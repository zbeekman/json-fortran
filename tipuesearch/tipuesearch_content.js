var tipuesearch = {"pages":[{"text":"JSON-Fortran Brief description License Official Releases Miscellaneous Brief description A user-friendly, thread-safe, and object-oriented API for reading and writing JSON files, written in modern Fortran. License The JSON -Fortran source code and related files and documentation are\ndistributed under a permissive free software license (BSD-style).  See\nthe LICENSE file for more details. Official Releases The current stable release is 5.0.2 and can be downloaded\non GitHub or installed with Homebrew on Mac OSX. The\ndocumentation for the current version, 5.0.2 , can be\nfound here 1 , and a\nlist of changes from the previous version are here . A list of all past releases, links to their documentation, and the\nchange log can be found on the releases page . Miscellaneous For more information about JSON , see: http://www.json.org/ Documentation for a particular release does not contain links\nback to general documentation; use the browser's back button to\nnavigate back to http://jacobwilliams.github.io/json-fortran/ â†© Developer Info Jacob Williams","tags":"","loc":"index.html","title":" JSON-Fortran "},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Higher-level [[json_file]] interface for the [[json_value]] type. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_file_module use , intrinsic :: iso_fortran_env use json_kinds use json_parameters , only : unit2str use json_string_utilities use json_value_module implicit none private #include \"json_macros.inc\" !********************************************************* !> author: Jacob Williams !  date: 12/9/2013 ! !  The `json_file` is the main public class that is !  used to open a file and get data from it. ! !  A `json_file` contains only two items: an instance of a [[json_core]], !  which use used for all data manipulation, and a [[json_value]], !  which is used to construct the linked-list data structure. !  Note that most methods in the `json_file` class are simply wrappers !  to the lower-level routines in the [[json_value_module]]. ! !# Example ! !```fortran !    program test !    use json_module !    implicit none !    type(json_file) :: json !    integer :: ival !    real(real64) :: rval !    character(len=:),allocatable :: cval !    logical :: found !    call json%initialize(compact_reals=.true.) !    call json%load_file(filename='myfile.json') !    call json%print_file() !print to the console !    call json%get('var.i',ival,found) !    call json%get('var.r(3)',rval,found) !    call json%get('var.c',cval,found) !    call json%destroy() !    end program test !``` type , public :: json_file private type ( json_core ) :: core !! The instance of the [[json_core]] factory used for this file. type ( json_value ), pointer :: p => null () !! the JSON structure read from the file contains generic , public :: initialize => initialize_json_core_in_file ,& set_json_core_in_file procedure , public :: get_core => get_json_core_in_file procedure , public :: load_file => json_file_load generic , public :: load_from_string => MAYBEWRAP ( json_file_load_from_string ) procedure , public :: destroy => json_file_destroy procedure , public :: move => json_file_move_pointer generic , public :: info => MAYBEWRAP ( json_file_variable_info ) !error checking: procedure , public :: failed => json_file_failed procedure , public :: print_error_message => json_file_print_error_message procedure , public :: check_for_errors => json_file_check_for_errors procedure , public :: clear_exceptions => json_file_clear_exceptions procedure , public :: print_to_string => json_file_print_to_string generic , public :: print_file => json_file_print_to_console , & json_file_print_1 , & json_file_print_2 generic , public :: get => MAYBEWRAP ( json_file_get_object ), & MAYBEWRAP ( json_file_get_integer ), & MAYBEWRAP ( json_file_get_double ), & MAYBEWRAP ( json_file_get_logical ), & MAYBEWRAP ( json_file_get_string ), & MAYBEWRAP ( json_file_get_integer_vec ), & MAYBEWRAP ( json_file_get_double_vec ), & MAYBEWRAP ( json_file_get_logical_vec ), & MAYBEWRAP ( json_file_get_string_vec ), & json_file_get_root generic , public :: update => MAYBEWRAP ( json_file_update_integer ), & MAYBEWRAP ( json_file_update_logical ), & MAYBEWRAP ( json_file_update_real ), & MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 generic , public :: update => json_file_update_string_name_ascii , & json_file_update_string_val_ascii #endif !traverse procedure , public :: traverse => json_file_traverse ! *************************************************** ! private routines ! *************************************************** !load from string: procedure :: MAYBEWRAP ( json_file_load_from_string ) !initialize procedure :: initialize_json_core_in_file procedure :: set_json_core_in_file !git info: procedure :: MAYBEWRAP ( json_file_variable_info ) !get: procedure :: MAYBEWRAP ( json_file_get_object ) procedure :: MAYBEWRAP ( json_file_get_integer ) procedure :: MAYBEWRAP ( json_file_get_double ) procedure :: MAYBEWRAP ( json_file_get_logical ) procedure :: MAYBEWRAP ( json_file_get_string ) procedure :: MAYBEWRAP ( json_file_get_integer_vec ) procedure :: MAYBEWRAP ( json_file_get_double_vec ) procedure :: MAYBEWRAP ( json_file_get_logical_vec ) procedure :: MAYBEWRAP ( json_file_get_string_vec ) procedure :: json_file_get_root !update: procedure :: MAYBEWRAP ( json_file_update_integer ) procedure :: MAYBEWRAP ( json_file_update_logical ) procedure :: MAYBEWRAP ( json_file_update_real ) procedure :: MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 procedure :: json_file_update_string_name_ascii procedure :: json_file_update_string_val_ascii #endif !print_file: procedure :: json_file_print_to_console procedure :: json_file_print_1 procedure :: json_file_print_2 end type json_file !********************************************************* !********************************************************* !> author: Izaak Beekman !  date: 07/23/2015 ! !  Structure constructor to initialize a [[json_file(type)]] object !  with an existing [[json_value]] object, and either the [[json_core]] !  settings or a [[json_core]] instance. ! !# Example ! !```fortran ! ... ! type(json_file)  :: my_file ! type(json_value),pointer :: json_object ! type(json_core) :: json_core_object ! ... ! ! Construct a json_object: ! !could do this: !   my_file = json_file(json_object) ! !or: !   my_file = json_file(json_object,verbose=.true.) ! !or: !   my_file = json_file(json_object,json_core_object) !``` interface json_file module procedure initialize_json_file , initialize_json_file_v2 end interface !************************************************************************************* contains !***************************************************************************************** !***************************************************************************************** !> !  Check error status in the file. pure function json_file_failed ( me ) result ( failed ) implicit none class ( json_file ), intent ( in ) :: me logical ( LK ) :: failed !! will be true if there has been an error. failed = me % core % failed () end function json_file_failed !***************************************************************************************** !***************************************************************************************** !> !  Retrieve error status and message from the class. subroutine json_file_check_for_errors ( me , status_ok , error_msg ) implicit none class ( json_file ), intent ( inout ) :: me logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) call me % core % check_for_errors ( status_ok , error_msg ) end subroutine json_file_check_for_errors !***************************************************************************************** !***************************************************************************************** !> !  Clear exceptions in the class. pure subroutine json_file_clear_exceptions ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % core % clear_exceptions () end subroutine json_file_clear_exceptions !***************************************************************************************** !***************************************************************************************** !> !  This is a wrapper for [[json_print_error_message]]. subroutine json_file_print_error_message ( me , io_unit ) implicit none class ( json_file ), intent ( inout ) :: me integer , intent ( in ), optional :: io_unit call me % core % print_error_message ( io_unit ) end subroutine json_file_print_error_message !***************************************************************************************** !***************************************************************************************** !> !  Initialize the [[json_core]] for this [[json_file]]. !  This is just a wrapper for [[json_initialize]]. ! !@note: This does not destroy the data in the file. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. subroutine initialize_json_core_in_file ( me , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) implicit none class ( json_file ), intent ( inout ) :: me logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call me % core % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) end subroutine initialize_json_core_in_file !***************************************************************************************** !***************************************************************************************** !> !  Set the [[json_core]] for this [[json_file]]. ! !@note: This does not destroy the data in the file. ! !@note: This one is used if you want to initialize the file with !       an already-existing [[json_core]] (presumably, this was already !       initialized by a call to [[initialize_json_core]] or similar). subroutine set_json_core_in_file ( me , core ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_core ), intent ( in ) :: core me % core = core end subroutine set_json_core_in_file !***************************************************************************************** !***************************************************************************************** !> !  Get a copy of the [[json_core]] in this [[json_file]]. subroutine get_json_core_in_file ( me , core ) implicit none class ( json_file ), intent ( in ) :: me type ( json_core ), intent ( out ) :: core core = me % core end subroutine get_json_core_in_file !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 07/23/2015 ! !  Cast a [[json_value]] object as a [[json_file(type)]] object. !  It also calls the `initialize()` method. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. function initialize_json_file ( p , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , optional , intent ( in ) :: p !! `json_value` object to cast !! as a `json_file` object logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call file_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) if ( present ( p )) file_object % p => p end function initialize_json_file !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Cast a [[json_value]] pointer and a [[json_core]] object !  as a [[json_file(type)]] object. function initialize_json_file_v2 ( json_value_object , json_core_object ) & result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , intent ( in ) :: json_value_object type ( json_core ), intent ( in ) :: json_core_object file_object % p => json_value_object file_object % core = json_core_object end function initialize_json_file_v2 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Destroy the [[json_value]] data in a [[json_file(type)]]. !  This must be done when the variable is no longer needed, !  or will be reused to open a different file. !  Otherwise a memory leak will occur. ! !  Optionally, also destroy the [[json_core]] instance (this !  is not necessary to prevent memory leaks, since a [[json_core]] !  does not use pointers). ! !### History !  * 12/9/2013 : Created !  * 4/26/2016 : Added optional `destroy_core` argument subroutine json_file_destroy ( me , destroy_core ) implicit none class ( json_file ), intent ( inout ) :: me logical , intent ( in ), optional :: destroy_core !! to also destroy the [[json_core]]. !! default is to leave it as is. if ( associated ( me % p )) call me % core % destroy ( me % p ) if ( present ( destroy_core )) then if ( destroy_core ) call me % core % destroy () end if end subroutine json_file_destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/5/2014 ! !  Move the [[json_value]] pointer from one [[json_file(type)]] to another. !  The \"from\" pointer is then nullified, but not destroyed. ! !@note If \"from%p\" is not associated, then an error is thrown. subroutine json_file_move_pointer ( to , from ) implicit none class ( json_file ), intent ( inout ) :: to class ( json_file ), intent ( inout ) :: from if ( associated ( from % p )) then if ( from % failed ()) then !Don't get the data if the FROM file has an !active exception, since it may not be valid. call to % core % throw_exception ( 'Error in json_file_move_pointer: ' // & 'error exception in FROM file.' ) else call to % initialize () !initialize and clear any exceptions that may be present to % p => from % p nullify ( from % p ) end if else call to % core % throw_exception ( 'Error in json_file_move_pointer: ' // & 'pointer is not associated.' ) end if end subroutine json_file_move_pointer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Load the JSON data from a file. ! !# Example ! !```fortran !     program main !      use json_module !      implicit none !      type(json_file) :: f !      call f%load_file('my_file.json') !      !... !      call f%destroy() !     end program main !``` subroutine json_file_load ( me , filename , unit ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to open integer ( IK ), intent ( in ), optional :: unit !! the unit number to use (if not present, a newunit is used) call me % core % parse ( file = filename , p = me % p , unit = unit ) end subroutine json_file_load !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/13/2015 ! !  Load the JSON data from a string. ! !# Example ! !  Load JSON from a string: !```fortran !     type(json_file) :: f !     call f%load_from_string('{ \"name\": \"Leonidas\" }') !``` subroutine json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: str !! string to load JSON data from call me % core % parse ( str = str , p = me % p ) end subroutine json_file_load_from_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_load_from_string]], where \"str\" is kind=CDK. subroutine wrap_json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: str call me % load_from_string ( to_unicode ( str )) end subroutine wrap_json_file_load_from_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON file to the console. subroutine json_file_print_to_console ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % core % print ( me % p , iunit = output_unit ) end subroutine json_file_print_to_console !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Prints the JSON file to the specified file unit number. subroutine json_file_print_1 ( me , iunit ) implicit none class ( json_file ), intent ( inout ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit number (must not be -1) if ( iunit /= unit2str ) then call me % core % print ( me % p , iunit = iunit ) else call me % core % throw_exception ( 'Error in json_file_print_1: iunit must not be -1.' ) end if end subroutine json_file_print_1 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON structure to the specified filename. !  The file is opened, printed, and then closed. ! !# Example !  Example loading a JSON file, changing a value, and then printing !  result to a new file: !```fortran !     type(json_file) :: f !     logical :: found !     call f%load_file('my_file.json')    !open the original file !     call f%update('version',4,found)    !change the value of a variable !     call f%print_file('my_file_2.json') !save file as new name !``` subroutine json_file_print_2 ( me , filename ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! filename to print to call me % core % print ( me % p , filename ) end subroutine json_file_print_2 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON file to a string. ! !# Example ! !  Open a JSON file, and then print the contents to a string: !```fortran !     type(json_file) :: f !     character(kind=CK,len=:),allocatable :: str !     call f%load_file('my_file.json') !     call f%print_file(str) !``` subroutine json_file_print_to_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: str !! string to print JSON data to call me % core % print_to_string ( me % p , str ) end subroutine json_file_print_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2014 ! !  Returns information about a variable in a [[json_file(type)]]. subroutine json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: found !! the variable exists in the structure integer ( IK ), intent ( out ) :: var_type !! variable type integer ( IK ), intent ( out ) :: n_children !! number of children type ( json_value ), pointer :: p !initialize: nullify ( p ) !get a pointer to the variable (if it is there): call me % get ( path , p , found ) if ( found ) then !get info: call me % core % info ( p , var_type , n_children ) else !set to dummy values: var_type = json_unknown n_children = 0 end if !cleanup: nullify ( p ) end subroutine json_file_variable_info !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_variable_info]], where \"path\" is kind=CDK. subroutine wrap_json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: found integer ( IK ), intent ( out ) :: var_type integer ( IK ), intent ( out ) :: n_children call me % info ( to_unicode ( path ), found , var_type , n_children ) end subroutine wrap_json_file_variable_info !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 7/23/2015 ! !  Get a [[json_value]] pointer to the JSON file root. ! !@note This is equivalent to calling ```[[json_file]]%get('$',p)``` subroutine json_file_get_root ( me , p ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable p => me % p end subroutine json_file_get_root !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2014 ! !  Get a [[json_value]] pointer to an object from a JSON file. subroutine json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , p = p , found = found ) end subroutine json_file_get_object !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_object]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), p , found ) end subroutine wrap_json_file_get_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get an integer value from a JSON file. subroutine json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_integer]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Get an integer vector from a JSON file. subroutine json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_integer_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a real(RK) variable value from a JSON file. subroutine json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_double]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Get a real(RK) vector from a JSON file. subroutine json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_double_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a logical(LK) value from a JSON file. subroutine json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_logical]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Get a logical(LK) vector from a JSON file. subroutine json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_logical_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a character string from a json file. !  The output val is an allocatable character string. subroutine json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_string]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Get a string vector from a JSON file. subroutine json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_string_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_string_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_integer]] subroutine json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , name , val , found ) end subroutine json_file_update_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_integer]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_logical]] subroutine json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , name , val , found ) end subroutine json_file_update_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_logical]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_double]] subroutine json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , name , val , found ) end subroutine json_file_update_real !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_real]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_real !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_string]] subroutine json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , name , val , found ) end subroutine json_file_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"name\" and \"val\" are kind=CDK. subroutine wrap_json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_file_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"name\" is kind=CDK. subroutine json_file_update_string_name_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine json_file_update_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"val\" is kind=CDK. subroutine json_file_update_string_val_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( name , to_unicode ( val ), found ) end subroutine json_file_update_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 6/11/2016 ! !  Traverse the JSON structure in the file. !  This routine calls the user-specified [[json_traverse_callback_func]] !  for each element of the structure. subroutine json_file_traverse ( me , traverse_callback ) implicit none class ( json_file ), intent ( inout ) :: me procedure ( json_traverse_callback_func ) :: traverse_callback call me % core % traverse ( me % p , traverse_callback ) end subroutine json_file_traverse !***************************************************************************************** !***************************************************************************************** end module json_file_module !*****************************************************************************************","tags":"","loc":"sourcefile/json_file_module.f90.html","title":"json_file_module.F90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  JSON-Fortran kind definitions. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. ! !@note ```-DUSE_UCS4``` is an optional preprocessor flag. !      When present, Unicode support is enabled. Note that this !      is currently only supported with the gfortran compiler. !      Example: ```gfortran -DUSE_UCS4 ... ``` #ifdef USE_UCS4 #  pragma push_macro(\"USE_UCS4\") #  undef USE_UCS4 !      The documentation given here assumes ```USE_UCS4``` **is** defined. #  pragma pop_macro(\"USE_UCS4\") #else !      The documentation given here assumes ```USE_UCS4``` **is not** defined. #endif ! !@warning ```CK``` and ```CDK``` are the JSON-Fortran character kind and JSON-Fortran default !         character kind respectively. Client code **MUST** ensure characters of ```kind=CK``` !         are used for all character variables and strings passed to the JSON-Fortran !         library *EXCEPT* for file names which must be of ```'DEFAULT'``` character kind, !         provided here as ```CDK```. In particular, any variable that is a: json path, string !         value or object name passed to the JSON-Fortran library **MUST** be of type ```CK```. ! !@note Most string literal constants of default kind are fine to pass as arguments to !      JSON-Fortran procedures since they have been overloaded to accept ```intent(in)``` !      character arguments of the default (```CDK```) kind. If you find a procedure which does !      not accept an ```intent(in)``` literal string argument of default kind, please !      [file an issue](https://github.com/jacobwilliams/json-fortran/issues/new) on GitHub. module json_kinds use , intrinsic :: iso_fortran_env , only : real64 , int32 , logical_kinds implicit none private integer , parameter , public :: RK = real64 !! Default real kind [8 bytes] integer , parameter , public :: IK = int32 !! Default integer kind [4 bytes]. !********************************************************* !> !  Processor dependendant 'DEFAULT' character kind. !  This is 1 byte for the Intel and Gfortran compilers. integer , parameter , public :: CDK = selected_char_kind ( 'DEFAULT' ) !********************************************************* !********************************************************* !> !  Default logical kind. !  This is 4 bytes for the Intel and Gfortran compilers !  (and perhaps others). !  The declaration ensures a valid kind !  if the compiler doesn't have a logical_kinds(3). ! integer , parameter , public :: LK = logical_kinds ( min ( 3 , size ( logical_kinds ))) !********************************************************* !********************************************************* !> !  String kind preprocessor macro. ! #if defined __GFORTRAN__ && defined USE_UCS4 ! gfortran compiler AND UCS4 support requested: character ( kind = CDK , len =* ), parameter :: json_fortran_string_kind = 'ISO_10646' #else ! this is the string kind to use unless compiling with GFortran AND ! UCS4/ISO 10646 support is requested character ( kind = CDK , len =* ), parameter :: json_fortran_string_kind = 'DEFAULT' #endif !********************************************************* !********************************************************* !> !  Default character kind used by JSON-Fortran. !  If ISO 10646 (UCS4) support is available, use that, !  otherwise, gracefully fall back on 'DEFAULT' characters. !  Currently only gfortran >= 4.9.2 will correctly support !  UCS4 which is stored in 4 bytes. !  (and perhaps others). integer , parameter , public :: CK = selected_char_kind ( json_fortran_string_kind ) !********************************************************* end module json_kinds !*****************************************************************************************","tags":"","loc":"sourcefile/json_kinds.f90.html","title":"json_kinds.F90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  A Fortran 2008 JSON (JavaScript Object Notation) API. ! !  This module provides access to [[json_value_module]] and !  [[json_file_module]]. For normal JSON-Fortran use, using this module !  is all that is necessary. ! !  Note that this module renames the kind definition variables from [[json_kinds]] !  from [`RK`, `IK`, `LK`, `CK`, and `CDK`] to [`json_RK`, `json_IK`, `json_LK`, !  `json_CK`, and `json_CDK`] so as to avoid namespace pollution with short !  variable names. ! #ifdef USE_UCS4 #pragma push_macro(\"USE_UCS4\") #undef USE_UCS4 !  Since ```USE_UCS4``` **is** defined, this module also exports the !  operators `==`, `/=`, and `//` from [[json_string_utilities]] for !  `CK` and `CDK` operations. #pragma pop_macro(\"USE_UCS4\") #endif ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. ! !## History !  * Joseph A. Levin : March 2012 : Original [FSON](https://github.com/josephalevin/fson) !    code [retrieved on 12/2/2013]. !  * Jacob Williams : 2/8/2014 : Extensive modifications to the original FSON code. !    The original F95 code was split into four files: !    fson_path_m.f95, fson_string_m.f95, fson_value_m.f95, and fson.f95. !    The new code has been extensively updated, refactored and combined into this !    one module (json_module.f90). !    Various Fortran 2003/2008 features are now used !    (e.g., allocatable strings, newunit, generic, class, and abstract interface). !  * Development continues at: [Github](http://github.com/jacobwilliams/json-fortran) ! !## See also !  * [json-fortran development site](http://github.com/jacobwilliams/json-fortran) !  * [json-fortran online documentation](http://jacobwilliams.github.io/json-fortran) !  * [JSON website](http://www.json.org/) !  * [JSON validator](http://jsonlint.com/) ! !@note Originally JSON-Fortran was entirely contained within this module. module json_module use json_kinds , only : json_RK => RK , & json_IK => IK , & json_LK => LK , & json_CK => CK , & json_CDK => CDK #ifdef USE_UCS4 use json_string_utilities , only : operator ( == ),& operator ( // ),& operator ( /= ) #endif use json_value_module use json_file_module implicit none public end module json_module !*****************************************************************************************","tags":"","loc":"sourcefile/json_module.f90.html","title":"json_module.F90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Other parameters used by JSON-Fortran. !  This is a low-level module not meant to be used by a JSON-Fortran user. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_parameters use json_kinds implicit none public character ( kind = CDK , len =* ), parameter :: json_ext = '.json' !! JSON file extension !special JSON characters character ( kind = CK , len =* ), parameter :: space = ' ' character ( kind = CK , len =* ), parameter :: start_object = '{' character ( kind = CK , len =* ), parameter :: end_object = '}' character ( kind = CK , len =* ), parameter :: start_array = '[' character ( kind = CK , len =* ), parameter :: end_array = ']' character ( kind = CK , len =* ), parameter :: delimiter = ',' character ( kind = CK , len =* ), parameter :: colon_char = ':' character ( kind = CK , len =* ), parameter :: start_array_alt = '(' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: end_array_alt = ')' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: root = '$' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: this = '@' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: child = '.' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: bspace = achar ( 8 ) character ( kind = CK , len =* ), parameter :: horizontal_tab = achar ( 9 ) character ( kind = CK , len =* ), parameter :: newline = achar ( 10 ) character ( kind = CK , len =* ), parameter :: formfeed = achar ( 12 ) character ( kind = CK , len =* ), parameter :: carriage_return = achar ( 13 ) character ( kind = CK , len =* ), parameter :: quotation_mark = achar ( 34 ) character ( kind = CK , len =* ), parameter :: slash = achar ( 47 ) character ( kind = CK , len =* ), parameter :: backslash = achar ( 92 ) character ( kind = CDK , len =* ), parameter , public :: default_real_fmt = '(ss,E26.16E4)' !! default real number format statement (for writing real values to strings and files). !! Note that this can be overridden by calling [[json_initialize]]. character ( kind = CK , len =* ), parameter , public :: star = '*' !! for invalid numbers and !! list-directed real output #if defined __GFORTRAN__ !not parameters due to gfortran bug (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65141) character ( kind = CK , len = 26 ), protected :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! uppercase characters character ( kind = CK , len = 26 ), protected :: lower = 'abcdefghijklmnopqrstuvwxyz' !! lowercase characters #else character ( kind = CK , len =* ), parameter , public :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! uppercase characters character ( kind = CK , len =* ), parameter , public :: lower = 'abcdefghijklmnopqrstuvwxyz' !! lowercase characters #endif #if defined __GFORTRAN__ !not parameters due to gfortran bug (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65141) character ( kind = CK , len = 4 ), protected :: null_str = 'null' !! JSON Null variable string character ( kind = CK , len = 4 ), protected :: true_str = 'true' !! JSON logical True string character ( kind = CK , len = 5 ), protected :: false_str = 'false' !! JSON logical False string #else character ( kind = CK , len =* ), parameter , public :: null_str = 'null' !! JSON Null variable string character ( kind = CK , len =* ), parameter , public :: true_str = 'true' !! JSON logical True string character ( kind = CK , len =* ), parameter , public :: false_str = 'false' !! JSON logical False string #endif integer , private :: i_ !! just a counter for `control_chars` array character ( kind = CK , len =* ), dimension ( 32 ), parameter :: control_chars = & [( achar ( i_ ), i_ = 1 , 31 ), achar ( 127 )] !! Control characters, possibly in unicode !find out the precision of the floating point number system !and set safety factors integer ( IK ), parameter :: rp_safety_factor = 1_IK integer ( IK ), parameter :: rp_addl_safety = 1_IK integer ( IK ), parameter :: real_precision = rp_safety_factor * precision ( 1.0_RK ) + & rp_addl_safety !Get the number of possible digits in the exponent when using decimal number system integer ( IK ), parameter :: maxexp = maxexponent ( 1.0_RK ) integer ( IK ), parameter :: minexp = minexponent ( 1.0_RK ) integer ( IK ), parameter :: real_exponent_digits = floor ( 1 + log10 ( & real ( max ( maxexp , abs ( maxexp )),& kind = RK ) ) ) integer ( IK ), parameter :: max_numeric_str_len = real_precision + real_exponent_digits + 6 !! 6 = sign + leading 0 + decimal + 'E' + exponent sign + 1 extra character ( kind = CDK , len =* ), parameter :: int_fmt = '(ss,I0)' !! minimum width format for integers integer ( IK ), parameter :: chunk_size = 100_IK !! for allocatable strings: allocate chunks of this size integer ( IK ), parameter :: unit2str = - 1_IK !! unit number to cause stuff to be !! output to strings rather than files. !! See 9.5.6.12 in the F2003/08 standard integer ( IK ), parameter , public :: seq_chunk_size = 256_IK !! chunk size for reading sequential files integer ( IK ), parameter , public :: pushed_char_size = 10_IK !! magic number end module json_parameters !*****************************************************************************************","tags":"","loc":"sourcefile/json_parameters.f90.html","title":"json_parameters.F90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  JSON-Fortran support module for string manipulation. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_string_utilities use json_kinds use json_parameters implicit none private !****************************************************** !> !  Convert a 'DEFAULT' kind character input to !  'ISO_10646' kind and return it interface to_unicode module procedure to_uni , to_uni_vec end interface !****************************************************** #ifdef USE_UCS4 !****************************************************** !> ! Provide a means to convert to UCS4 while ! concatenating UCS4 and default strings interface operator ( // ) module procedure ucs4_join_default , default_join_ucs4 end interface public :: operator ( // ) !****************************************************** !****************************************************** !> ! Provide a string `==` operator that works ! with mixed kinds interface operator ( == ) module procedure ucs4_comp_default , default_comp_ucs4 end interface public :: operator ( == ) !****************************************************** !****************************************************** !> ! Provide a string `/=` operator that works ! with mixed kinds interface operator ( /= ) module procedure ucs4_neq_default , default_neq_ucs4 end interface public :: operator ( /= ) !****************************************************** #endif public :: integer_to_string public :: real_to_string public :: valid_json_hex public :: to_unicode public :: escape_string public :: unescape_string public :: lowercase_string contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Convert an integer to a string. pure subroutine integer_to_string ( ival , int_fmt , str ) implicit none integer ( IK ), intent ( in ) :: ival !! integer value. character ( kind = CDK , len =* ), intent ( in ) :: int_fmt !! format for integers character ( kind = CK , len =* ), intent ( out ) :: str !! `ival` converted to a string. integer ( IK ) :: istat write ( str , fmt = int_fmt , iostat = istat ) ival if ( istat == 0 ) then str = adjustl ( str ) else str = repeat ( star , len ( str )) end if end subroutine integer_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Convert a real value to a string. ! !# Modified !  * Izaak Beekman : 02/24/2015 : added the compact option. !  * Jacob Williams : 10/27/2015 : added the star option. subroutine real_to_string ( rval , real_fmt , compact_real , str ) implicit none real ( RK ), intent ( in ) :: rval !! real value. character ( kind = CDK , len =* ), intent ( in ) :: real_fmt !! format for real numbers logical ( LK ), intent ( in ) :: compact_real !! compact the string so that it is !! displayed with fewer characters character ( kind = CK , len =* ), intent ( out ) :: str !! `rval` converted to a string. integer ( IK ) :: istat if ( real_fmt == star ) then write ( str , fmt =* , iostat = istat ) rval else write ( str , fmt = real_fmt , iostat = istat ) rval end if if ( istat == 0 ) then !in this case, the default string will be compacted, ! so that the same value is displayed with fewer characters. if ( compact_real ) call compact_real_string ( str ) else str = repeat ( star , len ( str )) end if end subroutine real_to_string !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 02/24/2015 ! !  Compact a string representing a real number, so that !  the same value is displayed with fewer characters. ! !# See also !  * [[real_to_string]] subroutine compact_real_string ( str ) implicit none character ( kind = CK , len =* ), intent ( inout ) :: str !! string representation of a real number. character ( kind = CK , len = len ( str )) :: significand character ( kind = CK , len = len ( str )) :: expnt character ( kind = CK , len = 2 ) :: separator integer ( IK ) :: exp_start integer ( IK ) :: decimal_pos integer ( IK ) :: sig_trim integer ( IK ) :: exp_trim integer ( IK ) :: i !! counter str = adjustl ( str ) exp_start = scan ( str , CK_ 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , CK_ '-+' , back = . true .) decimal_pos = scan ( str , CK_ '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine compact_real_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/21/2014 ! !  Add the escape characters to a string for adding to JSON. subroutine escape_string ( str_in , str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out integer ( IK ) :: i !! counter integer ( IK ) :: ipos !! accumulated string size !! (so we can allocate it in chunks for !! greater runtime efficiency) character ( kind = CK , len = 1 ) :: c !! for reading `str_in` one character at a time. #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! workaround for bug in gfortran 6.1 #endif character ( kind = CK , len =* ), parameter :: specials = quotation_mark // & backslash // & slash // & bspace // & formfeed // & newline // & carriage_return // & horizontal_tab !Do a quick scan for the special characters, ! if any are present, then process the string, ! otherwise, return the string as is. if ( scan ( str_in , specials ) > 0 ) then str_out = repeat ( space , chunk_size ) ipos = 1 !go through the string and look for special characters: do i = 1 , len ( str_in ) c = str_in ( i : i ) !get next character in the input string !if the string is not big enough, then add another chunk: if ( ipos + 3 > len ( str_out )) str_out = str_out // repeat ( space , chunk_size ) select case ( c ) case ( quotation_mark , backslash , slash ) str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( bspace ) str_out ( ipos : ipos + 1 ) = '\\b' ipos = ipos + 2 case ( formfeed ) str_out ( ipos : ipos + 1 ) = '\\f' ipos = ipos + 2 case ( newline ) str_out ( ipos : ipos + 1 ) = '\\n' ipos = ipos + 2 case ( carriage_return ) str_out ( ipos : ipos + 1 ) = '\\r' ipos = ipos + 2 case ( horizontal_tab ) str_out ( ipos : ipos + 1 ) = '\\t' ipos = ipos + 2 case default str_out ( ipos : ipos ) = c ipos = ipos + 1 end select end do !trim the string if necessary: if ( ipos < len ( str_out ) + 1 ) then if ( ipos == 1 ) then str_out = '' else #if defined __GFORTRAN__ tmp = str_out ( 1 : ipos - 1 ) !workaround for bug in gfortran 6.1 str_out = tmp #else str_out = str_out ( 1 : ipos - 1 ) !original #endif end if end if else str_out = str_in end if end subroutine escape_string !***************************************************************************************** !***************************************************************************************** !> !  Remove the escape characters from a JSON string and return it. ! !  The escaped characters are denoted by the '\\' character: !```` !    '\\\"'        quotation mark !    '\\\\'        reverse solidus !    '\\/'        solidus !    '\\b'        backspace !    '\\f'        formfeed !    '\\n'        newline (LF) !    '\\r'        carriage return (CR) !    '\\t'        horizontal tab !    '\\uXXXX'    4 hexadecimal digits !```` subroutine unescape_string ( str_in , str_out , error_message ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in !! string as stored in a [[json_value]] character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out !! decoded string character ( kind = CK , len = :), allocatable , intent ( out ) :: error_message !! will be allocated if there was an error integer :: i !! counter integer :: n !! length of str_in integer :: m !! length of str_out character ( kind = CK , len = 1 ) :: c !! for scanning each character in string if ( scan ( str_in , backslash ) > 0 ) then !there is at least one escape character, so process this string: n = len ( str_in ) str_out = repeat ( space , n ) !size the output string (will be trimmed later) m = 0 !counter in str_out i = 0 !counter in str_in do i = i + 1 if ( i > n ) exit ! finished c = str_in ( i : i ) ! get next character in the string if ( c == backslash ) then if ( i < n ) then i = i + 1 c = str_in ( i : i ) !character after the escape if ( any ( c == [ quotation_mark , backslash , slash , & to_unicode ([ 'b' , 'f' , 'n' , 'r' , 't' ])])) then select case ( c ) case ( quotation_mark , backslash , slash ) !use d as is case ( CK_ 'b' ) c = bspace case ( CK_ 'f' ) c = formfeed case ( CK_ 'n' ) c = newline case ( CK_ 'r' ) c = carriage_return case ( CK_ 't' ) c = horizontal_tab end select m = m + 1 str_out ( m : m ) = c else if ( c == 'u' ) then !expecting 4 hexadecimal digits after !the escape character    [\\uXXXX] !for now, we are just returning them as is ![not checking to see if it is a valid hex value] ! ! Example: !   123456 !   \\uXXXX if ( i + 4 <= n ) then m = m + 1 str_out ( m : m + 5 ) = str_in ( i - 1 : i + 4 ) i = i + 4 m = m + 5 else error_message = 'Error in unescape_string:' // & ' Invalid hexadecimal sequence' // & ' in string: ' // str_in ( i - 1 :) if ( allocated ( str_out )) deallocate ( str_out ) return end if else !unknown escape character error_message = 'Error in unescape_string:' // & ' unknown escape sequence in string \"' // & trim ( str_in ) // '\" [' // backslash // c // ']' if ( allocated ( str_out )) deallocate ( str_out ) return end if else !an escape character is the last character in ! the string [this may not be valid syntax, ! but just keep it] m = m + 1 str_out ( m : m ) = c end if else m = m + 1 str_out ( m : m ) = c end if end do !trim trailing space: str_out = str_out ( 1 : m ) else !there are no escape characters, so return as is: str_out = str_in end if end subroutine unescape_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:6/14/2014 ! !  Returns true if the string is a valid 4-digit hex string. ! !# Examples !```fortran !    valid_json_hex('0000')  !returns true !    valid_json_hex('ABC4')  !returns true !    valid_json_hex('AB')    !returns false (< 4 characters) !    valid_json_hex('WXYZ')  !returns false (invalid characters) !``` pure function valid_json_hex ( str ) result ( valid ) implicit none logical ( LK ) :: valid !! is str a value 4-digit hex string character ( kind = CK , len =* ), intent ( in ) :: str !! the string to check. integer ( IK ) :: n !! length of `str` integer ( IK ) :: i !! counter !> an array of the valid hex characters character ( kind = CK , len = 1 ), dimension ( 22 ), parameter :: valid_chars = & [ ( achar ( i ), i = 48 , 57 ), & ! decimal digits ( achar ( i ), i = 65 , 70 ), & ! capital A-F ( achar ( i ), i = 97 , 102 ) ] ! lowercase a-f !initialize valid = . false . !check all the characters in the string: n = len ( str ) if ( n == 4 ) then do i = 1 , n if (. not . any ( str ( i : i ) == valid_chars )) return end do valid = . true . !all are in the set, so it is OK end if end function valid_json_hex !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Convert string to unicode (CDK to CK). pure function to_uni ( str ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: str character ( kind = CK , len = len ( str )) :: to_uni to_uni = str end function to_uni !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Convert array of strings to unicode (CDK to CK). ! !@note JW: may be able to remove this by making [[to_uni]] PURE ELEMENTAL ? pure function to_uni_vec ( str ) implicit none character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: str character ( kind = CK , len = len ( str )), dimension ( size ( str )) :: to_uni_vec to_uni_vec = str end function to_uni_vec !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CK`//`CDK` operator. pure function ucs4_join_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len = ( len ( ucs4_str ) + len ( def_str ))) :: res res = ucs4_str // to_unicode ( def_str ) end function ucs4_join_default !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CDK`//`CK` operator. pure function default_join_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CK , len = ( len ( def_str ) + len ( ucs4_str ))) :: res res = to_unicode ( def_str ) // ucs4_str end function default_join_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CK`==`CDK` operator. pure elemental function ucs4_comp_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str == to_unicode ( def_str ) ) end function ucs4_comp_default !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CDK`==`CK` operator. pure elemental function default_comp_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) == ucs4_str ) end function default_comp_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  `CK`/=`CDK` operator. pure elemental function ucs4_neq_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str /= to_unicode ( def_str ) ) end function ucs4_neq_default !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  `CDK`/=`CK` operator. pure elemental function default_neq_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) /= ucs4_str ) end function default_neq_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Return the lowercase version of the `CK` character. pure elemental function lowercase_character ( c ) result ( c_lower ) implicit none character ( kind = CK , len = 1 ), intent ( in ) :: c character ( kind = CK , len = 1 ) :: c_lower integer :: i !! index in uppercase array i = index ( upper , c ) c_lower = merge ( lower ( i : i ), c , i > 0 ) end function lowercase_character !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Returns lowercase version of the `CK` string. pure elemental function lowercase_string ( str ) result ( s_lower ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! input string character ( kind = CK , len = ( len ( str ))) :: s_lower !! lowercase version of the string integer :: i !! counter integer :: n !! length of input string s_lower = '' n = len_trim ( str ) if ( n > 0 ) then do concurrent ( i = 1 : n ) s_lower ( i : i ) = lowercase_character ( str ( i : i )) end do end if end function lowercase_string !***************************************************************************************** end module json_string_utilities !*****************************************************************************************","tags":"","loc":"sourcefile/json_string_utilities.f90.html","title":"json_string_utilities.F90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  This module provides a low-level interface for manipulation of JSON data. !  The two public entities are [[json_value]], and [[json_core]]. !  The [[json_file_module]] provides a higher-level interface to some !  of these routines. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_value_module use , intrinsic :: iso_fortran_env , only : iostat_end , error_unit , output_unit use json_kinds use json_parameters use json_string_utilities implicit none private #include \"json_macros.inc\" !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 logical , parameter :: use_unformatted_stream = . false . #else logical , parameter :: use_unformatted_stream = . true . #endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 character ( kind = CDK , len =* ), parameter :: access_spec = 'SEQUENTIAL' #else character ( kind = CDK , len =* ), parameter :: access_spec = 'STREAM' #endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 character ( kind = CDK , len =* ), parameter :: form_spec = 'FORMATTED' #else character ( kind = CDK , len =* ), parameter :: form_spec = 'UNFORMATTED' #endif !********************************************************* !********************************************************* ! !  The types of JSON data. ! integer ( IK ), parameter , public :: json_unknown = 0 !! Unknown JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_null = 1 !! Null JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_object = 2 !! Object JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_array = 3 !! Array JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_logical = 4 !! Logical JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_integer = 5 !! Integer JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_double = 6 !! Double JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_string = 7 !! String JSON data type !********************************************************* !********************************************************* !> !  Type used to construct the linked-list JSON structure. !  Normally, this should always be a pointer variable. !  This type should only be used by an instance of [[json_core]]. ! !# Example ! !  The following test program: ! !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json !     type(json_value),pointer :: p !     call json%create_object(p,'')   !create the root !     call json%add(p,'year',1805)    !add some data !     call json%add(p,'value',1.0_RK) !add some data !     call json%print(p,'test.json')  !write it to a file !     call json%destroy(p)            !cleanup !    end program test !```` ! !  Produces the JSON file **test.json**: ! !````json !    { !      \"year\": 1805, !      \"value\": 0.1E+1 !    } !```` type , public :: json_value !force the constituents to be stored contiguously ![note: on Intel, the order of the variables below ! is significant to avoid the misaligned field warnings] sequence private !for the linked list: type ( json_value ), pointer :: previous => null () !! previous item in the list type ( json_value ), pointer :: next => null () !! next item in the list type ( json_value ), pointer :: parent => null () !! parent item of this type ( json_value ), pointer :: children => null () !! first child item of this type ( json_value ), pointer :: tail => null () !! last child item of this character ( kind = CK , len = :), allocatable :: name !! variable name real ( RK ), allocatable :: dbl_value !! real data for this variable logical ( LK ), allocatable :: log_value !! logical data for this variable character ( kind = CK , len = :), allocatable :: str_value !! string data for this variable integer ( IK ), allocatable :: int_value !! integer data for this variable integer ( IK ) :: var_type = json_unknown !! variable type integer ( IK ), private :: n_children = 0 !! number of children end type json_value !********************************************************* !********************************************************* !> !  To access the core routines for manipulation !  of [[json_value]] pointer variables. This class allows !  for thread safe use of the module. ! !### Usage !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json     !<--have to declare this !     type(json_value),pointer :: p !     call json%create_object(p,'')   !create the root !     call json%add(p,'year',1805)    !add some data !     call json%add(p,'value',1.0_RK) !add some data !     call json%print(p,'test.json')  !write it to a file !     call json%destroy(p)            !cleanup !    end program test !    type,public :: json_core !```` type , public :: json_core private integer ( IK ) :: spaces_per_tab = 2 !! number of spaces for indenting logical ( LK ) :: compact_real = . true . !! to use the \"compact\" form of real !! numbers for output character ( kind = CDK , len = :), allocatable :: real_fmt !! the format string to use !! for converting real numbers to strings. !! It can be set in [[json_initialize]], !! and used in [[json_value_print]] !! If not set, then `default_real_fmt` !! is used instead. logical ( LK ) :: is_verbose = . false . !! if true, all exceptions are !! immediately printed to console. logical ( LK ) :: exception_thrown = . false . !! The error flag. Will be set to true !! when an error is thrown in the class. !! Many of the methods will check this !! and return immediately if it is true. character ( kind = CK , len = :), allocatable :: err_message !! the error message integer ( IK ) :: char_count = 0 !! character position in the current line integer ( IK ) :: line_count = 1 !! lines read counter integer ( IK ) :: pushed_index = 0 !! used when parsing lines in file character ( kind = CK , len = pushed_char_size ) :: pushed_char = '' !! used when parsing !! lines in file integer ( IK ) :: ipos = 1 !! for allocatable strings: next character to read logical ( LK ) :: strict_type_checking = . false . !! if true, then no type conversions are done !! in the `get` routines if the actual variable !! type is different from the return type (for !! example, integer to double). logical ( LK ) :: trailing_spaces_significant = . false . !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ) :: case_sensitive_keys = . true . !! for name and path comparisons, are they !! case sensitive. contains private generic , public :: get_child => json_value_get_by_index , & json_value_get_child ,& MAYBEWRAP ( json_value_get_by_name_chars ) procedure , private :: json_value_get_by_index procedure , private :: MAYBEWRAP ( json_value_get_by_name_chars ) procedure , private :: json_value_get_child !> !  Add objects to a linked list of [[json_value]]s. generic , public :: add => json_value_add_member , & MAYBEWRAP ( json_value_add_integer ), & MAYBEWRAP ( json_value_add_integer_vec ), & MAYBEWRAP ( json_value_add_double ), & MAYBEWRAP ( json_value_add_double_vec ), & MAYBEWRAP ( json_value_add_logical ), & MAYBEWRAP ( json_value_add_logical_vec ), & MAYBEWRAP ( json_value_add_string ), & MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 generic , public :: add => json_value_add_string_name_ascii , & json_value_add_string_val_ascii , & json_value_add_string_vec_name_ascii , & json_value_add_string_vec_val_ascii #endif procedure , private :: json_value_add_member procedure , private :: MAYBEWRAP ( json_value_add_integer ) procedure , private :: MAYBEWRAP ( json_value_add_integer_vec ) procedure , private :: MAYBEWRAP ( json_value_add_double ) procedure , private :: MAYBEWRAP ( json_value_add_double_vec ) procedure , private :: MAYBEWRAP ( json_value_add_logical ) procedure , private :: MAYBEWRAP ( json_value_add_logical_vec ) procedure , private :: MAYBEWRAP ( json_value_add_string ) procedure , private :: MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 procedure , private :: json_value_add_string_name_ascii procedure , private :: json_value_add_string_val_ascii procedure , private :: json_value_add_string_vec_name_ascii procedure , private :: json_value_add_string_vec_val_ascii #endif !> !  These are like the `add` methods, except if a child with the !  same name is already present, then its value is simply updated. !  Note that currently, these only work for scalar variables. !  These routines can also change the variable's type (but an error will be !  thrown if the existing variable is not a scalar). ! !@note It should not be used to change the type of a variable in an array, !      or it may result in an invalid JSON file. generic , public :: update => MAYBEWRAP ( json_update_logical ),& MAYBEWRAP ( json_update_double ),& MAYBEWRAP ( json_update_integer ),& MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 generic , public :: update => json_update_string_name_ascii ,& json_update_string_val_ascii #endif procedure , private :: MAYBEWRAP ( json_update_logical ) procedure , private :: MAYBEWRAP ( json_update_double ) procedure , private :: MAYBEWRAP ( json_update_integer ) procedure , private :: MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 procedure , private :: json_update_string_name_ascii procedure , private :: json_update_string_val_ascii #endif !> !  Get data from a [[json_value]] linked list. ! !@note There are two versions (e.g. [[json_get_integer]] and [[json_get_integer_with_path]]). !      The first one gets the value from the [[json_value]] passed into the routine, !      while the second one gets the value from the [[json_value]] found by parsing the !      path.  The path version is split up into unicode and non-unicode versions. generic , public :: get => & MAYBEWRAP ( json_get_by_path ), & json_get_integer , MAYBEWRAP ( json_get_integer_with_path ), & json_get_integer_vec , MAYBEWRAP ( json_get_integer_vec_with_path ), & json_get_double , MAYBEWRAP ( json_get_double_with_path ), & json_get_double_vec , MAYBEWRAP ( json_get_double_vec_with_path ), & json_get_logical , MAYBEWRAP ( json_get_logical_with_path ), & json_get_logical_vec , MAYBEWRAP ( json_get_logical_vec_with_path ), & json_get_string , MAYBEWRAP ( json_get_string_with_path ), & json_get_string_vec , MAYBEWRAP ( json_get_string_vec_with_path ), & json_get_array , MAYBEWRAP ( json_get_array_with_path ) procedure , private :: json_get_integer procedure , private :: json_get_integer_vec procedure , private :: json_get_double procedure , private :: json_get_double_vec procedure , private :: json_get_logical procedure , private :: json_get_logical_vec procedure , private :: json_get_string procedure , private :: json_get_string_vec procedure , private :: json_get_array procedure , private :: MAYBEWRAP ( json_get_by_path ) procedure , private :: MAYBEWRAP ( json_get_integer_with_path ) procedure , private :: MAYBEWRAP ( json_get_integer_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_double_with_path ) procedure , private :: MAYBEWRAP ( json_get_double_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_logical_with_path ) procedure , private :: MAYBEWRAP ( json_get_logical_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_string_with_path ) procedure , private :: MAYBEWRAP ( json_get_string_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_array_with_path ) procedure , public :: print_to_string => json_value_to_string !! Print the [[json_value]] structure to an allocatable string !> !  Print the [[json_value]] to a file. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value) :: p !    !... !    call json%print(p,'test.json')  !this is [[json_print_2]] !```` generic , public :: print => json_print_1 , json_print_2 procedure :: json_print_1 procedure :: json_print_2 !> !  Destructor routine for a [[json_value]] pointer. !  This must be called explicitly if it is no longer needed, !  before it goes out of scope.  Otherwise, a memory leak will result. ! !# Example ! !  Destroy the [[json_value]] pointer before the variable goes out of scope: !````fortran !     subroutine example1() !     type(json_core) :: json !     type(json_value),pointer :: p !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%print(p) !     call json%destroy(p) !     end subroutine example1 !```` ! !  Note: it should NOT be called for a [[json_value]] pointer than has already been !  added to another [[json_value]] structure, since doing so may render the !  other structure invalid.  Consider the following example: !````fortran !     subroutine example2(p) !     type(json_core) :: json !     type(json_value),pointer,intent(out) :: p !     type(json_value),pointer :: q !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%create_object(q,'q') !     call json%add(q,'val',1) !     call json%add(p, q)  !add q to p structure !     ! do NOT call json%destroy(q) here, because q is !     ! now part of the output structure p.  p should be destroyed !     ! somewhere upstream by the caller of this routine. !     nullify(q) !OK, but not strictly necessary !     end subroutine example2 !```` generic , public :: destroy => json_value_destroy , destroy_json_core procedure :: json_value_destroy procedure :: destroy_json_core !> !  If the child variable is present, then remove it. generic , public :: remove_if_present => MAYBEWRAP ( json_value_remove_if_present ) procedure :: MAYBEWRAP ( json_value_remove_if_present ) !> !  Allocate a [[json_value]] pointer and make it a double variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_double(p,'value',1.0_RK) !```` generic , public :: create_double => MAYBEWRAP ( json_value_create_double ) procedure :: MAYBEWRAP ( json_value_create_double ) !> !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_array(p,'arrayname') !```` generic , public :: create_array => MAYBEWRAP ( json_value_create_array ) procedure :: MAYBEWRAP ( json_value_create_array ) !> !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_object(p,'objectname') !```` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. generic , public :: create_object => MAYBEWRAP ( json_value_create_object ) procedure :: MAYBEWRAP ( json_value_create_object ) !> !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_null(p,'value') !```` generic , public :: create_null => MAYBEWRAP ( json_value_create_null ) procedure :: MAYBEWRAP ( json_value_create_null ) !> !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_string(p,'value','foobar') !```` generic , public :: create_string => MAYBEWRAP ( json_value_create_string ) procedure :: MAYBEWRAP ( json_value_create_string ) !> !  Allocate a json_value pointer and make it an integer variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_integer(p,'value',42) !```` generic , public :: create_integer => MAYBEWRAP ( json_value_create_integer ) procedure :: MAYBEWRAP ( json_value_create_integer ) !> !  Allocate a json_value pointer and make it a logical variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_logical(p,'value',.true.) !```` generic , public :: create_logical => MAYBEWRAP ( json_value_create_logical ) procedure :: MAYBEWRAP ( json_value_create_logical ) !> !  Parse the JSON file and populate the [[json_value]] tree. generic , public :: parse => json_parse_file , MAYBEWRAP ( json_parse_string ) procedure :: json_parse_file procedure :: MAYBEWRAP ( json_parse_string ) !> !  Throw an exception. generic , public :: throw_exception => MAYBEWRAP ( json_throw_exception ) procedure :: MAYBEWRAP ( json_throw_exception ) !> !  Rename a [[json_value]] variable. generic , public :: rename => MAYBEWRAP ( json_value_rename ) procedure :: MAYBEWRAP ( json_value_rename ) procedure , public :: remove => json_value_remove !! Remove a [[json_value]] from a linked-list structure. procedure , public :: check_for_errors => json_check_for_errors !! check for error and get error message procedure , public :: clear_exceptions => json_clear_exceptions !! clear exceptions procedure , public :: count => json_count !! count the number of children procedure , public :: clone => json_clone !! clone a JSON structure (deep copy) procedure , public :: failed => json_failed !! check for error procedure , public :: get_parent => json_get_parent !! get pointer to json_value parent procedure , public :: get_next => json_get_next !! get pointer to json_value next procedure , public :: get_previous => json_get_previous !! get pointer to json_value previous procedure , public :: get_tail => json_get_tail !! get pointer to json_value tail procedure , public :: info => json_info !! get info about a json_value procedure , public :: initialize => json_initialize !! to initialize some parsing parameters procedure , public :: traverse => json_traverse !! to traverse all elements of a JSON structure procedure , public :: print_error_message => json_print_error_message !! simply routine to print error messages procedure , public :: swap => json_value_swap !! Swap two [[json_value]] pointers !! in a structure (or two different structures). procedure , public :: is_child_of => json_value_is_child_of !! Check if a [[json_value]] is a child of another. procedure , public :: validate => json_value_validate !! Check that a [[json_value]] linked list is valid !! (i.e., is properly constructed). This may be !! useful if it has been constructed externally. !other private routines: procedure :: name_equal procedure :: json_value_print procedure :: string_to_integer procedure :: string_to_double procedure :: parse_value procedure :: parse_number procedure :: parse_string procedure :: parse_for_chars procedure :: parse_object procedure :: parse_array procedure :: annotate_invalid_json procedure :: pop_char procedure :: push_char procedure :: get_current_line_from_file_stream procedure :: get_current_line_from_file_sequential end type json_core !********************************************************* !********************************************************* !> !  Structure constructor to initialize a !  [[json_core]] object ! !# Example ! !```fortran ! type(json_file)  :: json_core ! json_core = json_core() !``` interface json_core module procedure initialize_json_core end interface !********************************************************* !************************************************************************************* abstract interface subroutine json_array_callback_func ( json , element , i , count ) !! Array element callback function.  Used by [[json_get_array]] import :: json_value , json_core , IK implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array end subroutine json_array_callback_func subroutine json_traverse_callback_func ( json , p , finished ) !! Callback function used by [[json_traverse]] import :: json_value , json_core , LK implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished !! set true to stop traversing end subroutine json_traverse_callback_func end interface public :: json_array_callback_func public :: json_traverse_callback_func !************************************************************************************* contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/17/2016 ! !  Destructor for the [[json_core]] type. subroutine destroy_json_core ( me ) implicit none class ( json_core ), intent ( out ) :: me end subroutine destroy_json_core !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Function constructor for a [[json_core]]. !  This is just a wrapper for [[json_initialize]]. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. function initialize_json_core ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) result ( json_core_object ) implicit none type ( json_core ) :: json_core_object logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call json_core_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) end function initialize_json_core !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Initialize the [[json_core]] instance. ! !  The routine may be called before any of the [[json_core]] methods are used in !  order to specify certain parameters. If it is not called, then the defaults !  are used. This routine is also called internally by various routines. !  It can also be called to clear exceptions, or to reset some !  of the variables (note that only the arguments present are changed). ! !# Modified !  * Izaak Beekman : 02/24/2015 ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. subroutine json_initialize ( json , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) implicit none class ( json_core ), intent ( inout ) :: json logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. character ( kind = CDK , len = 10 ) :: w , d , e character ( kind = CDK , len = 2 ) :: sgn , rl_edit_desc integer ( IK ) :: istat logical ( LK ) :: sgn_prnt !reset exception to false: call json % clear_exceptions () !Just in case, clear these global variables also: json % pushed_index = 0 json % pushed_char = '' json % char_count = 0 json % line_count = 1 json % ipos = 1 #ifdef USE_UCS4 ! reopen stdout and stderr with utf-8 encoding open ( output_unit , encoding = 'utf-8' ) open ( error_unit , encoding = 'utf-8' ) #endif !various optional inputs: if ( present ( spaces_per_tab )) & json % spaces_per_tab = spaces_per_tab if ( present ( verbose )) & json % is_verbose = verbose if ( present ( strict_type_checking )) & json % strict_type_checking = strict_type_checking if ( present ( trailing_spaces_significant )) & json % trailing_spaces_significant = trailing_spaces_significant if ( present ( case_sensitive_keys )) & json % case_sensitive_keys = case_sensitive_keys !Set the format for real numbers: ! [if not changing it, then it remains the same] if ( (. not . allocated ( json % real_fmt )) . or . & ! if this hasn't been done yet present ( compact_reals ) . or . & present ( print_signs ) . or . & present ( real_format ) ) then !allow the special case where real format is '*': ! [this overrides the other options] if ( present ( real_format )) then if ( real_format == star ) then json % compact_real = . false . json % real_fmt = star return end if end if if ( present ( compact_reals )) json % compact_real = compact_reals !set defaults sgn_prnt = . false . if ( present ( print_signs ) ) sgn_prnt = print_signs if ( sgn_prnt ) then sgn = 'sp' else sgn = 'ss' end if rl_edit_desc = 'E' if ( present ( real_format ) ) then select case ( real_format ) case ( 'g' , 'G' , 'e' , 'E' , 'en' , 'EN' , 'es' , 'ES' ) rl_edit_desc = real_format case default call json % throw_exception ( 'Invalid real format, \"' // & trim ( real_format ) // '\", passed to json_initialize.' // & new_line ( 'a' ) // 'Acceptable formats are: \"G\", \"E\", \"EN\", and \"ES\".' ) end select end if ! set the default output/input format for reals: write ( w , '(ss,I0)' , iostat = istat ) max_numeric_str_len if ( istat == 0 ) write ( d , '(ss,I0)' , iostat = istat ) real_precision if ( istat == 0 ) write ( e , '(ss,I0)' , iostat = istat ) real_exponent_digits if ( istat == 0 ) then json % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & trim ( w ) // '.' // trim ( d ) // 'E' // trim ( e ) // ')' else json % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & '30.16E3)' !just use this one (should never happen) end if end if end subroutine json_initialize !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/30/2016 ! !  Returns true if `name` is equal to `p%name`, using the specified !  settings for case sensitivity and trailing whitespace. function name_equal ( json , p , name ) result ( is_equal ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), intent ( in ) :: p !! the json object character ( kind = CK , len =* ), intent ( in ) :: name !! the name to check for logical ( LK ) :: is_equal !! true if the string are lexically equal if ( allocated ( p % name )) then !must be the same length if we are treating !trailing spaces as significant, so do a !quick test of this first: if ( json % trailing_spaces_significant ) then is_equal = len ( p % name ) == len ( name ) if (. not . is_equal ) return end if if ( json % case_sensitive_keys ) then is_equal = p % name == name else is_equal = lowercase_string ( p % name ) == lowercase_string ( name ) end if else is_equal = name == '' ! check a blank name end if end function name_equal !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Create a deep copy of a [[json_value]] linked-list structure. ! !# Example ! !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json !     type(json_value),pointer :: j1, j2 !     call json%parse('../files/inputs/test1.json',j1) !     call json%clone(j1,j2) !now have two independent copies !     call json%destroy(j1)  !destroys j1, but j2 remains !     call json%print(j2,'j2.json') !     call json%destroy(j2) !    end program test !```` subroutine json_clone ( json , from , to ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here !! (it must not already be associated) !call the main function: ! [note: this is not part of json_core class] call json_value_clone_func ( from , to ) end subroutine json_clone !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Recursive deep copy function called by [[json_clone]]. ! !@note If new data is added to the [[json_value]] type, !      then this would need to be updated. recursive subroutine json_value_clone_func ( from , to , parent , previous , next , children , tail ) implicit none type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here !! (it must not already be associated) type ( json_value ), pointer , optional :: parent !! to%parent type ( json_value ), pointer , optional :: previous !! to%previous type ( json_value ), pointer , optional :: next !! to%next type ( json_value ), pointer , optional :: children !! to%children logical , optional :: tail !! if \"to\" is the tail of its parent's children nullify ( to ) if ( associated ( from )) then allocate ( to ) !copy over the data variables: ! [note: the allocate() statements don't work here for the !  deferred-length characters in gfortran-4.9] if ( allocated ( from % name )) to % name = from % name if ( allocated ( from % dbl_value )) allocate ( to % dbl_value , source = from % dbl_value ) if ( allocated ( from % log_value )) allocate ( to % log_value , source = from % log_value ) if ( allocated ( from % str_value )) to % str_value = from % str_value if ( allocated ( from % int_value )) allocate ( to % int_value , source = from % int_value ) to % var_type = from % var_type to % n_children = from % n_children !allocate and associate the pointers as necessary: if ( present ( parent )) to % parent => parent if ( present ( previous )) to % previous => previous if ( present ( next )) to % next => next if ( present ( children )) to % children => children if ( present ( tail )) then if ( tail ) to % parent % tail => to end if if ( associated ( from % next )) then allocate ( to % next ) call json_value_clone_func ( from % next ,& to % next ,& previous = to ,& parent = to % parent ,& tail = (. not . associated ( from % next % next ))) end if if ( associated ( from % children )) then allocate ( to % children ) call json_value_clone_func ( from % children ,& to % children ,& parent = to ,& tail = (. not . associated ( from % children % next ))) end if end if end subroutine json_value_clone_func !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Destroy the data within a [[json_value]], and reset type to `json_unknown`. subroutine destroy_json_data ( d ) implicit none type ( json_value ), intent ( inout ) :: d d % var_type = json_unknown if ( allocated ( d % log_value )) deallocate ( d % log_value ) if ( allocated ( d % int_value )) deallocate ( d % int_value ) if ( allocated ( d % dbl_value )) deallocate ( d % dbl_value ) if ( allocated ( d % str_value )) deallocate ( d % str_value ) end subroutine destroy_json_data !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/13/2014 ! !  Returns information about a [[json_value]]. subroutine json_info ( json , p , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name if ( present ( var_type )) var_type = p % var_type if ( present ( n_children )) n_children = json % count ( p ) if ( present ( name )) then if ( allocated ( p % name )) then name = p % name else name = '' end if end if end subroutine json_info !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/29/2016 ! !  Rename a [[json_value]]. subroutine json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! new variable name p % name = name end subroutine json_value_rename !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/29/2016 ! !  Alternate version of [[json_value_rename]], where `name` is kind=CDK. subroutine wrap_json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! new variable name call json % rename ( p , to_unicode ( name )) end subroutine wrap_json_value_rename !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Clear exceptions in the [[json_core]]. pure subroutine json_clear_exceptions ( json ) implicit none class ( json_core ), intent ( inout ) :: json !clear the flag and message: json % exception_thrown = . false . json % err_message = '' end subroutine json_clear_exceptions !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Throw an exception in the [[json_core]]. !  This routine sets the error flag, and prevents any subsequent routine !  from doing anything, until [[json_clear_exceptions]] is called. ! !@note If `is_verbose` is true, this will also print a !      traceback if the Intel compiler is used. subroutine json_throw_exception ( json , msg ) #ifdef __INTEL_COMPILER use ifcore , only : tracebackqq #endif implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: msg !! the error message json % exception_thrown = . true . json % err_message = trim ( msg ) if ( json % is_verbose ) then write ( output_unit , '(A)' ) '***********************' write ( output_unit , '(A)' ) 'JSON-Fortran Exception: ' // trim ( msg ) !call backtrace()     ! gfortran (use -fbacktrace -fall-intrinsics flags) #ifdef __INTEL_COMPILER call tracebackqq ( user_exit_code =- 1 ) ! print a traceback and return #endif write ( output_unit , '(A)' ) '***********************' end if end subroutine json_throw_exception !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_throw_exception]], where `msg` is kind=CDK. subroutine wrap_json_throw_exception ( json , msg ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: msg !! the error message call json % throw_exception ( to_unicode ( msg )) end subroutine wrap_json_throw_exception !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Retrieve error code from the [[json_core]]. !  This should be called after `parse` to check for errors. !  If an error is thrown, before using the class again, [[json_initialize]] !  should be called to clean up before it is used again. ! !# Example ! !````fortran !     type(json_file) :: json !     logical :: status_ok !     character(kind=CK,len=:),allocatable :: error_msg !     call json%load_file(filename='myfile.json') !     call json%check_for_errors(status_ok, error_msg) !     if (.not. status_ok) then !         write(*,*) 'Error: '//error_msg !         call json%clear_exceptions() !         call json%destroy() !     end if !```` ! !# See also !  * [[json_failed]] subroutine json_check_for_errors ( json , status_ok , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) status_ok = . not . json % exception_thrown if (. not . status_ok ) then if ( allocated ( json % err_message )) then error_msg = json % err_message else error_msg = 'Unknown error.' end if else error_msg = '' end if end subroutine json_check_for_errors !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/5/2013 ! !  Logical function to indicate if an exception has been thrown in a [[json_core]]. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    logical :: status_ok !    character(len=:),allocatable :: error_msg !    call json%parse(filename='myfile.json',p) !    if (json%failed()) then !        call json%check_for_errors(status_ok, error_msg) !        write(*,*) 'Error: '//error_msg !        call json%clear_exceptions() !        call json%destroy(p) !    end if !```` ! !  Note that [[json_file]] contains a wrapper for this routine, which is used like: !````fortran !    type(json_file) :: f !    logical :: status_ok !    character(len=:),allocatable :: error_msg !    call f%load_file(filename='myfile.json') !    if (f%failed()) then !        call f%check_for_errors(status_ok, error_msg) !        write(*,*) 'Error: '//error_msg !        call f%clear_exceptions() !        call f%destroy() !    end if !```` ! !# See also !  * [[json_check_for_errors]] pure function json_failed ( json ) result ( failed ) implicit none class ( json_core ), intent ( in ) :: json logical ( LK ) :: failed !! will be true if an exception !! has been thrown. failed = json % exception_thrown end function json_failed !***************************************************************************************** !***************************************************************************************** !> !  Allocate a [[json_value]] pointer variable. !  This should be called before adding data to it. ! !# Example ! !````fortran !    type(json_value),pointer :: var !    call json_value_create(var) !    call to_double(var,1.0_RK) !```` ! !# Notes !  1. This routine does not check for exceptions. !  2. The pointer should not already be allocated, or a memory leak will occur. subroutine json_value_create ( p ) implicit none type ( json_value ), pointer :: p nullify ( p ) allocate ( p ) end subroutine json_value_create !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/22/2014 ! !  Destroy a [[json_value]] linked-list structure. ! !@note The original FSON version of this !      routine was not properly freeing the memory. !      It was rewritten. recursive subroutine json_value_destroy ( json , p , destroy_next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! variable to destroy logical ( LK ), intent ( in ), optional :: destroy_next !! if true, then `p%next` !! is also destroyed (default is true) logical ( LK ) :: des_next type ( json_value ), pointer :: child if ( associated ( p )) then if ( present ( destroy_next )) then des_next = destroy_next else des_next = . true . end if if ( allocated ( p % name )) deallocate ( p % name ) call destroy_json_data ( p ) if ( associated ( p % children )) then do while ( p % n_children > 0 ) child => p % children if ( associated ( child )) then p % children => p % children % next p % n_children = p % n_children - 1 call json_value_destroy ( json , child ,. false .) else call json % throw_exception ( 'Error in json_value_destroy: ' // & 'Malformed JSON linked list' ) exit end if end do nullify ( p % children ) nullify ( child ) end if if ( associated ( p % next ) . and . des_next ) call json_value_destroy ( json , p % next ) if ( associated ( p % previous )) nullify ( p % previous ) if ( associated ( p % parent )) nullify ( p % parent ) if ( associated ( p % tail )) nullify ( p % tail ) deallocate ( p ) nullify ( p ) end if end subroutine json_value_destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/9/2014 ! !  Remove a [[json_value]] (and all its children) !  from a linked-list structure, preserving the rest of the structure. ! !# Examples ! !  To extract an object from one JSON structure, and add it to another: !````fortran !     type(json_core) :: json !     type(json_value),pointer :: json1,json2,p !     logical :: found !     !create and populate json1 and json2 !     call json%get(json1,'name',p,found)  ! get pointer to name element of json1 !     call json%remove(p,destroy=.false.)  ! remove it from json1 (don't destroy) !     call json%add(json2,p)               ! add it to json2 !```` ! !  To remove an object from a JSON structure (and destroy it): !````fortran !     type(json_core) :: json !     type(json_value),pointer :: json1,p !     logical :: found !     !create and populate json1 !     call json%get(json1,'name',p,found)  ! get pointer to name element of json1 !     call json%remove(p)                  ! remove and destroy it !```` ! !# History !  * Jacob Williams : 12/28/2014 : added destroy optional argument. subroutine json_value_remove ( json , p , destroy ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ), optional :: destroy !! If destroy is not present, it is also destroyed. !! If destroy is present and true, it is destroyed. !! If destroy is present and false, it is not destroyed. type ( json_value ), pointer :: parent , previous , next logical ( LK ) :: destroy_it if ( associated ( p )) then !optional input argument: if ( present ( destroy )) then destroy_it = destroy else destroy_it = . true . end if if ( associated ( p % parent )) then parent => p % parent if ( associated ( p % next )) then !there are later items in the list: next => p % next nullify ( p % next ) if ( associated ( p % previous )) then !there are earlier items in the list previous => p % previous previous % next => next next % previous => previous else !this is the first item in the list parent % children => next nullify ( next % previous ) end if else if ( associated ( p % previous )) then !there are earlier items in the list: previous => p % previous nullify ( previous % next ) parent % tail => previous else !this is the only item in the list: nullify ( parent % children ) nullify ( parent % tail ) end if end if parent % n_children = parent % n_children - 1 end if if ( destroy_it ) call json % destroy ( p ) end if end subroutine json_value_remove !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Swap two elements in a JSON structure. !  All of the children are carried along as well. ! !@note If both are not associated, then an error is thrown. ! !@note The assumption here is that both variables are part of a valid !      [[json_value]] linked list (so the normal `parent`, `previous`, !      `next`, etc. pointers are properly associated if necessary). ! !@warning This cannot be used to swap a parent/child pair, since that !         could lead to a circular linkage. An exception is thrown if !         this is tried. ! !@warning There are also other situations where using this routine may !         produce a malformed JSON structure, such as moving an array !         element outside of an array. This is not checked for. ! !@note If `p1` and `p2` have a common parent, it is always safe to swap them. subroutine json_value_swap ( json , p1 , p2 ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical :: same_parent , first_last , adjacent type ( json_value ), pointer :: a , b if ( json % exception_thrown ) return !both have to be associated: if ( associated ( p1 ) . and . associated ( p2 )) then !simple check to make sure that they both !aren't pointing to the same thing: if (. not . associated ( p1 , p2 )) then !we will not allow swapping an item with one of its descendants: if ( json % is_child_of ( p1 , p2 ) . or . json % is_child_of ( p2 , p1 )) then call json % throw_exception ( 'Error in json_value_swap: ' // & 'cannot swap an item with one of its descendants' ) else same_parent = ( associated ( p1 % parent ) . and . & associated ( p2 % parent ) . and . & associated ( p1 % parent , p2 % parent ) ) if ( same_parent ) then !if p1,p2 are the first,last or last,first !children of a common parent first_last = ( associated ( p1 % parent % children , p1 ) . and . & associated ( p2 % parent % tail , p2 )) . or . & ( associated ( p1 % parent % tail , p1 ) . and . & associated ( p2 % parent % children , p2 )) else first_last = . false . end if !first, we fix children,tail pointers: if ( same_parent . and . first_last ) then !this is all we have to do for the parent in this case: call swap_pointers ( p1 % parent % children , p2 % parent % tail ) else if ( same_parent . and . . not . first_last ) then if ( associated ( p1 % parent % children , p1 )) then p1 % parent % children => p2 ! p1 is the first child of the parent else if ( associated ( p1 % parent % children , p2 )) then p1 % parent % children => p1 ! p2 is the first child of the parent end if if ( associated ( p1 % parent % tail , p1 )) then p1 % parent % tail => p2 ! p1 is the last child of the parent else if ( associated ( p1 % parent % tail , p2 )) then p1 % parent % tail => p1 ! p2 is the last child of the parent end if else ! general case: different parents if ( associated ( p1 % parent )) then if ( associated ( p1 % parent % children , p1 )) p1 % parent % children => p2 if ( associated ( p1 % parent % tail , p1 )) p1 % parent % tail => p2 end if if ( associated ( p2 % parent )) then if ( associated ( p2 % parent % children , p2 )) p2 % parent % children => p1 if ( associated ( p2 % parent % tail , p2 )) p2 % parent % tail => p1 end if call swap_pointers ( p1 % parent , p2 % parent ) end if !now, have to fix previous,next pointers: !first, see if they are adjacent: adjacent = associated ( p1 % next , p2 ) . or . & associated ( p2 % next , p1 ) if ( associated ( p2 % next , p1 )) then !p2,p1 a => p2 b => p1 else !p1,p2 (or not adjacent) a => p1 b => p2 end if if ( associated ( a % previous )) a % previous % next => b if ( associated ( b % next )) b % next % previous => a if ( adjacent ) then !a comes before b in the original list b % previous => a % previous a % next => b % next a % previous => b b % next => a else if ( associated ( a % next )) a % next % previous => b if ( associated ( b % previous )) b % previous % next => a call swap_pointers ( a % previous , b % previous ) call swap_pointers ( a % next , b % next ) end if end if else call json % throw_exception ( 'Error in json_value_swap: ' // & 'both pointers must be associated' ) end if end if contains pure subroutine swap_pointers ( s1 , s2 ) implicit none type ( json_value ), pointer , intent ( inout ) :: s1 type ( json_value ), pointer , intent ( inout ) :: s2 type ( json_value ), pointer :: tmp !! temporary pointer if (. not . associated ( s1 , s2 )) then tmp => s1 s1 => s2 s2 => tmp end if end subroutine swap_pointers end subroutine json_value_swap !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/28/2016 ! !  Returns True if `p2` is a descendant of `p1` !  (i.e, a child, or a child of child, etc.) function json_value_is_child_of ( json , p1 , p2 ) result ( is_child_of ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical ( LK ) :: is_child_of is_child_of = . false . if ( json % exception_thrown ) return if ( associated ( p1 ) . and . associated ( p2 )) then if ( associated ( p1 % children )) then call json % traverse ( p1 % children , is_child_of_callback ) end if end if contains subroutine is_child_of_callback ( json , p , finished ) !! Traverse until `p` is `p2`. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished is_child_of = associated ( p , p2 ) finished = is_child_of ! stop searching if found end subroutine is_child_of_callback end function json_value_is_child_of !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/2/2016 ! !  Validate a [[json_value]] linked list by checking to make sure !  all the pointers are properly associated, arrays and objects !  have the correct number of children, and the correct data is !  allocated for the variable types. ! !  It recursively traverses the entire structure and checks every element. ! !@note This routine does not check or throw any exceptions. subroutine json_value_validate ( json , p , is_valid , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: is_valid !! True if the structure is valid. character ( kind = CK , len = :), allocatable :: error_msg !! if not valid, this will contain !! a description of the problem if ( associated ( p )) then is_valid = . true . call check_if_valid ( p , require_parent = associated ( p % parent )) else error_msg = 'The pointer is not associated' is_valid = . false . end if contains recursive subroutine check_if_valid ( p , require_parent ) implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( in ) :: require_parent !! the first one may be a root (so no parent), !! but all descendants must have a parent. integer :: i !! counter type ( json_value ), pointer :: element type ( json_value ), pointer :: previous if ( is_valid . and . associated ( p )) then ! data type: select case ( p % var_type ) case ( json_null , json_object , json_array ) if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for ' // & 'json_null, json_object, or json_array variable type' is_valid = . false . return end if case ( json_logical ) if (. not . allocated ( p % log_value )) then error_msg = 'log_value should be allocated for json_logical variable type' is_valid = . false . return else if ( allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_logical variable type' is_valid = . false . return end if case ( json_integer ) if (. not . allocated ( p % int_value )) then error_msg = 'int_value should be allocated for json_integer variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_integer variable type' is_valid = . false . return end if case ( json_double ) if (. not . allocated ( p % dbl_value )) then error_msg = 'dbl_value should be allocated for json_double variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_double variable type' is_valid = . false . return end if case ( json_string ) if (. not . allocated ( p % str_value )) then error_msg = 'str_value should be allocated for json_string variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value )) then error_msg = 'incorrect data allocated for json_string variable type' is_valid = . false . return end if case default error_msg = 'invalid JSON variable type' is_valid = . false . return end select if ( require_parent . and . . not . associated ( p % parent )) then error_msg = 'parent pointer is not associated' is_valid = . false . return end if if (. not . allocated ( p % name )) then if ( associated ( p % parent )) then if ( p % parent % var_type /= json_array ) then error_msg = 'JSON variable must have a name if not an ' // & 'array element or the root' is_valid = . false . return end if end if end if if ( associated ( p % children ) . neqv . associated ( p % tail )) then error_msg = 'both children and tail pointers must be associated' is_valid = . false . return end if ! now, check next one: if ( associated ( p % next )) then call check_if_valid ( p % next , require_parent = require_parent ) end if if ( associated ( p % children )) then if ( p % var_type /= json_array . and . p % var_type /= json_object ) then error_msg = 'only arrays and objects can have children' is_valid = . false . return end if ! first validate children pointers: previous => null () element => p % children do i = 1 , p % n_children if (. not . associated ( element % parent , p )) then error_msg = 'child''s parent pointer not properly associated' is_valid = . false . return end if if ( i == 1 . and . associated ( element % previous )) then error_msg = 'first child shouldn''t have a previous' is_valid = . false . return end if if ( i < p % n_children . and . . not . associated ( element % next )) then error_msg = 'not enough children' is_valid = . false . return end if if ( i == p % n_children . and . associated ( element % next )) then error_msg = 'too many children' is_valid = . false . return end if if ( i > 1 ) then if (. not . associated ( previous , element % previous )) then error_msg = 'previous pointer not properly associated' is_valid = . false . return end if end if if ( i == p % n_children . and . & . not . associated ( element % parent % tail , element )) then error_msg = 'parent''s tail pointer not properly associated' is_valid = . false . return end if if ( i < p % n_children ) then !setup next case: previous => element element => element % next end if end do !now check all the children: call check_if_valid ( p % children , require_parent = . true .) end if end if end subroutine check_if_valid end subroutine json_value_validate !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, remove the variable from !  the [[json_value]] structure, if it exists. subroutine json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p_var logical ( LK ) :: found call json % get ( p , name , p_var , found ) if ( found ) call json % remove ( p_var ) end subroutine json_value_remove_if_present !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_remove_if_present]], where `name` is kind=CDK. subroutine wrap_json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % remove_if_present ( p , to_unicode ( name )) end subroutine wrap_json_value_remove_if_present !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_logical ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_logical ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_logical: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_logical]], where `name` is kind=CDK. subroutine wrap_json_update_logical ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_double ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_double ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_double: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_double]], where `name` is kind=CDK. subroutine wrap_json_update_double ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_integer ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_integer ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_integer: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_integer]], where `name` is kind=CDK. subroutine wrap_json_update_integer ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_string ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_string ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_string: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `name` and `value` are kind=CDK. subroutine wrap_json_update_string ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `name` is kind=CDK. subroutine json_update_string_name_ascii ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine json_update_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `val` is kind=CDK. subroutine json_update_string_val_ascii ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , name , to_unicode ( val ), found ) end subroutine json_update_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> !  Adds `member` as a child of `p`. subroutine json_value_add_member ( json , p , member ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p type ( json_value ), pointer :: member !! the child member to add if (. not . json % exception_thrown ) then ! associate the parent member % parent => p ! add to linked list if ( associated ( p % children )) then p % tail % next => member member % previous => p % tail else p % children => member member % previous => null () !first in the list end if ! new member is now the last one in the list p % tail => member p % n_children = p % n_children + 1 end if end subroutine json_value_add_member !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add a real value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value type ( json_value ), pointer :: var !create the variable: call json % create_double ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_double]] where `name` is kind=CDK. subroutine wrap_json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a real vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_double_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add an integer value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val type ( json_value ), pointer :: var !create the variable: call json % create_integer ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_integer]] where `name` is kind=CDK. subroutine wrap_json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add an integer vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create a variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_integer_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a logical value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value type ( json_value ), pointer :: var !create the variable: call json % create_logical ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_logical]] where `name` is kind=CDK. subroutine wrap_json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a logical vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the vector logical ( LK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_logical_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add a character string child to the [[json_value]] variable. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_string ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value type ( json_value ), pointer :: var character ( kind = CK , len = :), allocatable :: str !add escape characters if necessary: call escape_string ( val , str ) !create the variable: call json % create_string ( var , str , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `name` and `val` are kind=CDK. subroutine wrap_json_value_add_string ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), to_unicode ( val )) end subroutine wrap_json_value_add_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `name` is kind=CDK. subroutine json_value_add_string_name_ascii ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine json_value_add_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `val` is kind=CDK. subroutine json_value_add_string_val_ascii ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json % add ( p , name , to_unicode ( val )) end subroutine json_value_add_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add an array of character strings to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val !! array of strings logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: var integer ( IK ) :: i logical ( LK ) :: trim_string , adjustl_string character ( kind = CK , len = :), allocatable :: str !if the string is to be trimmed or not: if ( present ( trim_str )) then trim_string = trim_str else trim_string = . false . end if if ( present ( adjustl_str )) then adjustl_string = adjustl_str else adjustl_string = . false . end if !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) !the string to write: str = val ( i ) if ( adjustl_string ) str = adjustl ( str ) if ( trim_string ) str = trim ( str ) !write it: call json % add ( var , '' , str ) !cleanup deallocate ( str ) end do !add it: call json % add ( p , var ) end subroutine json_value_add_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `name` and `val` are kind=CDK. subroutine wrap_json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `name` is kind=CDK. subroutine json_value_add_string_vec_name_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_vec_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `val` is kind=CDK. subroutine json_value_add_string_vec_val_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_vec_val_ascii !***************************************************************************************** !***************************************************************************************** !> !  Count the number of children. ! !# History !  * JW : 1/4/2014 : Original routine removed. !    Now using n_children variable. !    Renamed from json_value_count. function json_count ( json , p ) result ( count ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ) :: count !! number of children if ( associated ( p )) then count = p % n_children else call json % throw_exception ( 'Error in json_count: ' // & 'pointer is not associated.' ) end if end function json_count !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/16/2015 ! !  Returns a pointer to the parent of a [[json_value]]. !  If there is no parent, then a null() pointer is returned. subroutine json_get_parent ( json , p , parent ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: parent !! pointer to parent if ( associated ( p )) then parent => p % parent else nullify ( parent ) call json % throw_exception ( 'Error in json_get_parent: ' // & 'pointer is not associated.' ) end if end subroutine json_get_parent !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the next of a [[json_value]]. !  If there is no next, then a null() pointer is returned. subroutine json_get_next ( json , p , next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: next !! pointer to next if ( associated ( p )) then next => p % next else nullify ( next ) call json % throw_exception ( 'Error in json_get_next: ' // & 'pointer is not associated.' ) end if end subroutine json_get_next !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the previous of a [[json_value]]. !  If there is no previous, then a null() pointer is returned. subroutine json_get_previous ( json , p , previous ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: previous !! pointer to previous if ( associated ( p )) then previous => p % previous else nullify ( previous ) call json % throw_exception ( 'Error in json_get_previous: ' // & 'pointer is not associated.' ) end if end subroutine json_get_previous !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the tail of a [[json_value]] !  (the last child of an array of object). !  If there is no tail, then a null() pointer is returned. subroutine json_get_tail ( json , p , tail ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: tail !! pointer to tail if ( associated ( p )) then tail => p % tail else nullify ( tail ) call json % throw_exception ( 'Error in json_get_tail: ' // & 'pointer is not associated.' ) end if end subroutine json_get_tail !***************************************************************************************** !***************************************************************************************** !> !  Returns a child in the object or array given the index. subroutine json_value_get_by_index ( json , p , idx , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data integer ( IK ), intent ( in ) :: idx !! index of the child type ( json_value ), pointer :: child !! pointer to the child integer ( IK ) :: i nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p % children )) then child => p % children do i = 1 , idx - 1 if ( associated ( child % next )) then child => child % next else call json % throw_exception ( 'Error in json_value_get_by_index:' // & ' child%next is not associated.' ) nullify ( child ) return end if end do else call json % throw_exception ( 'Error in json_value_get_by_index:' // & ' p%children is not associated.' ) end if end if end subroutine json_value_get_by_index !***************************************************************************************** !***************************************************************************************** !> !  Returns pointer to the first child of the object !  (or null() if it is not associated). subroutine json_value_get_child ( json , p , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data type ( json_value ), pointer :: child !! pointer to the child if ( associated ( p )) then child => p % children else nullify ( child ) call json % throw_exception ( 'Error in json_value_get_child: ' // & 'pointer is not associated.' ) end if end subroutine json_value_get_child !***************************************************************************************** !***************************************************************************************** !> !  Returns a child in the object or array given the name string. ! !  The name search can be case-sensitive or not, and can have significant trailing !  whitespace or not, depending on the settings in the [[json_core]] class. ! !@note The `name` input is not a path, and is not parsed like it is in [[json_get_by_path]]. subroutine json_value_get_by_name_chars ( json , p , name , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! the name of a child of `p` type ( json_value ), pointer :: child !! pointer to the child integer ( IK ) :: i , n_children nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p )) then if ( p % var_type == json_object ) then n_children = json % count ( p ) child => p % children !start with first one do i = 1 , n_children if (. not . associated ( child )) then call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'Malformed JSON linked list' ) return end if if ( allocated ( child % name )) then !name string matching routine: if ( json % name_equal ( child , name )) return end if child => child % next end do end if !did not find anything: call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'child variable ' // trim ( name ) // ' was not found.' ) nullify ( child ) else call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'pointer is not associated.' ) end if end if end subroutine json_value_get_by_name_chars !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_get_by_name_chars]] where `name` is kind=CDK. subroutine wrap_json_value_get_by_name_chars ( json , p , name , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: child call json % get ( p , to_unicode ( name ), child ) end subroutine wrap_json_value_get_by_name_chars !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/12/2014 ! !  Print the [[json_value]] structure to an allocatable string. subroutine json_value_to_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len = :), intent ( out ), allocatable :: str !! prints structure to this string str = '' call json % json_value_print ( p , iunit = unit2str , str = str , indent = 1 , colon = . true .) end subroutine json_value_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 6/20/2014 ! !  Print the [[json_value]] structure to a file. subroutine json_print_1 ( json , p , iunit ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! the file unit (the file must already have been opened, can't be -1). character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then call json % json_value_print ( p , iunit , str = dummy , indent = 1 , colon = . true .) else call json % throw_exception ( 'Error in json_print_1: iunit must not be -1.' ) end if end subroutine json_print_1 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/23/2014 ! !  Print the [[json_value]] structure to a file. subroutine json_print_2 ( json , p , filename ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to print to (should not already be open) integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call json % print ( p , iunit ) close ( iunit , iostat = istat ) else call json % throw_exception ( 'Error in json_print_2: could not open file: ' // & trim ( filename )) end if end subroutine json_print_2 !***************************************************************************************** !***************************************************************************************** !> !  Print the JSON structure to a string or a file. ! !# Notes !  * This is an internal routine called by the various wrapper routines. !  * The reason the str argument is non-optional is because of a !    bug in v4.9 of the gfortran compiler. recursive subroutine json_value_print ( json , p , iunit , str , indent ,& need_comma , colon , is_array_element ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! file unit to write to (6=console) integer ( IK ), intent ( in ), optional :: indent !! indention level logical ( LK ), intent ( in ), optional :: is_array_element !! if this is an array element logical ( LK ), intent ( in ), optional :: need_comma !! if it needs a comma after it logical ( LK ), intent ( in ), optional :: colon !! if the colon was just written character ( kind = CK , len = :), intent ( inout ), allocatable :: str !! if iunit==unit2str (-1) then the structure is !! printed to this string rather than !! a file. This mode is used by !! [[json_value_to_string]]. character ( kind = CK , len = max_numeric_str_len ) :: tmp !for val to string conversions character ( kind = CK , len = :), allocatable :: s type ( json_value ), pointer :: element integer ( IK ) :: tab , i , count , spaces logical ( LK ) :: print_comma logical ( LK ) :: write_file , write_string logical ( LK ) :: is_array if (. not . json % exception_thrown ) then !whether to write a string or a file (one or the other): write_string = ( iunit == unit2str ) write_file = . not . write_string !if the comma will be printed after the value ! [comma not printed for the last elements] if ( present ( need_comma )) then print_comma = need_comma else print_comma = . false . end if !number of \"tabs\" to indent: if ( present ( indent )) then tab = indent else tab = 0 end if !convert to number of spaces: spaces = tab * json % spaces_per_tab !if this is an element in an array: if ( present ( is_array_element )) then is_array = is_array_element else is_array = . false . end if !if the colon was the last thing written if ( present ( colon )) then s = '' else s = repeat ( space , spaces ) end if select case ( p % var_type ) case ( json_object ) count = json % count ( p ) if ( count == 0 ) then !special case for empty object call write_it ( s // start_object // end_object , comma = print_comma ) else call write_it ( s // start_object ) !if an object is in an array, there is an extra tab: if ( is_array ) then tab = tab + 1 spaces = tab * json % spaces_per_tab end if nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! print the name if ( allocated ( element % name )) then call write_it ( repeat ( space , spaces ) // quotation_mark // & element % name // quotation_mark // colon_char // space ,& advance = . false .) else call json % throw_exception ( 'Error in json_value_print:' // & ' element%name not allocated' ) nullify ( element ) return end if ! recursive print of the element call json % json_value_print ( element , iunit = iunit , indent = tab + 1 , & need_comma = i < count , colon = . true ., str = str ) ! get the next child the list: element => element % next end do ! [one fewer tab if it isn't an array element] if (. not . is_array ) s = repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) call write_it ( s // end_object , comma = print_comma ) nullify ( element ) end if case ( json_array ) count = json % count ( p ) if ( count == 0 ) then !special case for empty array call write_it ( s // start_array // end_array , comma = print_comma ) else call write_it ( start_array ) nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! recursive print of the element call json % json_value_print ( element , iunit = iunit , indent = tab ,& need_comma = i < count , is_array_element = . true ., str = str ) ! get the next child the list: element => element % next end do !indent the closing array character: call write_it ( repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) // end_array ,& comma = print_comma ) nullify ( element ) end if case ( json_null ) call write_it ( s // null_str , comma = print_comma ) case ( json_string ) if ( allocated ( p % str_value )) then call write_it ( s // quotation_mark // & trim ( p % str_value ) // quotation_mark , comma = print_comma ) else call json % throw_exception ( 'Error in json_value_print:' // & ' p%value_string not allocated' ) return end if case ( json_logical ) if ( p % log_value ) then call write_it ( s // true_str , comma = print_comma ) else call write_it ( s // false_str , comma = print_comma ) end if case ( json_integer ) call integer_to_string ( p % int_value , int_fmt , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma ) case ( json_double ) if ( allocated ( json % real_fmt )) then call real_to_string ( p % dbl_value , json % real_fmt , json % compact_real , tmp ) else !use the default format (user has not called initialize() or specified one): call real_to_string ( p % dbl_value , default_real_fmt , json % compact_real , tmp ) end if call write_it ( s // trim ( tmp ), comma = print_comma ) case default call json % throw_exception ( 'Error in json_value_print: unknown data type' ) end select !cleanup: if ( allocated ( s )) deallocate ( s ) end if contains subroutine write_it ( s , advance , comma ) !! write the string to the file (or the output string) implicit none character ( kind = CK , len =* ), intent ( in ) :: s !! string to print logical ( LK ), intent ( in ), optional :: advance !! to add line break or not logical ( LK ), intent ( in ), optional :: comma !! print comma after the string logical ( LK ) :: add_line_break , add_comma character ( kind = CK , len = :), allocatable :: s2 if ( present ( comma )) then add_comma = comma else add_comma = . false . !default is not to add comma end if if ( present ( advance )) then add_line_break = advance else add_line_break = . true . !default is to advance end if !string to print: s2 = s if ( add_comma ) s2 = s2 // delimiter if ( write_file ) then if ( add_line_break ) then write ( iunit , fmt = '(A)' ) s2 else write ( iunit , fmt = '(A)' , advance = 'NO' ) s2 end if else !write string str = str // s2 if ( add_line_break ) str = str // newline end if !cleanup: if ( allocated ( s2 )) deallocate ( s2 ) end subroutine write_it end subroutine json_value_print !***************************************************************************************** !***************************************************************************************** !> !  Returns the [[json_value]] pointer given the path string. ! !# Example ! !````fortran !    type(json_value),pointer :: dat,p !    logical :: found !    !... !    call json%get(dat,'data(2).version',p,found) !```` ! !# Notes !  The following special characters are used to denote paths: ! !```` !  $         - root !  @         - this !  .         - child object member !  [] or ()  - child array element !```` ! !  Thus, if any of these characters are present in the name key, !  this routine cannot be used to get the value. !  In that case, the `get_child` methods would need to be used. subroutine json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ) :: i integer ( IK ) :: length integer ( IK ) :: child_i character ( kind = CK , len = 1 ) :: c logical ( LK ) :: array type ( json_value ), pointer :: tmp nullify ( p ) if (. not . json % exception_thrown ) then ! default to assuming relative to this p => me child_i = 1 array = . false . !keep trailing space or not: if ( json % trailing_spaces_significant ) then length = len ( path ) else length = len_trim ( path ) end if do i = 1 , length c = path ( i : i ) select case ( c ) case ( root ) ! root do while ( associated ( p % parent )) p => p % parent end do child_i = i + 1 case ( this ) ! this p => me child_i = i + 1 case ( child ) ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path:' // & ' Error getting child member.' ) exit end if child_i = i + 1 case ( start_array , start_array_alt ) !....Modified to allow for 'var[3]' style syntax !Note: jmozmoz/fson has a slightly different version of this... ! start looking for the array element index array = . true . ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path:' // & ' Error getting array element' ) exit end if child_i = i + 1 case ( end_array , end_array_alt ) if (. not . array ) then call json % throw_exception ( 'Error in json_get_by_path: Unexpected ]' ) exit end if array = . false . child_i = json % string_to_integer ( path ( child_i : i - 1 )) nullify ( tmp ) call json % get_child ( p , child_i , tmp ) p => tmp nullify ( tmp ) child_i = i + 1 end select end do if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else ! grab the last child if present in the path if ( child_i <= length ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) end if if ( associated ( p )) then if ( present ( found )) found = . true . !everything seems to be ok else call json % throw_exception ( 'Error in json_get_by_path:' // & ' variable not found: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if end if else if ( present ( found )) found = . false . end if end subroutine json_get_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_get_by_path !***************************************************************************************** !***************************************************************************************** !> !  Convert a string into an integer. ! !# History !  * Jacob Williams : 12/10/2013 : Rewrote routine.  Added error checking. !  * Modified by Izaak Beekman ! !@note Replacement for the parse_integer function in the original code. function string_to_integer ( json , str ) result ( ival ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ival character ( kind = CDK , len = :), allocatable :: digits integer ( IK ) :: ndigits_digits , ndigits , ierr if (. not . json % exception_thrown ) then ! Compute how many digits we need to read ndigits = 2 * len_trim ( str ) ndigits_digits = floor ( log10 ( real ( ndigits ))) + 1 allocate ( character ( kind = CDK , len = ndigits_digits ) :: digits ) write ( digits , '(I0)' ) ndigits !gfortran will have a runtime error with * edit descriptor here ! gfortran bug: '*' edit descriptor for ISO_10646 strings does bad stuff. read ( str , '(I' // trim ( digits ) // ')' , iostat = ierr ) ival !string to integer if ( ierr /= 0 ) then !if there was an error ival = 0 call json % throw_exception ( 'Error in string_to_integer: ' // & 'string cannot be converted to an integer: ' // & trim ( str )) end if else ival = 0 end if end function string_to_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Convert a string into a double. ! !# History !  * Jacob Williams, 10/27/2015 : Now using fmt=*, rather than !    fmt=real_fmt, since it doesn't work for some unusual cases !    (e.g., when str='1E-5'). function string_to_double ( json , str ) result ( rval ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str real ( RK ) :: rval integer ( IK ) :: ierr !! read iostat error code if (. not . json % exception_thrown ) then !string to double read ( str , fmt =* , iostat = ierr ) rval if ( ierr /= 0 ) then !if there was an error rval = 0.0_RK call json % throw_exception ( 'Error in string_to_double: ' // & 'string cannot be converted to a double: ' // & trim ( str )) end if else rval = 0.0_RK end if end function string_to_double !***************************************************************************************** !***************************************************************************************** !> !  Get an integer value from a [[json_value]]. subroutine json_get_integer ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( out ) :: value value = 0 if ( json % exception_thrown ) return if ( me % var_type == json_integer ) then value = me % int_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_double ) value = int ( me % dbl_value ) case ( json_logical ) if ( me % log_value ) then value = 1 else value = 0 end if case default call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) end select end if end if end subroutine json_get_integer !***************************************************************************************** !***************************************************************************************** !> !  Get an integer value from a [[json_value]], given the path string. subroutine json_get_integer_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0 if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_integer:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_integer_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_integer_with_path]], where \"path\" is kind=CDK. subroutine wrap_json_get_integer_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_integer_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get an integer vector from a [[json_value]]. subroutine json_get_integer_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_int_from_array ) contains subroutine get_int_from_array ( json , element , i , count ) !! callback function for integer implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Get an integer vector from a [[json_value]], given the path string. subroutine json_get_integer_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . call json % get ( me , path = path , array_callback = get_int_from_array , found = found ) ! need to duplicate callback function, no other way contains subroutine get_int_from_array ( json , element , i , count ) !! callback function for integer implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_integer_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_integer_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , path = to_unicode ( path ), vec = vec , found = found ) end subroutine wrap_json_get_integer_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a double value from a [[json_value]]. subroutine json_get_double ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), intent ( out ) :: value value = 0.0_RK if ( json % exception_thrown ) return if ( me % var_type == json_double ) then value = me % dbl_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_logical ) if ( me % log_value ) then value = 1.0_RK else value = 0.0_RK end if case default call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) end select end if end if end subroutine json_get_double !***************************************************************************************** !***************************************************************************************** !> !  Get a double value from a [[json_value]], given the path. subroutine json_get_double_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0.0_RK if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_double_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_double_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_double_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_double_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a double vector from a [[json_value]]. subroutine json_get_double_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_double_from_array ) contains subroutine get_double_from_array ( json , element , i , count ) !! callback function for double implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a double vector from a [[json_value]], given the path. subroutine json_get_double_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_double_from_array , found = found ) contains subroutine get_double_from_array ( json , element , i , count ) !! callback function for double implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_double_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_double_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_double_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a logical value from a [[json_value]]. subroutine json_get_logical ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ) :: value value = . false . if ( json % exception_thrown ) return if ( me % var_type == json_logical ) then value = me % log_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = ( me % int_value > 0 ) case default call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) end select end if end if end subroutine json_get_logical !***************************************************************************************** !***************************************************************************************** !> !  Get a logical value from a [[json_value]], given the path. subroutine json_get_logical_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = . false . if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_logical_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_logical_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_logical_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_logical_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a logical vector from [[json_value]]. subroutine json_get_logical_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_logical_from_array ) contains subroutine get_logical_from_array ( json , element , i , count ) !! callback function for logical implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a logical vector from a [[json_value]], given the path. subroutine json_get_logical_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_logical_from_array , found = found ) contains subroutine get_logical_from_array ( json , element , i , count ) !! callback function for logical implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_logical_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_logical_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_logical_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a character string from a [[json_value]]. subroutine json_get_string ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: value character ( kind = CK , len = :), allocatable :: error_message !! for [[unescape_string]] value = '' if (. not . json % exception_thrown ) then select case ( me % var_type ) case ( json_string ) if ( allocated ( me % str_value )) then call unescape_string ( me % str_value , value , error_message ) if ( allocated ( error_message )) then call json % throw_exception ( error_message ) deallocate ( error_message ) value = '' end if else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%str_value not allocated' ) end if case default call json % throw_exception ( 'Error in json_get_string: ' // & 'Unable to resolve value to characters: ' // & me % name ) ! Note: for the other cases, we could do val to string conversions. end select end if end subroutine json_get_string !***************************************************************************************** !***************************************************************************************** !> !  Get a character string from a [[json_value]], given the path. subroutine json_get_string_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = '' if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_string_with_path:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( allocated ( value ) . and . . not . json % exception_thrown ) then if ( present ( found )) found = . true . else if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if !cleanup: if ( associated ( p )) nullify ( p ) end subroutine json_get_string_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_string_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_string_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_string_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a string vector from a [[json_value(type)]]. subroutine json_get_string_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_chars_from_array ) contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a string vector from a [[json_value(type)]], given the path. subroutine json_get_string_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_chars_from_array , found = found ) contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_string_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_string_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_string_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  This routine calls the user-supplied [[json_array_callback_func]] subroutine !      for each element in the array. ! !@note For integer, double, logical, and character arrays, !      higher-level routines are provided (see `get` methods), so !      this routine does not have to be used for those cases. subroutine json_get_array ( json , me , array_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me procedure ( json_array_callback_func ) :: array_callback type ( json_value ), pointer :: element !! temp variable for getting elements integer ( IK ) :: i !! counter integer ( IK ) :: count !! number of elements in the array if ( json % exception_thrown ) return nullify ( element ) select case ( me % var_type ) case ( json_array ) count = json % count ( me ) element => me % children do i = 1 , count ! callback for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_get_array: ' // & 'Malformed JSON linked list' ) return end if call array_callback ( json , element , i , count ) if ( json % exception_thrown ) exit element => element % next end do case default call json % throw_exception ( 'Error in json_get_array:' // & ' Resolved value is not an array ' ) end select !cleanup: if ( associated ( element )) nullify ( element ) end subroutine json_get_array !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/28/2016 ! !  Traverse a JSON structure. !  This routine calls the user-specified [[json_traverse_callback_func]] !  for each element of the structure. subroutine json_traverse ( json , p , traverse_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p procedure ( json_traverse_callback_func ) :: traverse_callback logical ( LK ) :: finished !! can be used to stop the process if (. not . json % exception_thrown ) call traverse ( p ) contains recursive subroutine traverse ( p ) !! recursive [[json_value]] traversal. implicit none type ( json_value ), pointer , intent ( in ) :: p type ( json_value ), pointer :: element !! a child element integer ( IK ) :: i !! counter integer ( IK ) :: icount !! number of children if ( json % exception_thrown ) return call traverse_callback ( json , p , finished ) ! first call for this object if ( finished ) return !for arrays and objects, have to also call for all children: if ( p % var_type == json_array . or . p % var_type == json_object ) then icount = json % count ( p ) ! number of children if ( icount > 0 ) then element => p % children ! first one do i = 1 , icount ! call for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_traverse: ' // & 'Malformed JSON linked list' ) return end if call traverse ( element ) if ( finished . or . json % exception_thrown ) exit element => element % next end do end if nullify ( element ) end if end subroutine traverse end subroutine json_traverse !***************************************************************************************** !***************************************************************************************** !> !  This routine calls the user-supplied array_callback subroutine !  for each element in the array (specified by the path). subroutine json_get_array_with_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path procedure ( json_array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) ! resolve the path to the value call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_array:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( me = p , array_callback = array_callback ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_array_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_array_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_array_with_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path procedure ( json_array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), array_callback , found ) end subroutine wrap_json_get_array_with_path !***************************************************************************************** !***************************************************************************************** !> !  Parse the JSON file and populate the [[json_value]] tree. ! !# Inputs ! !  The inputs can be: ! !  * `file` & `unit` : the specified unit is used to read JSON from file. !                      [note if unit is already open, then the filename is ignored] !  * `file`          : JSON is read from file using internal unit number ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%parse(file='myfile.json', p=p) !```` ! !# History !  * Jacob Williams : 01/13/2015 : added read from string option. !  * Izaak Beekman  : 03/08/2015 : moved read from string to separate !    subroutine, and error annotation to separate subroutine. ! !@note When calling this routine, any exceptions thrown from previous !      calls will automatically be cleared. subroutine json_parse_file ( json , file , p , unit ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: file !! JSON file name type ( json_value ), pointer :: p !! output structure integer ( IK ), intent ( in ), optional :: unit !! file unit number (/= 0) integer ( IK ) :: iunit !! file unit actually used integer ( IK ) :: istat !! iostat flag logical ( LK ) :: is_open !! if the file is already open !clear any exceptions and initialize: call json % initialize () if ( present ( unit ) ) then if ( unit == 0 ) then call json % throw_exception ( 'Error in json_parse_file: unit number must not be 0.' ) return end if iunit = unit !check to see if the file is already open ! if it is, then use it, otherwise open the file with the name given. inquire ( unit = iunit , opened = is_open , iostat = istat ) if ( istat == 0 . and . . not . is_open ) then ! open the file open ( unit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) else !if the file is already open, then we need to make sure ! that it is open with the correct form/access/etc... end if else ! open the file with a new unit number: open ( newunit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) end if if ( istat == 0 ) then ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = trim ( file ) !use the file name ! parse as a value call json % parse_value ( unit = iunit , str = CK_ '' , value = p ) if ( json % exception_thrown ) call json % annotate_invalid_json ( iunit , CK_ '' ) ! close the file if necessary close ( unit = iunit , iostat = istat ) else call json % throw_exception ( 'Error in json_parse_file: Error opening file: ' // trim ( file )) nullify ( p ) end if end subroutine json_parse_file !***************************************************************************************** !***************************************************************************************** !> !  Parse the JSON string and populate the [[json_value]] tree. ! !# See also !  * [[json_parse_file]] subroutine json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data integer ( IK ), parameter :: iunit = 0 !! indicates that json data will be read from buffer !clear any exceptions and initialize: call json % initialize () ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = '' ! parse as a value call json % parse_value ( unit = iunit , str = str , value = p ) if ( json % exception_thrown ) call json % annotate_invalid_json ( iunit , str ) end subroutine json_parse_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_parse_string]], where `str` is kind=CDK. subroutine wrap_json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CDK , len =* ), intent ( in ) :: str !! string with JSON data call json % parse ( p , to_unicode ( str )) end subroutine wrap_json_parse_string !***************************************************************************************** !***************************************************************************************** !> !  Generate a warning message if there was an error parsing a JSON !  file or string. subroutine annotate_invalid_json ( json , iunit , str ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data character ( kind = CK , len = :), allocatable :: line , arrow_str character ( kind = CK , len = 10 ) :: line_str , char_str integer ( IK ) :: i , i_nl_prev , i_nl !  If there was an error reading the file, then !   print the line where the error occurred: if ( json % exception_thrown ) then !the counters for the current line and the last character read: call integer_to_string ( json % line_count , int_fmt , line_str ) call integer_to_string ( json % char_count , int_fmt , char_str ) !draw the arrow string that points to the current character: arrow_str = repeat ( '-' , max ( 0 , json % char_count - 1 ) ) // '&#94;' if ( json % line_count > 0 . and . json % char_count > 0 ) then if ( iunit /= 0 ) then if ( use_unformatted_stream ) then call json % get_current_line_from_file_stream ( iunit , line ) else call json % get_current_line_from_file_sequential ( iunit , line ) end if else !get the current line from the string: ! [this is done by counting the newline characters] i_nl_prev = 0 !index of previous newline character i_nl = 2 !just in case line_count = 0 do i = 1 , json % line_count i_nl = index ( str ( i_nl_prev + 1 :), newline ) if ( i_nl == 0 ) then !last line - no newline character i_nl = len ( str ) + 1 exit end if i_nl = i_nl + i_nl_prev !index of current newline character i_nl_prev = i_nl !update for next iteration end do line = str ( i_nl_prev + 1 : i_nl - 1 ) !extract current line end if else !in this case, it was an empty line or file line = '' end if !create the error message: json % err_message = json % err_message // newline // & 'line: ' // trim ( adjustl ( line_str )) // ', ' // & 'character: ' // trim ( adjustl ( char_str )) // newline // & trim ( line ) // newline // arrow_str if ( allocated ( line )) deallocate ( line ) end if end subroutine annotate_invalid_json !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rewind the file to the beginning of the current line, and return this line. !  The file is assumed to be opened. !  This is the SEQUENTIAL version (see also [[get_current_line_from_file_stream]]). subroutine get_current_line_from_file_sequential ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line character ( kind = CK , len = seq_chunk_size ) :: chunk !! for reading line in chunks integer ( IK ) :: istat !! iostat flag integer ( IK ) :: isize !! number of characters read in read statement !initialize: line = '' !rewind to beginning of the current record: backspace ( iunit , iostat = istat ) !loop to read in all the characters in the current record. ![the line is read in chunks until the end of the line is reached] if ( istat == 0 ) then do isize = 0 read ( iunit , fmt = '(A)' , advance = 'NO' , size = isize , iostat = istat ) chunk if ( istat == 0 ) then line = line // chunk else if ( isize > 0 . and . isize <= seq_chunk_size ) line = line // chunk ( 1 : isize ) exit end if end do end if end subroutine get_current_line_from_file_sequential !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rewind the file to the beginning of the current line, and return this line. !  The file is assumed to be opened. !  This is the STREAM version (see also [[get_current_line_from_file_sequential]]). subroutine get_current_line_from_file_stream ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ) :: istart , iend , ios character ( kind = CK , len = 1 ) :: c istart = json % ipos do if ( istart <= 1 ) then istart = 1 exit end if read ( iunit , pos = istart , iostat = ios ) c if ( c == newline . or . ios /= 0 ) then if ( istart /= 1 ) istart = istart - 1 exit end if istart = istart - 1 !rewind until the beginning of the line end do iend = json % ipos do read ( iunit , pos = iend , iostat = ios ) c if ( c == newline . or . ios /= 0 ) exit iend = iend + 1 end do allocate ( character ( kind = CK , len = iend - istart + 1 ) :: line ) read ( iunit , pos = istart , iostat = ios ) line end subroutine get_current_line_from_file_stream !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_value ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string containing JSON data (only used if unit=0) type ( json_value ), pointer :: value !! JSON data that is extracted logical ( LK ) :: eof !! end-of-file flag character ( kind = CK , len = 1 ) :: c !! character read from file (or string) #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( value )) then call json % throw_exception ( 'Error in parse_value: value pointer not associated.' ) end if ! pop the next non whitespace character off the file c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then return else select case ( c ) case ( start_object ) ! start object call to_object ( value ) !allocate class call json % parse_object ( unit , str , value ) case ( start_array ) ! start array call to_array ( value ) !allocate class call json % parse_array ( unit , str , value ) case ( end_array ) ! end an empty array call json % push_char ( c ) nullify ( value ) case ( quotation_mark ) ! string call to_string ( value ) !allocate class select case ( value % var_type ) case ( json_string ) #if defined __GFORTRAN__ call json % parse_string ( unit , str , tmp ) ! write to a tmp variable because of value % str_value = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) ! #else call json % parse_string ( unit , str , value % str_value ) #endif end select case ( CK_ 't' ) !true_str(1:1) gfortran bug work around !true call json % parse_for_chars ( unit , str , true_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call to_logical ( value ,. true .) case ( CK_ 'f' ) !false_str(1:1) gfortran bug work around !false call json % parse_for_chars ( unit , str , false_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call to_logical ( value ,. false .) case ( CK_ 'n' ) !null_str(1:1) gfortran bug work around !null call json % parse_for_chars ( unit , str , null_str ( 2 :)) if (. not . json % exception_thrown ) call to_null ( value ) !allocate class case ( CK_ '-' , CK_ '0' : CK_ '9' ) call json % push_char ( c ) call json % parse_number ( unit , str , value ) case default call json % throw_exception ( 'Error in parse_value:' // & ' Unexpected character while parsing value. \"' // & c // '\"' ) end select end if end if end subroutine parse_value !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it a logical(LK) variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_logical(p,'value',.true.) !```` subroutine json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name logical ( LK ), intent ( in ) :: val !! variable value call json_value_create ( p ) call to_logical ( p , val , name ) end subroutine json_value_create_logical !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrapper for [[json_value_create_logical]] so `create_logical` method can !  be called with name of character kind 'DEFAULT' or 'ISO_10646' subroutine wrap_json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val call json % create_logical ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an integer(IK) variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_integer(p,'value',1) !```` subroutine json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json_value_create ( p ) call to_integer ( p , val , name ) end subroutine json_value_create_integer !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper procedure for [[json_value_create_integer]] so that `create_integer` !  method may be called with either a 'DEFAULT' or 'ISO_10646' character kind !  `name` actual argument. subroutine wrap_json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json % create_integer ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it a real(RK) variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_double(p,'value',1.0_RK) !```` subroutine json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json_value_create ( p ) call to_double ( p , val , name ) end subroutine json_value_create_double !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper for [[json_value_create_double]] so that `create_double` method !  may be called with an actual argument corresponding to the dummy argument, !  `name` that may be of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json % create_double ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_string(p,'value','hello') !```` subroutine json_value_create_string ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val call json_value_create ( p ) call to_string ( p , val , name ) end subroutine json_value_create_string !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_string]] so that `create_string` method may be called !  with actual character string arguments for `name` and `val` that are BOTH of !  'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_string ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val call json % create_string ( p , to_unicode ( val ), to_unicode ( name )) end subroutine wrap_json_value_create_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_null(p,'value') !```` subroutine json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_null ( p , name ) end subroutine json_value_create_null !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_null]] so that `create_null` method may be called with !  an actual argument corresponding to the dummy argument `name` that is either !  of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_null ( p , to_unicode ( name )) end subroutine wrap_json_value_create_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_object(p,'objectname') !```` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. subroutine json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_object ( p , name ) end subroutine json_value_create_object !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_object]] so that `create_object` method may be called !  with an actual argument corresponding to the dummy argument `name` that is of !  either 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_object ( p , to_unicode ( name )) end subroutine wrap_json_value_create_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_array(p,'arrayname') !```` subroutine json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_array ( p , name ) end subroutine json_value_create_array !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper for [[json_value_create_array]] so that `create_array` method may be !  called with an actual argument, corresponding to the dummy argument `name`, !  that is either of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_array ( p , to_unicode ( name )) end subroutine wrap_json_value_create_array !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a logical. subroutine to_logical ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p logical ( LK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then .false. is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_logical allocate ( p % log_value ) if ( present ( val )) then p % log_value = val else p % log_value = . false . !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an integer. subroutine to_integer ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p integer ( IK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0 is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_integer allocate ( p % int_value ) if ( present ( val )) then p % int_value = val else p % int_value = 0 !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a double. subroutine to_double ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p real ( RK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0.0_rk is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_double allocate ( p % dbl_value ) if ( present ( val )) then p % dbl_value = val else p % dbl_value = 0.0_RK !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a string. ! !# Modified !  * Izaak Beekman : 02/24/2015 ! subroutine to_string ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then '' is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_string if ( present ( val )) then p % str_value = val else p % str_value = '' !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a null. subroutine to_null ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_null !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an object. subroutine to_object ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_object !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an array. subroutine to_array ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_array !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_array !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_object ( json , unit , str , parent ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: parent !! the parsed object will be added as a child of this type ( json_value ), pointer :: pair logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( parent )) then call json % throw_exception ( 'Error in parse_object: parent pointer not associated.' ) end if nullify ( pair ) !probably not necessary ! pair name c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing start of object.' ) return else if ( end_object == c ) then ! end of an empty object return else if ( quotation_mark == c ) then call json_value_create ( pair ) #if defined __GFORTRAN__ call json % parse_string ( unit , str , tmp ) ! write to a tmp variable because of pair % name = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) #else call json % parse_string ( unit , str , pair % name ) #endif if ( json % exception_thrown ) then call json % destroy ( pair ) return end if else call json % throw_exception ( 'Error in parse_object: Expecting string: \"' // c // '\"' ) return end if ! pair value c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing object member.' ) return else if ( colon_char == c ) then ! parse the value call json % parse_value ( unit , str , pair ) if ( json % exception_thrown ) then call json % destroy ( pair ) return else call json % add ( parent , pair ) end if else call json % throw_exception ( 'Error in parse_object:' // & ' Expecting : and then a value: ' // c ) return end if ! another possible pair c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object: ' // & 'End of file encountered when parsing an object' ) return else if ( delimiter == c ) then ! read the next member call json % parse_object ( unit = unit , str = str , parent = parent ) else if ( end_object == c ) then ! end of object return else call json % throw_exception ( 'Error in parse_object: Expecting end of object: ' // c ) return end if end if end subroutine parse_object !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_array ( json , unit , str , array ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: array type ( json_value ), pointer :: element logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c do if ( json % exception_thrown ) exit ! try to parse an element value nullify ( element ) call json_value_create ( element ) call json % parse_value ( unit , str , element ) if ( json % exception_thrown ) then if ( associated ( element )) call json % destroy ( element ) exit end if ! parse value will disassociate an empty array value if ( associated ( element )) call json % add ( array , element ) ! popped the next character c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then ! The file ended before array was finished: call json % throw_exception ( 'Error in parse_array: ' // & 'End of file encountered when parsing an array.' ) exit else if ( delimiter == c ) then ! parse the next element cycle else if ( end_array == c ) then ! end of array exit else call json % throw_exception ( 'Error in parse_array: ' // & 'Unexpected character encountered when parsing array.' ) exit end if end do end subroutine parse_array !***************************************************************************************** !***************************************************************************************** !> !  Parses a string while reading a JSON file. ! !# History !  * Jacob Williams : 6/16/2014 : Added hex validation. !  * Jacob Williams : 12/3/2015 : Fixed some bugs. subroutine parse_string ( json , unit , str , string ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len = :), allocatable , intent ( out ) :: string logical ( LK ) :: eof , is_hex , escape character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = 4 ) :: hex integer ( IK ) :: i integer ( IK ) :: ip !! index to put next character, !! to speed up by reducing the number of character string reallocations. !at least return a blank string if there is a problem: string = repeat ( space , chunk_size ) if (. not . json % exception_thrown ) then !initialize: ip = 1 is_hex = . false . escape = . false . i = 0 do !get the next character from the file: c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . false .) if ( eof ) then call json % throw_exception ( 'Error in parse_string: Expecting end of string' ) return else if ( c == quotation_mark . and . . not . escape ) then !end of string if ( is_hex ) call json % throw_exception ( 'Error in parse_string:' // & ' incomplete hex string: \\u' // trim ( hex )) exit else !if the string is not big enough, then add another chunk: if ( ip > len ( string )) string = string // repeat ( space , chunk_size ) !append to string: string ( ip : ip ) = c ip = ip + 1 !hex validation: if ( is_hex ) then !accumulate the four characters after '\\u' i = i + 1 hex ( i : i ) = c if ( i == 4 ) then if ( valid_json_hex ( hex )) then i = 0 hex = '' is_hex = . false . else call json % throw_exception ( 'Error in parse_string:' // & ' invalid hex string: \\u' // trim ( hex )) exit end if end if else !when the '\\u' string is encountered, then !  start accumulating the hex string (should be the next 4 characters) if ( escape ) then escape = . false . is_hex = ( c == 'u' ) !the next four characters are the hex string else escape = ( c == backslash ) end if end if end if end do !trim the string if necessary: if ( ip < len ( string ) + 1 ) then if ( ip == 1 ) then string = '' else string = string ( 1 : ip - 1 ) end if end if end if end subroutine parse_string !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. subroutine parse_for_chars ( json , unit , str , chars ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len =* ), intent ( in ) :: chars !! the string to check for. integer ( IK ) :: i , length logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c if (. not . json % exception_thrown ) then length = len_trim ( chars ) do i = 1 , length c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected end of file while parsing array.' ) return else if ( c /= chars ( i : i )) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected character.: \"' // c // '\" ' // chars ( i : i )) return end if end do end if end subroutine parse_for_chars !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Read a numerical value from the file (or string). !  The routine will determine if it is an integer or a double, and !  allocate the type accordingly. ! !@note Complete rewrite of the original FSON routine, which had some problems. subroutine parse_number ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: value character ( kind = CK , len = :), allocatable :: tmp character ( kind = CK , len = 1 ) :: c logical ( LK ) :: eof real ( RK ) :: rval integer ( IK ) :: ival logical ( LK ) :: first logical ( LK ) :: is_integer integer ( IK ) :: ip !! index to put next character !! [to speed up by reducing the number !! of character string reallocations] if (. not . json % exception_thrown ) then tmp = repeat ( space , chunk_size ) ip = 1 first = . true . is_integer = . true . !assume it may be an integer, unless otherwise determined !read one character at a time and accumulate the string: do !get the next character: c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_number:' // & ' Unexpected end of file while parsing number.' ) return else select case ( c ) case ( CK_ '-' , CK_ '+' ) !note: allowing a '+' as the first character here. if ( is_integer . and . (. not . first )) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '.' , CK_ 'E' , CK_ 'e' ) !can be present in real numbers if ( is_integer ) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '0' : CK_ '9' ) !valid characters for numbers !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case default !push back the last character read: call json % push_char ( c ) !string to value: if ( is_integer ) then ival = json % string_to_integer ( tmp ) call to_integer ( value , ival ) else rval = json % string_to_double ( tmp ) call to_double ( value , rval ) end if exit !finished end select end if if ( first ) first = . false . end do !cleanup: if ( allocated ( tmp )) deallocate ( tmp ) end if end subroutine parse_number !***************************************************************************************** !***************************************************************************************** !> !  Get the next character from the file (or string). ! !# See also !  * [[push_char]] ! !@note This routine ignores non-printing ASCII characters (iachar<=31) that are in strings. recursive function pop_char ( json , unit , str , eof , skip_ws ) result ( popped ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len = 1 ) :: popped !! the popped character. integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) -- only used if unit=0 logical ( LK ), intent ( out ) :: eof !! true if the end of the file has been reached. logical ( LK ), intent ( in ), optional :: skip_ws !! to ignore whitespace. integer ( IK ) :: ios , str_len character ( kind = CK , len = 1 ) :: c logical ( LK ) :: ignore if (. not . json % exception_thrown ) then eof = . false . if (. not . present ( skip_ws )) then ignore = . false . else ignore = skip_ws end if do if ( json % pushed_index > 0 ) then ! there is a character pushed back on, most likely ! from the number parsing. Note: this can only occur if ! reading from a file when use_unformatted_stream=.false. c = json % pushed_char ( json % pushed_index : json % pushed_index ) json % pushed_index = json % pushed_index - 1 else if ( unit /= 0 ) then !read from the file !read the next character: if ( use_unformatted_stream ) then read ( unit = unit , pos = json % ipos , iostat = ios ) c else read ( unit = unit , fmt = '(A1)' , advance = 'NO' , iostat = ios ) c end if json % ipos = json % ipos + 1 !....note: maybe try read the file in chunks... !.... or use asynchronous read with double buffering !     (see Modern Fortran: Style and Usage) else !read from the string str_len = len ( str ) !length of the string if ( json % ipos <= str_len ) then c = str ( json % ipos : json % ipos ) ios = 0 else ios = IOSTAT_END !end of the string end if json % ipos = json % ipos + 1 end if json % char_count = json % char_count + 1 !character count in the current line if ( IS_IOSTAT_END ( ios )) then !end of file json % char_count = 0 eof = . true . exit else if ( IS_IOSTAT_EOR ( ios ) . or . c == newline ) then !end of record json % char_count = 0 json % line_count = json % line_count + 1 cycle end if end if if ( any ( c == control_chars )) then ! non printing ascii characters cycle else if ( ignore . and . c == space ) then cycle else popped = c exit end if end do end if end function pop_char !***************************************************************************************** !***************************************************************************************** !> !  Core routine. ! !# See also !  * [[pop_char]] ! !# History !  * Jacob Williams : 5/3/2015 : replaced original version of this routine. subroutine push_char ( json , c ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len = 1 ), intent ( in ) :: c character ( kind = CK , len = max_numeric_str_len ) :: istr if (. not . json % exception_thrown ) then if ( use_unformatted_stream ) then !in this case, c is ignored, and we just !decrement the stream position counter: json % ipos = json % ipos - 1 else json % pushed_index = json % pushed_index + 1 if ( json % pushed_index > 0 . and . json % pushed_index <= len ( json % pushed_char )) then json % pushed_char ( json % pushed_index : json % pushed_index ) = c else call integer_to_string ( json % pushed_index , int_fmt , istr ) call json % throw_exception ( 'Error in push_char: ' // & 'invalid valid of pushed_index: ' // trim ( istr )) end if end if end if end subroutine push_char !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Print any error message, and then clear the exceptions. ! !@note This routine is used by the unit tests. !      It was originally in json_example.f90, and was !      moved here 2/26/2015 by Izaak Beekman. subroutine json_print_error_message ( json , io_unit ) implicit none class ( json_core ), intent ( inout ) :: json integer , intent ( in ), optional :: io_unit character ( kind = CK , len = :), allocatable :: error_msg !! error message logical :: status_ok !! false if there were any errors thrown !get error message: call json % check_for_errors ( status_ok , error_msg ) !print it if there is one: if (. not . status_ok ) then if ( present ( io_unit )) then write ( io_unit , '(A)' ) error_msg else write ( output_unit , '(A)' ) error_msg end if deallocate ( error_msg ) call json % clear_exceptions () end if end subroutine json_print_error_message !***************************************************************************************** !***************************************************************************************** end module json_value_module !*****************************************************************************************","tags":"","loc":"sourcefile/json_value_module.f90.html","title":"json_value_module.F90 â€“ JSON-Fortran"},{"text":"type, public :: json_file type~~json_file~~InheritsGraph type~json_file json_file type~json_value json_value type~json_value->type~json_file p type~json_value->type~json_value previous, next, parent, children, tail type~json_core json_core type~json_core->type~json_file core Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. The json_file is the main public class that is\n  used to open a file and get data from it. A json_file contains only two items: an instance of a json_core ,\n  which use used for all data manipulation, and a json_value ,\n  which is used to construct the linked-list data structure.\n  Note that most methods in the json_file class are simply wrappers\n  to the lower-level routines in the json_value_module . Example program test use json_module implicit none type ( json_file ) :: json integer :: ival real ( real64 ) :: rval character ( len = :), allocatable :: cval logical :: found call json % initialize ( compact_reals = . true .) call json % load_file ( filename = 'myfile.json' ) call json % print_file () !print to the console call json % get ( 'var.i' , ival , found ) call json % get ( 'var.r(3)' , rval , found ) call json % get ( 'var.c' , cval , found ) call json % destroy () end program test Components Type Visibility Attributes Name Initial type( json_core ), private :: core The instance of the json_core factory used for this file. type( json_value ), private, pointer :: p => null() the JSON structure read from the file Constructor public interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object, and either the json_core settings or a json_core instance. private function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_file ) Description Author Izaak Beekman Date 07/23/2015 Cast a json_value object as a json_file object.\n  It also calls the initialize() method. private function initialize_json_file_v2 (json_value_object, json_core_object) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Description Author Jacob Williams Date 4/26/2016 Cast a json_value pointer and a json_core object\n  as a json_file object. Type-Bound Procedures generic, public :: initialize => initialize_json_core_in_file , set_json_core_in_file private subroutine initialize_json_core_in_file (me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Description Initialize the json_core for this json_file .\n  This is just a wrapper for json_initialize . private subroutine set_json_core_in_file (me, core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_core ), intent(in) :: core Description Set the json_core for this json_file . procedure, public :: get_core => get_json_core_in_file private subroutine get_json_core_in_file (me, core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me type( json_core ), intent(out) :: core Description Get a copy of the json_core in this json_file . procedure, public :: load_file => json_file_load private subroutine json_file_load (me, filename, unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use (if not present, a newunit is used) Description Author Jacob Williams Date 12/9/2013 Load the JSON data from a file. generic, public :: load_from_string => json_file_load_from_string , wrap_json_file_load_from_string private subroutine json_file_load_from_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from Description Author Jacob Williams Date 1/13/2015 Load the JSON data from a string. private subroutine wrap_json_file_load_from_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: str Description Alternate version of json_file_load_from_string , where \"str\" is kind=CDK. procedure, public :: destroy => json_file_destroy private subroutine json_file_destroy (me, destroy_core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical, intent(in), optional :: destroy_core to also destroy the json_core .\n default is to leave it as is. Description Author Jacob Williams Destroy the json_value data in a json_file .\n  This must be done when the variable is no longer needed,\n  or will be reused to open a different file.\n  Otherwise a memory leak will occur. procedure, public :: move => json_file_move_pointer private subroutine json_file_move_pointer (to, from) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from Description Author Jacob Williams Date 12/5/2014 Move the json_value pointer from one json_file to another.\n  The \"from\" pointer is then nullified, but not destroyed. generic, public :: info => json_file_variable_info , wrap_json_file_variable_info private subroutine json_file_variable_info (me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children Description Author Jacob Williams Date 2/3/2014 Returns information about a variable in a json_file . private subroutine wrap_json_file_variable_info (me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: found integer(kind=IK), intent(out) :: var_type integer(kind=IK), intent(out) :: n_children Description Alternate version of json_file_variable_info , where \"path\" is kind=CDK. procedure, public :: failed => json_file_failed private pure function json_file_failed (me) result(failed) Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me Return Value logical(kind=LK) will be true if there has been an error. Description Check error status in the file. procedure, public :: print_error_message => json_file_print_error_message private subroutine json_file_print_error_message (me, io_unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer, intent(in), optional :: io_unit Description This is a wrapper for json_print_error_message . procedure, public :: check_for_errors => json_file_check_for_errors private subroutine json_file_check_for_errors (me, status_ok, error_msg) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Description Retrieve error status and message from the class. procedure, public :: clear_exceptions => json_file_clear_exceptions private pure subroutine json_file_clear_exceptions (me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Clear exceptions in the class. procedure, public :: print_to_string => json_file_print_to_string private subroutine json_file_print_to_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to Description Author Jacob Williams Date 1/11/2015 Print the JSON file to a string. generic, public :: print_file => json_file_print_to_console , json_file_print_1 , json_file_print_2 private subroutine json_file_print_to_console (me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Author Jacob Williams Date 1/11/2015 Print the JSON file to the console. private subroutine json_file_print_1 (me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) Description Author Jacob Williams Date 12/9/2013 Prints the JSON file to the specified file unit number. private subroutine json_file_print_2 (me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to Description Author Jacob Williams Date 1/11/2015 Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. generic, public :: get => json_file_get_object , wrap_json_file_get_object , json_file_get_integer , wrap_json_file_get_integer , json_file_get_double , wrap_json_file_get_double , json_file_get_logical , wrap_json_file_get_logical , json_file_get_string , wrap_json_file_get_string , json_file_get_integer_vec , wrap_json_file_get_integer_vec , json_file_get_double_vec , wrap_json_file_get_double_vec , json_file_get_logical_vec , wrap_json_file_get_logical_vec , json_file_get_string_vec , wrap_json_file_get_string_vec , json_file_get_root private subroutine json_file_get_object (me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 2/3/2014 Get a json_value pointer to an object from a JSON file. private subroutine wrap_json_file_get_object (me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_object , where \"path\" is kind=CDK. private subroutine json_file_get_integer (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 12/9/2013 Get an integer value from a JSON file. private subroutine wrap_json_file_get_integer (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer , where \"path\" is kind=CDK. private subroutine json_file_get_double (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a real(RK) variable value from a JSON file. private subroutine wrap_json_file_get_double (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double , where \"path\" is kind=CDK. private subroutine json_file_get_logical (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a logical(LK) value from a JSON file. private subroutine wrap_json_file_get_logical (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical , where \"path\" is kind=CDK. private subroutine json_file_get_string (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a character string from a json file.\n  The output val is an allocatable character string. private subroutine wrap_json_file_get_string (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string , where \"path\" is kind=CDK. private subroutine json_file_get_integer_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 1/20/2014 Get an integer vector from a JSON file. private subroutine wrap_json_file_get_integer_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer_vec , where \"path\" is kind=CDK. private subroutine json_file_get_double_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/19/2014 Get a real(RK) vector from a JSON file. private subroutine wrap_json_file_get_double_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double_vec , where \"path\" is kind=CDK. private subroutine json_file_get_logical_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/20/2014 Get a logical(LK) vector from a JSON file. private subroutine wrap_json_file_get_logical_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical_vec , where \"path\" is kind=CDK. private subroutine json_file_get_string_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/19/2014 Get a string vector from a JSON file. private subroutine wrap_json_file_get_string_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string_vec , where \"path\" is kind=CDK. private subroutine json_file_get_root (me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable Description Author Izaak Beekman Date 7/23/2015 Get a json_value pointer to the JSON file root. generic, public :: update => json_file_update_integer , wrap_json_file_update_integer , json_file_update_logical , wrap_json_file_update_logical , json_file_update_real , wrap_json_file_update_real , json_file_update_string , wrap_json_file_update_string private subroutine json_file_update_integer (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_file_update_integer (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_integer , where \"name\" is kind=CDK. private subroutine json_file_update_logical (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_file_update_logical (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_logical , where \"name\" is kind=CDK. private subroutine json_file_update_real (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_file_update_real (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_real , where \"name\" is kind=CDK. private subroutine json_file_update_string (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_file_update_string (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" and \"val\" are kind=CDK. generic, public :: update => json_file_update_string_name_ascii , json_file_update_string_val_ascii private subroutine json_file_update_string_name_ascii (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" is kind=CDK. private subroutine json_file_update_string_val_ascii (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"val\" is kind=CDK. procedure, public :: traverse => json_file_traverse private subroutine json_file_traverse (me, traverse_callback) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure( json_traverse_callback_func ) :: traverse_callback Description Author Jacob Williams Date 6/11/2016 Traverse the JSON structure in the file.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. procedure, public :: wrap_json_file_load_from_string private subroutine wrap_json_file_load_from_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: str Description Alternate version of json_file_load_from_string , where \"str\" is kind=CDK. procedure, public :: json_file_load_from_string private subroutine json_file_load_from_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from Description Author Jacob Williams Date 1/13/2015 Load the JSON data from a string. procedure, public :: initialize_json_core_in_file private subroutine initialize_json_core_in_file (me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Description Initialize the json_core for this json_file .\n  This is just a wrapper for json_initialize . procedure, public :: set_json_core_in_file private subroutine set_json_core_in_file (me, core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_core ), intent(in) :: core Description Set the json_core for this json_file . procedure, public :: wrap_json_file_variable_info private subroutine wrap_json_file_variable_info (me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: found integer(kind=IK), intent(out) :: var_type integer(kind=IK), intent(out) :: n_children Description Alternate version of json_file_variable_info , where \"path\" is kind=CDK. procedure, public :: json_file_variable_info private subroutine json_file_variable_info (me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children Description Author Jacob Williams Date 2/3/2014 Returns information about a variable in a json_file . procedure, public :: wrap_json_file_get_object private subroutine wrap_json_file_get_object (me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_object , where \"path\" is kind=CDK. procedure, public :: json_file_get_object private subroutine json_file_get_object (me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 2/3/2014 Get a json_value pointer to an object from a JSON file. procedure, public :: wrap_json_file_get_integer private subroutine wrap_json_file_get_integer (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer , where \"path\" is kind=CDK. procedure, public :: json_file_get_integer private subroutine json_file_get_integer (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 12/9/2013 Get an integer value from a JSON file. procedure, public :: wrap_json_file_get_double private subroutine wrap_json_file_get_double (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double , where \"path\" is kind=CDK. procedure, public :: json_file_get_double private subroutine json_file_get_double (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a real(RK) variable value from a JSON file. procedure, public :: wrap_json_file_get_logical private subroutine wrap_json_file_get_logical (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical , where \"path\" is kind=CDK. procedure, public :: json_file_get_logical private subroutine json_file_get_logical (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a logical(LK) value from a JSON file. procedure, public :: wrap_json_file_get_string private subroutine wrap_json_file_get_string (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string , where \"path\" is kind=CDK. procedure, public :: json_file_get_string private subroutine json_file_get_string (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a character string from a json file.\n  The output val is an allocatable character string. procedure, public :: wrap_json_file_get_integer_vec private subroutine wrap_json_file_get_integer_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer_vec , where \"path\" is kind=CDK. procedure, public :: json_file_get_integer_vec private subroutine json_file_get_integer_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 1/20/2014 Get an integer vector from a JSON file. procedure, public :: wrap_json_file_get_double_vec private subroutine wrap_json_file_get_double_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double_vec , where \"path\" is kind=CDK. procedure, public :: json_file_get_double_vec private subroutine json_file_get_double_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/19/2014 Get a real(RK) vector from a JSON file. procedure, public :: wrap_json_file_get_logical_vec private subroutine wrap_json_file_get_logical_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical_vec , where \"path\" is kind=CDK. procedure, public :: json_file_get_logical_vec private subroutine json_file_get_logical_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/20/2014 Get a logical(LK) vector from a JSON file. procedure, public :: wrap_json_file_get_string_vec private subroutine wrap_json_file_get_string_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string_vec , where \"path\" is kind=CDK. procedure, public :: json_file_get_string_vec private subroutine json_file_get_string_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/19/2014 Get a string vector from a JSON file. procedure, public :: json_file_get_root private subroutine json_file_get_root (me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable Description Author Izaak Beekman Date 7/23/2015 Get a json_value pointer to the JSON file root. procedure, public :: wrap_json_file_update_integer private subroutine wrap_json_file_update_integer (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_integer , where \"name\" is kind=CDK. procedure, public :: json_file_update_integer private subroutine json_file_update_integer (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: wrap_json_file_update_logical private subroutine wrap_json_file_update_logical (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_logical , where \"name\" is kind=CDK. procedure, public :: json_file_update_logical private subroutine json_file_update_logical (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: wrap_json_file_update_real private subroutine wrap_json_file_update_real (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_real , where \"name\" is kind=CDK. procedure, public :: json_file_update_real private subroutine json_file_update_real (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: wrap_json_file_update_string private subroutine wrap_json_file_update_string (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" and \"val\" are kind=CDK. procedure, public :: json_file_update_string private subroutine json_file_update_string (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: json_file_update_string_name_ascii private subroutine json_file_update_string_name_ascii (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" is kind=CDK. procedure, public :: json_file_update_string_val_ascii private subroutine json_file_update_string_val_ascii (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"val\" is kind=CDK. procedure, public :: json_file_print_to_console private subroutine json_file_print_to_console (me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Author Jacob Williams Date 1/11/2015 Print the JSON file to the console. procedure, public :: json_file_print_1 private subroutine json_file_print_1 (me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) Description Author Jacob Williams Date 12/9/2013 Prints the JSON file to the specified file unit number. procedure, public :: json_file_print_2 private subroutine json_file_print_2 (me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to Description Author Jacob Williams Date 1/11/2015 Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. Source Code type , public :: json_file private type ( json_core ) :: core !! The instance of the [[json_core]] factory used for this file. type ( json_value ), pointer :: p => null () !! the JSON structure read from the file contains generic , public :: initialize => initialize_json_core_in_file ,& set_json_core_in_file procedure , public :: get_core => get_json_core_in_file procedure , public :: load_file => json_file_load generic , public :: load_from_string => MAYBEWRAP ( json_file_load_from_string ) procedure , public :: destroy => json_file_destroy procedure , public :: move => json_file_move_pointer generic , public :: info => MAYBEWRAP ( json_file_variable_info ) !error checking: procedure , public :: failed => json_file_failed procedure , public :: print_error_message => json_file_print_error_message procedure , public :: check_for_errors => json_file_check_for_errors procedure , public :: clear_exceptions => json_file_clear_exceptions procedure , public :: print_to_string => json_file_print_to_string generic , public :: print_file => json_file_print_to_console , & json_file_print_1 , & json_file_print_2 generic , public :: get => MAYBEWRAP ( json_file_get_object ), & MAYBEWRAP ( json_file_get_integer ), & MAYBEWRAP ( json_file_get_double ), & MAYBEWRAP ( json_file_get_logical ), & MAYBEWRAP ( json_file_get_string ), & MAYBEWRAP ( json_file_get_integer_vec ), & MAYBEWRAP ( json_file_get_double_vec ), & MAYBEWRAP ( json_file_get_logical_vec ), & MAYBEWRAP ( json_file_get_string_vec ), & json_file_get_root generic , public :: update => MAYBEWRAP ( json_file_update_integer ), & MAYBEWRAP ( json_file_update_logical ), & MAYBEWRAP ( json_file_update_real ), & MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 generic , public :: update => json_file_update_string_name_ascii , & json_file_update_string_val_ascii #endif !traverse procedure , public :: traverse => json_file_traverse ! *************************************************** ! private routines ! *************************************************** !load from string: procedure :: MAYBEWRAP ( json_file_load_from_string ) !initialize procedure :: initialize_json_core_in_file procedure :: set_json_core_in_file !git info: procedure :: MAYBEWRAP ( json_file_variable_info ) !get: procedure :: MAYBEWRAP ( json_file_get_object ) procedure :: MAYBEWRAP ( json_file_get_integer ) procedure :: MAYBEWRAP ( json_file_get_double ) procedure :: MAYBEWRAP ( json_file_get_logical ) procedure :: MAYBEWRAP ( json_file_get_string ) procedure :: MAYBEWRAP ( json_file_get_integer_vec ) procedure :: MAYBEWRAP ( json_file_get_double_vec ) procedure :: MAYBEWRAP ( json_file_get_logical_vec ) procedure :: MAYBEWRAP ( json_file_get_string_vec ) procedure :: json_file_get_root !update: procedure :: MAYBEWRAP ( json_file_update_integer ) procedure :: MAYBEWRAP ( json_file_update_logical ) procedure :: MAYBEWRAP ( json_file_update_real ) procedure :: MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 procedure :: json_file_update_string_name_ascii procedure :: json_file_update_string_val_ascii #endif !print_file: procedure :: json_file_print_to_console procedure :: json_file_print_1 procedure :: json_file_print_2 end type json_file","tags":"","loc":"type/json_file.html","title":"json_file â€“ JSON-Fortran "},{"text":"type, public :: json_value sequence Type used to construct the linked-list JSON structure.\n  Normally, this should always be a pointer variable.\n  This type should only be used by an instance of json_core . Example The following test program: program test use json_module implicit none type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_object ( p , '' ) !create the root call json % add ( p , 'year' , 1805 ) !add some data call json % add ( p , 'value' , 1.0_RK ) !add some data call json % print ( p , 'test.json' ) !write it to a file call json % destroy ( p ) !cleanup end program test Produces the JSON file test.json : { \"year\" : 1805 , \"value\" : 0.1E+1 } Inherited By type~~json_value~~InheritedByGraph type~json_value json_value type~json_value->type~json_value previous, next, parent, children, tail type~json_file json_file type~json_value->type~json_file p Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial type( json_value ), private, pointer :: previous => null() previous item in the list type( json_value ), private, pointer :: next => null() next item in the list type( json_value ), private, pointer :: parent => null() parent item of this type( json_value ), private, pointer :: children => null() first child item of this type( json_value ), private, pointer :: tail => null() last child item of this character(kind=CK,len=:), private, allocatable :: name variable name real(kind=RK), private, allocatable :: dbl_value real data for this variable logical(kind=LK), private, allocatable :: log_value logical data for this variable character(kind=CK,len=:), private, allocatable :: str_value string data for this variable integer(kind=IK), private, allocatable :: int_value integer data for this variable integer(kind=IK), private :: var_type = json_unknown variable type integer(kind=IK), private :: n_children = 0 number of children Source Code type , public :: json_value !force the constituents to be stored contiguously ![note: on Intel, the order of the variables below ! is significant to avoid the misaligned field warnings] sequence private !for the linked list: type ( json_value ), pointer :: previous => null () !! previous item in the list type ( json_value ), pointer :: next => null () !! next item in the list type ( json_value ), pointer :: parent => null () !! parent item of this type ( json_value ), pointer :: children => null () !! first child item of this type ( json_value ), pointer :: tail => null () !! last child item of this character ( kind = CK , len = :), allocatable :: name !! variable name real ( RK ), allocatable :: dbl_value !! real data for this variable logical ( LK ), allocatable :: log_value !! logical data for this variable character ( kind = CK , len = :), allocatable :: str_value !! string data for this variable integer ( IK ), allocatable :: int_value !! integer data for this variable integer ( IK ) :: var_type = json_unknown !! variable type integer ( IK ), private :: n_children = 0 !! number of children end type json_value","tags":"","loc":"type/json_value.html","title":"json_value â€“ JSON-Fortran "},{"text":"type, public :: json_core To access the core routines for manipulation\n  of json_value pointer variables. This class allows\n  for thread safe use of the module. Usage program test use json_module implicit none type ( json_core ) :: json !<--have to declare this type ( json_value ), pointer :: p call json % create_object ( p , '' ) !create the root call json % add ( p , 'year' , 1805 ) !add some data call json % add ( p , 'value' , 1.0_RK ) !add some data call json % print ( p , 'test.json' ) !write it to a file call json % destroy ( p ) !cleanup end program test type , public :: json_core Inherited By type~~json_core~~InheritedByGraph type~json_core json_core type~json_file json_file type~json_core->type~json_file core Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=IK), private :: spaces_per_tab = 2 number of spaces for indenting logical(kind=LK), private :: compact_real = .true. to use the \"compact\" form of real\n numbers for output character(kind=CDK,len=:), private, allocatable :: real_fmt the format string to use\n for converting real numbers to strings.\n It can be set in json_initialize ,\n and used in json_value_print If not set, then default_real_fmt is used instead. logical(kind=LK), private :: is_verbose = .false. if true, all exceptions are\n immediately printed to console. logical(kind=LK), private :: exception_thrown = .false. The error flag. Will be set to true\n when an error is thrown in the class.\n Many of the methods will check this\n and return immediately if it is true. character(kind=CK,len=:), private, allocatable :: err_message the error message integer(kind=IK), private :: char_count = 0 character position in the current line integer(kind=IK), private :: line_count = 1 lines read counter integer(kind=IK), private :: pushed_index = 0 used when parsing lines in file character(kind=CK,len=pushed_char_size), private :: pushed_char = '' used when parsing\n lines in file integer(kind=IK), private :: ipos = 1 for allocatable strings: next character to read logical(kind=LK), private :: strict_type_checking = .false. if true, then no type conversions are done\n in the get routines if the actual variable\n type is different from the return type (for\n example, integer to double). logical(kind=LK), private :: trailing_spaces_significant = .false. for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), private :: case_sensitive_keys = .true. for name and path comparisons, are they\n case sensitive. Constructor public interface json_core Structure constructor to initialize a json_core object private function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(json_core_object) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_core ) Description Author Jacob Williams Date 4/26/2016 Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Type-Bound Procedures generic, public :: get_child => json_value_get_by_index , json_value_get_child , json_value_get_by_name_chars , wrap_json_value_get_by_name_chars private subroutine json_value_get_by_index (json, p, idx, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child type( json_value ), , pointer :: child pointer to the child Description Returns a child in the object or array given the index. private subroutine json_value_get_child (json, p, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), , pointer :: child pointer to the child Description Returns pointer to the first child of the object\n  (or null() if it is not associated). private subroutine json_value_get_by_name_chars (json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), , pointer :: child pointer to the child Description Returns a child in the object or array given the name string. private subroutine wrap_json_value_get_by_name_chars (json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name type( json_value ), , pointer :: child Description Alternate version of json_value_get_by_name_chars where name is kind=CDK. procedure, private :: json_value_get_by_index private subroutine json_value_get_by_index (json, p, idx, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child type( json_value ), , pointer :: child pointer to the child Description Returns a child in the object or array given the index. procedure, private :: wrap_json_value_get_by_name_chars private subroutine wrap_json_value_get_by_name_chars (json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name type( json_value ), , pointer :: child Description Alternate version of json_value_get_by_name_chars where name is kind=CDK. procedure, private :: json_value_get_by_name_chars private subroutine json_value_get_by_name_chars (json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), , pointer :: child pointer to the child Description Returns a child in the object or array given the name string. procedure, private :: json_value_get_child private subroutine json_value_get_child (json, p, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), , pointer :: child pointer to the child Description Returns pointer to the first child of the object\n  (or null() if it is not associated). generic, public :: add => json_value_add_member , json_value_add_integer , wrap_json_value_add_integer , json_value_add_integer_vec , wrap_json_value_add_integer_vec , json_value_add_double , wrap_json_value_add_double , json_value_add_double_vec , wrap_json_value_add_double_vec , json_value_add_logical , wrap_json_value_add_logical , json_value_add_logical_vec , wrap_json_value_add_logical_vec , json_value_add_string , wrap_json_value_add_string , json_value_add_string_vec , wrap_json_value_add_string_vec Add objects to a linked list of json_value s. private subroutine json_value_add_member (json, p, member) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p type( json_value ), , pointer :: member the child member to add Description Adds member as a child of p . private subroutine json_value_add_integer (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val Description Author Jacob Williams Date 1/20/2014 Add an integer value child to the json_value variable private subroutine wrap_json_value_add_integer (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in) :: val value Description Alternate version of json_value_add_integer where name is kind=CDK. private subroutine json_value_add_integer_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Author Jacob Williams Date 1/20/2014 Add an integer vector to the structure. private subroutine wrap_json_value_add_integer_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_integer_vec where name is kind=CDK. private subroutine json_value_add_double (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Author Jacob Williams Date 1/19/2014 Add a real value child to the json_value variable private subroutine wrap_json_value_add_double (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Alternate version of json_value_add_double where name is kind=CDK. private subroutine json_value_add_double_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Author Jacob Williams Date 1/20/2014 Add a real vector to the structure. private subroutine wrap_json_value_add_double_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Alternate version of json_value_add_double_vec where name is kind=CDK. private subroutine json_value_add_logical (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Author Jacob Williams Date 1/20/2014 Add a logical value child to the json_value variable private subroutine wrap_json_value_add_logical (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Alternate version of json_value_add_logical where name is kind=CDK. private subroutine json_value_add_logical_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value Description Author Jacob Williams Date 1/20/2014 Add a logical vector to the structure. private subroutine wrap_json_value_add_logical_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_logical_vec where name is kind=CDK. private subroutine json_value_add_string (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Author Jacob Williams Date 1/19/2014 Add a character string child to the json_value variable. private subroutine wrap_json_value_add_string (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where name and val are kind=CDK. private subroutine json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Description Author Jacob Williams Date 1/19/2014 Add an array of character strings to the structure. private subroutine wrap_json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where name and val are kind=CDK. generic, public :: add => json_value_add_string_name_ascii , json_value_add_string_val_ascii , json_value_add_string_vec_name_ascii , json_value_add_string_vec_val_ascii private subroutine json_value_add_string_name_ascii (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where name is kind=CDK. private subroutine json_value_add_string_val_ascii (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where val is kind=CDK. private subroutine json_value_add_string_vec_name_ascii (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where name is kind=CDK. private subroutine json_value_add_string_vec_val_ascii (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where val is kind=CDK. procedure, private :: json_value_add_member private subroutine json_value_add_member (json, p, member) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p type( json_value ), , pointer :: member the child member to add Description Adds member as a child of p . procedure, private :: wrap_json_value_add_integer private subroutine wrap_json_value_add_integer (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in) :: val value Description Alternate version of json_value_add_integer where name is kind=CDK. procedure, private :: json_value_add_integer private subroutine json_value_add_integer (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val Description Author Jacob Williams Date 1/20/2014 Add an integer value child to the json_value variable procedure, private :: wrap_json_value_add_integer_vec private subroutine wrap_json_value_add_integer_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_integer_vec where name is kind=CDK. procedure, private :: json_value_add_integer_vec private subroutine json_value_add_integer_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Author Jacob Williams Date 1/20/2014 Add an integer vector to the structure. procedure, private :: wrap_json_value_add_double private subroutine wrap_json_value_add_double (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Alternate version of json_value_add_double where name is kind=CDK. procedure, private :: json_value_add_double private subroutine json_value_add_double (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Author Jacob Williams Date 1/19/2014 Add a real value child to the json_value variable procedure, private :: wrap_json_value_add_double_vec private subroutine wrap_json_value_add_double_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Alternate version of json_value_add_double_vec where name is kind=CDK. procedure, private :: json_value_add_double_vec private subroutine json_value_add_double_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Author Jacob Williams Date 1/20/2014 Add a real vector to the structure. procedure, private :: wrap_json_value_add_logical private subroutine wrap_json_value_add_logical (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Alternate version of json_value_add_logical where name is kind=CDK. procedure, private :: json_value_add_logical private subroutine json_value_add_logical (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Author Jacob Williams Date 1/20/2014 Add a logical value child to the json_value variable procedure, private :: wrap_json_value_add_logical_vec private subroutine wrap_json_value_add_logical_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_logical_vec where name is kind=CDK. procedure, private :: json_value_add_logical_vec private subroutine json_value_add_logical_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value Description Author Jacob Williams Date 1/20/2014 Add a logical vector to the structure. procedure, private :: wrap_json_value_add_string private subroutine wrap_json_value_add_string (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where name and val are kind=CDK. procedure, private :: json_value_add_string private subroutine json_value_add_string (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Author Jacob Williams Date 1/19/2014 Add a character string child to the json_value variable. procedure, private :: wrap_json_value_add_string_vec private subroutine wrap_json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where name and val are kind=CDK. procedure, private :: json_value_add_string_vec private subroutine json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Description Author Jacob Williams Date 1/19/2014 Add an array of character strings to the structure. procedure, private :: json_value_add_string_name_ascii private subroutine json_value_add_string_name_ascii (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where name is kind=CDK. procedure, private :: json_value_add_string_val_ascii private subroutine json_value_add_string_val_ascii (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where val is kind=CDK. procedure, private :: json_value_add_string_vec_name_ascii private subroutine json_value_add_string_vec_name_ascii (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where name is kind=CDK. procedure, private :: json_value_add_string_vec_val_ascii private subroutine json_value_add_string_vec_val_ascii (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where val is kind=CDK. generic, public :: update => json_update_logical , wrap_json_update_logical , json_update_double , wrap_json_update_double , json_update_integer , wrap_json_update_integer , json_update_string , wrap_json_update_string These are like the add methods, except if a child with the\n  same name is already present, then its value is simply updated.\n  Note that currently, these only work for scalar variables.\n  These routines can also change the variable's type (but an error will be\n  thrown if the existing variable is not a scalar). Note It should not be used to change the type of a variable in an array,\n      or it may result in an invalid JSON file. private subroutine json_update_logical (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_update_logical (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_logical , where name is kind=CDK. private subroutine json_update_double (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_update_double (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_double , where name is kind=CDK. private subroutine json_update_integer (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_update_integer (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_integer , where name is kind=CDK. private subroutine json_update_string (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_update_string (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where name and value are kind=CDK. generic, public :: update => json_update_string_name_ascii , json_update_string_val_ascii private subroutine json_update_string_name_ascii (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where name is kind=CDK. private subroutine json_update_string_val_ascii (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where val is kind=CDK. procedure, private :: wrap_json_update_logical private subroutine wrap_json_update_logical (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_logical , where name is kind=CDK. procedure, private :: json_update_logical private subroutine json_update_logical (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, private :: wrap_json_update_double private subroutine wrap_json_update_double (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_double , where name is kind=CDK. procedure, private :: json_update_double private subroutine json_update_double (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, private :: wrap_json_update_integer private subroutine wrap_json_update_integer (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_integer , where name is kind=CDK. procedure, private :: json_update_integer private subroutine json_update_integer (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, private :: wrap_json_update_string private subroutine wrap_json_update_string (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where name and value are kind=CDK. procedure, private :: json_update_string private subroutine json_update_string (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, private :: json_update_string_name_ascii private subroutine json_update_string_name_ascii (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where name is kind=CDK. procedure, private :: json_update_string_val_ascii private subroutine json_update_string_val_ascii (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where val is kind=CDK. generic, public :: get => json_get_by_path , wrap_json_get_by_path , json_get_integer , json_get_integer_with_path , wrap_json_get_integer_with_path , json_get_integer_vec , json_get_integer_vec_with_path , wrap_json_get_integer_vec_with_path , json_get_double , json_get_double_with_path , wrap_json_get_double_with_path , json_get_double_vec , json_get_double_vec_with_path , wrap_json_get_double_vec_with_path , json_get_logical , json_get_logical_with_path , wrap_json_get_logical_with_path , json_get_logical_vec , json_get_logical_vec_with_path , wrap_json_get_logical_vec_with_path , json_get_string , json_get_string_with_path , wrap_json_get_string_with_path , json_get_string_vec , json_get_string_vec_with_path , wrap_json_get_string_vec_with_path , json_get_array , json_get_array_with_path , wrap_json_get_array_with_path Get data from a json_value linked list. Note There are two versions (e.g. json_get_integer and json_get_integer_with_path ).\n      The first one gets the value from the json_value passed into the routine,\n      while the second one gets the value from the json_value found by parsing the\n      path.  The path version is split up into unicode and non-unicode versions. private subroutine json_get_by_path (json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable specify by path logical(kind=LK), intent(out), optional :: found true if it was found Description Returns the json_value pointer given the path string. private subroutine wrap_json_get_by_path (json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_by_path where \"path\" is kind=CDK. private subroutine json_get_integer (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value Description Get an integer value from a json_value . private subroutine json_get_integer_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get an integer value from a json_value , given the path string. private subroutine wrap_json_get_integer_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_with_path , where \"path\" is kind=CDK. private subroutine json_get_integer_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get an integer vector from a json_value . private subroutine json_get_integer_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get an integer vector from a json_value , given the path string. private subroutine wrap_json_get_integer_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_vec_with_path , where \"path\" is kind=CDK private subroutine json_get_double (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out) :: value Description Get a double value from a json_value . private subroutine json_get_double_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get a double value from a json_value , given the path. private subroutine wrap_json_get_double_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_with_path , where \"path\" is kind=CDK private subroutine json_get_double_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a double vector from a json_value . private subroutine json_get_double_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a double vector from a json_value , given the path. private subroutine wrap_json_get_double_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_vec_with_path , where \"path\" is kind=CDK private subroutine json_get_logical (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK) :: value Description Get a logical value from a json_value . private subroutine json_get_logical_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found Description Get a logical value from a json_value , given the path. private subroutine wrap_json_get_logical_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_with_path , where \"path\" is kind=CDK private subroutine json_get_logical_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a logical vector from json_value . private subroutine json_get_logical_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical vector from a json_value , given the path. private subroutine wrap_json_get_logical_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_vec_with_path , where \"path\" is kind=CDK private subroutine json_get_string (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value Description Get a character string from a json_value . private subroutine json_get_string_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Get a character string from a json_value , given the path. private subroutine wrap_json_get_string_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_with_path , where \"path\" is kind=CDK private subroutine json_get_string_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a string vector from a json_value . private subroutine json_get_string_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a json_value , given the path. private subroutine wrap_json_get_string_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_vec_with_path , where \"path\" is kind=CDK private subroutine json_get_array (json, me, array_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure( json_array_callback_func ) :: array_callback Description This routine calls the user-supplied json_array_callback_func subroutine\n      for each element in the array. private subroutine json_get_array_with_path (json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Description This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). private subroutine wrap_json_get_array_with_path (json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_array_with_path , where \"path\" is kind=CDK procedure, private :: json_get_integer private subroutine json_get_integer (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value Description Get an integer value from a json_value . procedure, private :: json_get_integer_vec private subroutine json_get_integer_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get an integer vector from a json_value . procedure, private :: json_get_double private subroutine json_get_double (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out) :: value Description Get a double value from a json_value . procedure, private :: json_get_double_vec private subroutine json_get_double_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a double vector from a json_value . procedure, private :: json_get_logical private subroutine json_get_logical (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK) :: value Description Get a logical value from a json_value . procedure, private :: json_get_logical_vec private subroutine json_get_logical_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a logical vector from json_value . procedure, private :: json_get_string private subroutine json_get_string (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value Description Get a character string from a json_value . procedure, private :: json_get_string_vec private subroutine json_get_string_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a string vector from a json_value . procedure, private :: json_get_array private subroutine json_get_array (json, me, array_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure( json_array_callback_func ) :: array_callback Description This routine calls the user-supplied json_array_callback_func subroutine\n      for each element in the array. procedure, private :: wrap_json_get_by_path private subroutine wrap_json_get_by_path (json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_by_path where \"path\" is kind=CDK. procedure, private :: json_get_by_path private subroutine json_get_by_path (json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable specify by path logical(kind=LK), intent(out), optional :: found true if it was found Description Returns the json_value pointer given the path string. procedure, private :: wrap_json_get_integer_with_path private subroutine wrap_json_get_integer_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_with_path , where \"path\" is kind=CDK. procedure, private :: json_get_integer_with_path private subroutine json_get_integer_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get an integer value from a json_value , given the path string. procedure, private :: wrap_json_get_integer_vec_with_path private subroutine wrap_json_get_integer_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_vec_with_path , where \"path\" is kind=CDK procedure, private :: json_get_integer_vec_with_path private subroutine json_get_integer_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get an integer vector from a json_value , given the path string. procedure, private :: wrap_json_get_double_with_path private subroutine wrap_json_get_double_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_with_path , where \"path\" is kind=CDK procedure, private :: json_get_double_with_path private subroutine json_get_double_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get a double value from a json_value , given the path. procedure, private :: wrap_json_get_double_vec_with_path private subroutine wrap_json_get_double_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_vec_with_path , where \"path\" is kind=CDK procedure, private :: json_get_double_vec_with_path private subroutine json_get_double_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a double vector from a json_value , given the path. procedure, private :: wrap_json_get_logical_with_path private subroutine wrap_json_get_logical_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_with_path , where \"path\" is kind=CDK procedure, private :: json_get_logical_with_path private subroutine json_get_logical_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found Description Get a logical value from a json_value , given the path. procedure, private :: wrap_json_get_logical_vec_with_path private subroutine wrap_json_get_logical_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_vec_with_path , where \"path\" is kind=CDK procedure, private :: json_get_logical_vec_with_path private subroutine json_get_logical_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical vector from a json_value , given the path. procedure, private :: wrap_json_get_string_with_path private subroutine wrap_json_get_string_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_with_path , where \"path\" is kind=CDK procedure, private :: json_get_string_with_path private subroutine json_get_string_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Get a character string from a json_value , given the path. procedure, private :: wrap_json_get_string_vec_with_path private subroutine wrap_json_get_string_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_vec_with_path , where \"path\" is kind=CDK procedure, private :: json_get_string_vec_with_path private subroutine json_get_string_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a json_value , given the path. procedure, private :: wrap_json_get_array_with_path private subroutine wrap_json_get_array_with_path (json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_array_with_path , where \"path\" is kind=CDK procedure, private :: json_get_array_with_path private subroutine json_get_array_with_path (json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Description This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). procedure, public :: print_to_string => json_value_to_string Print the json_value structure to an allocatable string private subroutine json_value_to_string (json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string Description Author Jacob Williams Date 2/12/2014 Print the json_value structure to an allocatable string. generic, public :: print => json_print_1 , json_print_2 Print the json_value to a file. Example type ( json_core ) :: json type ( json_value ) :: p !... call json % print ( p , 'test.json' ) !this is json_print_2 private subroutine json_print_1 (json, p, iunit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must already have been opened, can't be -1). Description Author Jacob Williams Date 6/20/2014 Print the json_value structure to a file. private subroutine json_print_2 (json, p, filename) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to (should not already be open) Description Author Jacob Williams Date 12/23/2014 Print the json_value structure to a file. procedure, private :: json_print_1 private subroutine json_print_1 (json, p, iunit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must already have been opened, can't be -1). Description Author Jacob Williams Date 6/20/2014 Print the json_value structure to a file. procedure, private :: json_print_2 private subroutine json_print_2 (json, p, filename) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to (should not already be open) Description Author Jacob Williams Date 12/23/2014 Print the json_value structure to a file. generic, public :: destroy => json_value_destroy , destroy_json_core Destructor routine for a json_value pointer.\n  This must be called explicitly if it is no longer needed,\n  before it goes out of scope.  Otherwise, a memory leak will result. Example Destroy the json_value pointer before the variable goes out of scope: subroutine example1 () type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_object ( p , '' ) call json % add ( p , 'year' , 2015 ) call json % print ( p ) call json % destroy ( p ) end subroutine example1 Note: it should NOT be called for a json_value pointer than has already been\n  added to another json_value structure, since doing so may render the\n  other structure invalid.  Consider the following example: subroutine example2 ( p ) type ( json_core ) :: json type ( json_value ), pointer , intent ( out ) :: p type ( json_value ), pointer :: q call json % create_object ( p , '' ) call json % add ( p , 'year' , 2015 ) call json % create_object ( q , 'q' ) call json % add ( q , 'val' , 1 ) call json % add ( p , q ) !add q to p structure ! do NOT call json%destroy(q) here, because q is ! now part of the output structure p.  p should be destroyed ! somewhere upstream by the caller of this routine. nullify ( q ) !OK, but not strictly necessary end subroutine example2 private recursive subroutine json_value_destroy (json, p, destroy_next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) Description Author Jacob Williams Date 1/22/2014 Destroy a json_value linked-list structure. private subroutine destroy_json_core (me) Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me Description Author Jacob Williams Date 4/17/2016 Destructor for the json_core type. procedure, private :: json_value_destroy private recursive subroutine json_value_destroy (json, p, destroy_next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) Description Author Jacob Williams Date 1/22/2014 Destroy a json_value linked-list structure. procedure, private :: destroy_json_core private subroutine destroy_json_core (me) Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me Description Author Jacob Williams Date 4/17/2016 Destructor for the json_core type. generic, public :: remove_if_present => json_value_remove_if_present , wrap_json_value_remove_if_present If the child variable is present, then remove it. private subroutine json_value_remove_if_present (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Date 12/6/2014 Given the path string, remove the variable from\n  the json_value structure, if it exists. private subroutine wrap_json_value_remove_if_present (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Alternate version of json_value_remove_if_present , where name is kind=CDK. procedure, private :: wrap_json_value_remove_if_present private subroutine wrap_json_value_remove_if_present (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Alternate version of json_value_remove_if_present , where name is kind=CDK. procedure, private :: json_value_remove_if_present private subroutine json_value_remove_if_present (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Date 12/6/2014 Given the path string, remove the variable from\n  the json_value structure, if it exists. generic, public :: create_double => json_value_create_double , wrap_json_value_create_double Allocate a json_value pointer and make it a double variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_double ( p , 'value' , 1.0_RK ) private subroutine json_value_create_double (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_double (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper for json_value_create_double so that create_double method\n  may be called with an actual argument corresponding to the dummy argument, name that may be of 'DEFAULT' or 'ISO_10646' character kind. procedure, private :: wrap_json_value_create_double private subroutine wrap_json_value_create_double (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper for json_value_create_double so that create_double method\n  may be called with an actual argument corresponding to the dummy argument, name that may be of 'DEFAULT' or 'ISO_10646' character kind. procedure, private :: json_value_create_double private subroutine json_value_create_double (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. generic, public :: create_array => json_value_create_array , wrap_json_value_create_array Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_array ( p , 'arrayname' ) private subroutine json_value_create_array (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_array (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper for json_value_create_array so that create_array method may be\n  called with an actual argument, corresponding to the dummy argument name ,\n  that is either of 'DEFAULT' or 'ISO_10646' character kind. procedure, private :: wrap_json_value_create_array private subroutine wrap_json_value_create_array (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper for json_value_create_array so that create_array method may be\n  called with an actual argument, corresponding to the dummy argument name ,\n  that is either of 'DEFAULT' or 'ISO_10646' character kind. procedure, private :: json_value_create_array private subroutine json_value_create_array (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. generic, public :: create_object => json_value_create_object , wrap_json_value_create_object Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_object ( p , 'objectname' ) Note The name is not significant for the root structure or an array element.\n      In those cases, an empty string can be used. private subroutine json_value_create_object (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_object (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_object so that create_object method may be called\n  with an actual argument corresponding to the dummy argument name that is of\n  either 'DEFAULT' or 'ISO_10646' character kind. procedure, private :: wrap_json_value_create_object private subroutine wrap_json_value_create_object (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_object so that create_object method may be called\n  with an actual argument corresponding to the dummy argument name that is of\n  either 'DEFAULT' or 'ISO_10646' character kind. procedure, private :: json_value_create_object private subroutine json_value_create_object (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. generic, public :: create_null => json_value_create_null , wrap_json_value_create_null Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_null ( p , 'value' ) private subroutine json_value_create_null (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_null (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_null so that create_null method may be called with\n  an actual argument corresponding to the dummy argument name that is either\n  of 'DEFAULT' or 'ISO_10646' character kind. procedure, private :: wrap_json_value_create_null private subroutine wrap_json_value_create_null (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_null so that create_null method may be called with\n  an actual argument corresponding to the dummy argument name that is either\n  of 'DEFAULT' or 'ISO_10646' character kind. procedure, private :: json_value_create_null private subroutine json_value_create_null (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. generic, public :: create_string => json_value_create_string , wrap_json_value_create_string Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_string ( p , 'value' , 'foobar' ) private subroutine json_value_create_string (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_string (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_string so that create_string method may be called\n  with actual character string arguments for name and val that are BOTH of\n  'DEFAULT' or 'ISO_10646' character kind. procedure, private :: wrap_json_value_create_string private subroutine wrap_json_value_create_string (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_string so that create_string method may be called\n  with actual character string arguments for name and val that are BOTH of\n  'DEFAULT' or 'ISO_10646' character kind. procedure, private :: json_value_create_string private subroutine json_value_create_string (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. generic, public :: create_integer => json_value_create_integer , wrap_json_value_create_integer Allocate a json_value pointer and make it an integer variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_integer ( p , 'value' , 42 ) private subroutine json_value_create_integer (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_integer (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper procedure for json_value_create_integer so that create_integer method may be called with either a 'DEFAULT' or 'ISO_10646' character kind name actual argument. procedure, private :: wrap_json_value_create_integer private subroutine wrap_json_value_create_integer (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper procedure for json_value_create_integer so that create_integer method may be called with either a 'DEFAULT' or 'ISO_10646' character kind name actual argument. procedure, private :: json_value_create_integer private subroutine json_value_create_integer (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. generic, public :: create_logical => json_value_create_logical , wrap_json_value_create_logical Allocate a json_value pointer and make it a logical variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_logical ( p , 'value' ,. true .) private subroutine json_value_create_logical (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name Description Author Jacob Williams Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_logical (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrapper for json_value_create_logical so create_logical method can\n  be called with name of character kind 'DEFAULT' or 'ISO_10646' procedure, private :: wrap_json_value_create_logical private subroutine wrap_json_value_create_logical (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrapper for json_value_create_logical so create_logical method can\n  be called with name of character kind 'DEFAULT' or 'ISO_10646' procedure, private :: json_value_create_logical private subroutine json_value_create_logical (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name Description Author Jacob Williams Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. generic, public :: parse => json_parse_file , json_parse_string , wrap_json_parse_string Parse the JSON file and populate the json_value tree. private subroutine json_parse_file (json, file, p, unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), , pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) Description Parse the JSON file and populate the json_value tree. private subroutine json_parse_string (json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data Description Parse the JSON string and populate the json_value tree. private subroutine wrap_json_parse_string (json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CDK,len=*), intent(in) :: str string with JSON data Description Alternate version of json_parse_string , where str is kind=CDK. procedure, private :: json_parse_file private subroutine json_parse_file (json, file, p, unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), , pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) Description Parse the JSON file and populate the json_value tree. procedure, private :: wrap_json_parse_string private subroutine wrap_json_parse_string (json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CDK,len=*), intent(in) :: str string with JSON data Description Alternate version of json_parse_string , where str is kind=CDK. procedure, private :: json_parse_string private subroutine json_parse_string (json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data Description Parse the JSON string and populate the json_value tree. generic, public :: throw_exception => json_throw_exception , wrap_json_throw_exception Throw an exception. private subroutine json_throw_exception (json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message Description Author Jacob Williams Date 12/4/2013 Throw an exception in the json_core .\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. private subroutine wrap_json_throw_exception (json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: msg the error message Description Alternate version of json_throw_exception , where msg is kind=CDK. procedure, private :: wrap_json_throw_exception private subroutine wrap_json_throw_exception (json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: msg the error message Description Alternate version of json_throw_exception , where msg is kind=CDK. procedure, private :: json_throw_exception private subroutine json_throw_exception (json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message Description Author Jacob Williams Date 12/4/2013 Throw an exception in the json_core .\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. generic, public :: rename => json_value_rename , wrap_json_value_rename Rename a json_value variable. private subroutine json_value_rename (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name Description Author Jacob Williams Date 4/29/2016 Rename a json_value . private subroutine wrap_json_value_rename (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name new variable name Description Author Jacob Williams Date 4/29/2016 Alternate version of json_value_rename , where name is kind=CDK. procedure, private :: wrap_json_value_rename private subroutine wrap_json_value_rename (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name new variable name Description Author Jacob Williams Date 4/29/2016 Alternate version of json_value_rename , where name is kind=CDK. procedure, private :: json_value_rename private subroutine json_value_rename (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name Description Author Jacob Williams Date 4/29/2016 Rename a json_value . procedure, public :: remove => json_value_remove Remove a json_value from a linked-list structure. private subroutine json_value_remove (json, p, destroy) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. Description Author Jacob Williams Date 9/9/2014 Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure. procedure, public :: check_for_errors => json_check_for_errors check for error and get error message private subroutine json_check_for_errors (json, status_ok, error_msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Description Author Jacob Williams Date 12/4/2013 Retrieve error code from the json_core .\n  This should be called after parse to check for errors.\n  If an error is thrown, before using the class again, json_initialize should be called to clean up before it is used again. procedure, public :: clear_exceptions => json_clear_exceptions clear exceptions private pure subroutine json_clear_exceptions (json) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json Description Author Jacob Williams Date 12/4/2013 Clear exceptions in the json_core . procedure, public :: count => json_count count the number of children private function json_count (json, p) result(count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p Return Value integer(kind=IK) number of children Description Count the number of children. procedure, public :: clone => json_clone clone a JSON structure (deep copy) private subroutine json_clone (json, from, to) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: from this is the structure to clone type( json_value ), , pointer :: to the clone is put here\n (it must not already be associated) Description Author Jacob Williams Date 10/31/2015 Create a deep copy of a json_value linked-list structure. procedure, public :: failed => json_failed check for error private pure function json_failed (json) result(failed) Arguments Type Intent Optional Attributes Name class( json_core ), intent(in) :: json Return Value logical(kind=LK) will be true if an exception\n has been thrown. Description Author Jacob Williams Date 12/5/2013 Logical function to indicate if an exception has been thrown in a json_core . procedure, public :: get_parent => json_get_parent get pointer to json_value parent private subroutine json_get_parent (json, p, parent) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: parent pointer to parent Description Author Jacob Williams Date 10/16/2015 Returns a pointer to the parent of a json_value .\n  If there is no parent, then a null() pointer is returned. procedure, public :: get_next => json_get_next get pointer to json_value next private subroutine json_get_next (json, p, next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: next pointer to next Description Author Jacob Williams Date 10/31/2015 Returns a pointer to the next of a json_value .\n  If there is no next, then a null() pointer is returned. procedure, public :: get_previous => json_get_previous get pointer to json_value previous private subroutine json_get_previous (json, p, previous) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: previous pointer to previous Description Author Jacob Williams Date 10/31/2015 Returns a pointer to the previous of a json_value .\n  If there is no previous, then a null() pointer is returned. procedure, public :: get_tail => json_get_tail get pointer to json_value tail private subroutine json_get_tail (json, p, tail) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: tail pointer to tail Description Author Jacob Williams Date 10/31/2015 Returns a pointer to the tail of a json_value (the last child of an array of object).\n  If there is no tail, then a null() pointer is returned. procedure, public :: info => json_info get info about a json_value private subroutine json_info (json, p, var_type, n_children, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Description Author Jacob Williams Date 2/13/2014 Returns information about a json_value . procedure, public :: initialize => json_initialize to initialize some parsing parameters private subroutine json_initialize (json, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Description Author Jacob Williams Date 12/4/2013 Initialize the json_core instance. procedure, public :: traverse => json_traverse to traverse all elements of a JSON structure private subroutine json_traverse (json, p, traverse_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p procedure( json_traverse_callback_func ) :: traverse_callback Description Author Jacob Williams Date 4/28/2016 Traverse a JSON structure.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. procedure, public :: print_error_message => json_print_error_message simply routine to print error messages private subroutine json_print_error_message (json, io_unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer, intent(in), optional :: io_unit Description Author Jacob Williams Print any error message, and then clear the exceptions. procedure, public :: swap => json_value_swap Swap two json_value pointers\n in a structure (or two different structures). private subroutine json_value_swap (json, p1, p2) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p1 type( json_value ), , pointer :: p2 Description Author Jacob Williams Date 4/26/2016 Swap two elements in a JSON structure.\n  All of the children are carried along as well. procedure, public :: is_child_of => json_value_is_child_of Check if a json_value is a child of another. private function json_value_is_child_of (json, p1, p2) result(is_child_of) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p1 type( json_value ), , pointer :: p2 Return Value logical(kind=LK) Description Author Jacob Williams Date 4/28/2016 Returns True if p2 is a descendant of p1 (i.e, a child, or a child of child, etc.) procedure, public :: validate => json_value_validate Check that a json_value linked list is valid\n (i.e., is properly constructed). This may be\n useful if it has been constructed externally. private subroutine json_value_validate (json, p, is_valid, error_msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: is_valid True if the structure is valid. character(kind=CK,len=:), , allocatable :: error_msg if not valid, this will contain\n a description of the problem Description Author Jacob Williams Date 5/2/2016 Validate a json_value linked list by checking to make sure\n  all the pointers are properly associated, arrays and objects\n  have the correct number of children, and the correct data is\n  allocated for the variable types. procedure, private :: name_equal private function name_equal (json, p, name) result(is_equal) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in) :: p the json object character(kind=CK,len=*), intent(in) :: name the name to check for Return Value logical(kind=LK) true if the string are lexically equal Description Author Jacob Williams Date 4/30/2016 Returns true if name is equal to p%name , using the specified\n  settings for case sensitivity and trailing whitespace. procedure, private :: json_value_print private recursive subroutine json_value_print (json, p, iunit, str, indent, need_comma, colon, is_array_element) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit file unit to write to (6=console) character(kind=CK,len=:), intent(inout), allocatable :: str if iunit==unit2str (-1) then the structure is\n printed to this string rather than\n a file. This mode is used by json_value_to_string . integer(kind=IK), intent(in), optional :: indent indention level logical(kind=LK), intent(in), optional :: need_comma if it needs a comma after it logical(kind=LK), intent(in), optional :: colon if the colon was just written logical(kind=LK), intent(in), optional :: is_array_element if this is an array element Description Print the JSON structure to a string or a file. procedure, private :: string_to_integer private function string_to_integer (json, str) result(ival) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value integer(kind=IK) Description Convert a string into an integer. procedure, private :: string_to_double private function string_to_double (json, str) result(rval) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value real(kind=RK) Description Author Jacob Williams Date 1/19/2014 Convert a string into a double. procedure, private :: parse_value private recursive subroutine parse_value (json, unit, str, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number character(kind=CK,len=*), intent(in) :: str string containing JSON data (only used if unit=0) type( json_value ), , pointer :: value JSON data that is extracted Description Core parsing routine. procedure, private :: parse_number private subroutine parse_number (json, unit, str, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: value Description Author Jacob Williams Date 1/20/2014 Read a numerical value from the file (or string).\n  The routine will determine if it is an integer or a double, and\n  allocate the type accordingly. procedure, private :: parse_string private subroutine parse_string (json, unit, str, string) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=:), intent(out), allocatable :: string Description Parses a string while reading a JSON file. procedure, private :: parse_for_chars private subroutine parse_for_chars (json, unit, str, chars) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=*), intent(in) :: chars the string to check for. Description Core parsing routine. procedure, private :: parse_object private recursive subroutine parse_object (json, unit, str, parent) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: parent the parsed object will be added as a child of this Description Core parsing routine. procedure, private :: parse_array private recursive subroutine parse_array (json, unit, str, array) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: array Description Core parsing routine. procedure, private :: annotate_invalid_json private subroutine annotate_invalid_json (json, iunit, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=*), intent(in) :: str string with JSON data Description Generate a warning message if there was an error parsing a JSON file or string. procedure, private :: pop_char private recursive function pop_char (json, unit, str, eof, skip_ws) result(popped) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) â€“ only used if unit=0 logical(kind=LK), intent(out) :: eof true if the end of the file has been reached. logical(kind=LK), intent(in), optional :: skip_ws to ignore whitespace. Return Value character(kind=CK,len=1) the popped character. Description Get the next character from the file (or string). procedure, private :: push_char private subroutine push_char (json, c) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=1), intent(in) :: c Description Core routine. procedure, private :: get_current_line_from_file_stream private subroutine get_current_line_from_file_stream (json, iunit, line) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Description Author Jacob Williams Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the STREAM version (see also get_current_line_from_file_sequential ). procedure, private :: get_current_line_from_file_sequential private subroutine get_current_line_from_file_sequential (json, iunit, line) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Description Author Jacob Williams Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the SEQUENTIAL version (see also get_current_line_from_file_stream ). Source Code type , public :: json_core private integer ( IK ) :: spaces_per_tab = 2 !! number of spaces for indenting logical ( LK ) :: compact_real = . true . !! to use the \"compact\" form of real !! numbers for output character ( kind = CDK , len = :), allocatable :: real_fmt !! the format string to use !! for converting real numbers to strings. !! It can be set in [[json_initialize]], !! and used in [[json_value_print]] !! If not set, then `default_real_fmt` !! is used instead. logical ( LK ) :: is_verbose = . false . !! if true, all exceptions are !! immediately printed to console. logical ( LK ) :: exception_thrown = . false . !! The error flag. Will be set to true !! when an error is thrown in the class. !! Many of the methods will check this !! and return immediately if it is true. character ( kind = CK , len = :), allocatable :: err_message !! the error message integer ( IK ) :: char_count = 0 !! character position in the current line integer ( IK ) :: line_count = 1 !! lines read counter integer ( IK ) :: pushed_index = 0 !! used when parsing lines in file character ( kind = CK , len = pushed_char_size ) :: pushed_char = '' !! used when parsing !! lines in file integer ( IK ) :: ipos = 1 !! for allocatable strings: next character to read logical ( LK ) :: strict_type_checking = . false . !! if true, then no type conversions are done !! in the `get` routines if the actual variable !! type is different from the return type (for !! example, integer to double). logical ( LK ) :: trailing_spaces_significant = . false . !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ) :: case_sensitive_keys = . true . !! for name and path comparisons, are they !! case sensitive. contains private generic , public :: get_child => json_value_get_by_index , & json_value_get_child ,& MAYBEWRAP ( json_value_get_by_name_chars ) procedure , private :: json_value_get_by_index procedure , private :: MAYBEWRAP ( json_value_get_by_name_chars ) procedure , private :: json_value_get_child !> !  Add objects to a linked list of [[json_value]]s. generic , public :: add => json_value_add_member , & MAYBEWRAP ( json_value_add_integer ), & MAYBEWRAP ( json_value_add_integer_vec ), & MAYBEWRAP ( json_value_add_double ), & MAYBEWRAP ( json_value_add_double_vec ), & MAYBEWRAP ( json_value_add_logical ), & MAYBEWRAP ( json_value_add_logical_vec ), & MAYBEWRAP ( json_value_add_string ), & MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 generic , public :: add => json_value_add_string_name_ascii , & json_value_add_string_val_ascii , & json_value_add_string_vec_name_ascii , & json_value_add_string_vec_val_ascii #endif procedure , private :: json_value_add_member procedure , private :: MAYBEWRAP ( json_value_add_integer ) procedure , private :: MAYBEWRAP ( json_value_add_integer_vec ) procedure , private :: MAYBEWRAP ( json_value_add_double ) procedure , private :: MAYBEWRAP ( json_value_add_double_vec ) procedure , private :: MAYBEWRAP ( json_value_add_logical ) procedure , private :: MAYBEWRAP ( json_value_add_logical_vec ) procedure , private :: MAYBEWRAP ( json_value_add_string ) procedure , private :: MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 procedure , private :: json_value_add_string_name_ascii procedure , private :: json_value_add_string_val_ascii procedure , private :: json_value_add_string_vec_name_ascii procedure , private :: json_value_add_string_vec_val_ascii #endif !> !  These are like the `add` methods, except if a child with the !  same name is already present, then its value is simply updated. !  Note that currently, these only work for scalar variables. !  These routines can also change the variable's type (but an error will be !  thrown if the existing variable is not a scalar). ! !@note It should not be used to change the type of a variable in an array, !      or it may result in an invalid JSON file. generic , public :: update => MAYBEWRAP ( json_update_logical ),& MAYBEWRAP ( json_update_double ),& MAYBEWRAP ( json_update_integer ),& MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 generic , public :: update => json_update_string_name_ascii ,& json_update_string_val_ascii #endif procedure , private :: MAYBEWRAP ( json_update_logical ) procedure , private :: MAYBEWRAP ( json_update_double ) procedure , private :: MAYBEWRAP ( json_update_integer ) procedure , private :: MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 procedure , private :: json_update_string_name_ascii procedure , private :: json_update_string_val_ascii #endif !> !  Get data from a [[json_value]] linked list. ! !@note There are two versions (e.g. [[json_get_integer]] and [[json_get_integer_with_path]]). !      The first one gets the value from the [[json_value]] passed into the routine, !      while the second one gets the value from the [[json_value]] found by parsing the !      path.  The path version is split up into unicode and non-unicode versions. generic , public :: get => & MAYBEWRAP ( json_get_by_path ), & json_get_integer , MAYBEWRAP ( json_get_integer_with_path ), & json_get_integer_vec , MAYBEWRAP ( json_get_integer_vec_with_path ), & json_get_double , MAYBEWRAP ( json_get_double_with_path ), & json_get_double_vec , MAYBEWRAP ( json_get_double_vec_with_path ), & json_get_logical , MAYBEWRAP ( json_get_logical_with_path ), & json_get_logical_vec , MAYBEWRAP ( json_get_logical_vec_with_path ), & json_get_string , MAYBEWRAP ( json_get_string_with_path ), & json_get_string_vec , MAYBEWRAP ( json_get_string_vec_with_path ), & json_get_array , MAYBEWRAP ( json_get_array_with_path ) procedure , private :: json_get_integer procedure , private :: json_get_integer_vec procedure , private :: json_get_double procedure , private :: json_get_double_vec procedure , private :: json_get_logical procedure , private :: json_get_logical_vec procedure , private :: json_get_string procedure , private :: json_get_string_vec procedure , private :: json_get_array procedure , private :: MAYBEWRAP ( json_get_by_path ) procedure , private :: MAYBEWRAP ( json_get_integer_with_path ) procedure , private :: MAYBEWRAP ( json_get_integer_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_double_with_path ) procedure , private :: MAYBEWRAP ( json_get_double_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_logical_with_path ) procedure , private :: MAYBEWRAP ( json_get_logical_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_string_with_path ) procedure , private :: MAYBEWRAP ( json_get_string_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_array_with_path ) procedure , public :: print_to_string => json_value_to_string !! Print the [[json_value]] structure to an allocatable string !> !  Print the [[json_value]] to a file. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value) :: p !    !... !    call json%print(p,'test.json')  !this is [[json_print_2]] !```` generic , public :: print => json_print_1 , json_print_2 procedure :: json_print_1 procedure :: json_print_2 !> !  Destructor routine for a [[json_value]] pointer. !  This must be called explicitly if it is no longer needed, !  before it goes out of scope.  Otherwise, a memory leak will result. ! !# Example ! !  Destroy the [[json_value]] pointer before the variable goes out of scope: !````fortran !     subroutine example1() !     type(json_core) :: json !     type(json_value),pointer :: p !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%print(p) !     call json%destroy(p) !     end subroutine example1 !```` ! !  Note: it should NOT be called for a [[json_value]] pointer than has already been !  added to another [[json_value]] structure, since doing so may render the !  other structure invalid.  Consider the following example: !````fortran !     subroutine example2(p) !     type(json_core) :: json !     type(json_value),pointer,intent(out) :: p !     type(json_value),pointer :: q !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%create_object(q,'q') !     call json%add(q,'val',1) !     call json%add(p, q)  !add q to p structure !     ! do NOT call json%destroy(q) here, because q is !     ! now part of the output structure p.  p should be destroyed !     ! somewhere upstream by the caller of this routine. !     nullify(q) !OK, but not strictly necessary !     end subroutine example2 !```` generic , public :: destroy => json_value_destroy , destroy_json_core procedure :: json_value_destroy procedure :: destroy_json_core !> !  If the child variable is present, then remove it. generic , public :: remove_if_present => MAYBEWRAP ( json_value_remove_if_present ) procedure :: MAYBEWRAP ( json_value_remove_if_present ) !> !  Allocate a [[json_value]] pointer and make it a double variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_double(p,'value',1.0_RK) !```` generic , public :: create_double => MAYBEWRAP ( json_value_create_double ) procedure :: MAYBEWRAP ( json_value_create_double ) !> !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_array(p,'arrayname') !```` generic , public :: create_array => MAYBEWRAP ( json_value_create_array ) procedure :: MAYBEWRAP ( json_value_create_array ) !> !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_object(p,'objectname') !```` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. generic , public :: create_object => MAYBEWRAP ( json_value_create_object ) procedure :: MAYBEWRAP ( json_value_create_object ) !> !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_null(p,'value') !```` generic , public :: create_null => MAYBEWRAP ( json_value_create_null ) procedure :: MAYBEWRAP ( json_value_create_null ) !> !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_string(p,'value','foobar') !```` generic , public :: create_string => MAYBEWRAP ( json_value_create_string ) procedure :: MAYBEWRAP ( json_value_create_string ) !> !  Allocate a json_value pointer and make it an integer variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_integer(p,'value',42) !```` generic , public :: create_integer => MAYBEWRAP ( json_value_create_integer ) procedure :: MAYBEWRAP ( json_value_create_integer ) !> !  Allocate a json_value pointer and make it a logical variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_logical(p,'value',.true.) !```` generic , public :: create_logical => MAYBEWRAP ( json_value_create_logical ) procedure :: MAYBEWRAP ( json_value_create_logical ) !> !  Parse the JSON file and populate the [[json_value]] tree. generic , public :: parse => json_parse_file , MAYBEWRAP ( json_parse_string ) procedure :: json_parse_file procedure :: MAYBEWRAP ( json_parse_string ) !> !  Throw an exception. generic , public :: throw_exception => MAYBEWRAP ( json_throw_exception ) procedure :: MAYBEWRAP ( json_throw_exception ) !> !  Rename a [[json_value]] variable. generic , public :: rename => MAYBEWRAP ( json_value_rename ) procedure :: MAYBEWRAP ( json_value_rename ) procedure , public :: remove => json_value_remove !! Remove a [[json_value]] from a linked-list structure. procedure , public :: check_for_errors => json_check_for_errors !! check for error and get error message procedure , public :: clear_exceptions => json_clear_exceptions !! clear exceptions procedure , public :: count => json_count !! count the number of children procedure , public :: clone => json_clone !! clone a JSON structure (deep copy) procedure , public :: failed => json_failed !! check for error procedure , public :: get_parent => json_get_parent !! get pointer to json_value parent procedure , public :: get_next => json_get_next !! get pointer to json_value next procedure , public :: get_previous => json_get_previous !! get pointer to json_value previous procedure , public :: get_tail => json_get_tail !! get pointer to json_value tail procedure , public :: info => json_info !! get info about a json_value procedure , public :: initialize => json_initialize !! to initialize some parsing parameters procedure , public :: traverse => json_traverse !! to traverse all elements of a JSON structure procedure , public :: print_error_message => json_print_error_message !! simply routine to print error messages procedure , public :: swap => json_value_swap !! Swap two [[json_value]] pointers !! in a structure (or two different structures). procedure , public :: is_child_of => json_value_is_child_of !! Check if a [[json_value]] is a child of another. procedure , public :: validate => json_value_validate !! Check that a [[json_value]] linked list is valid !! (i.e., is properly constructed). This may be !! useful if it has been constructed externally. !other private routines: procedure :: name_equal procedure :: json_value_print procedure :: string_to_integer procedure :: string_to_double procedure :: parse_value procedure :: parse_number procedure :: parse_string procedure :: parse_for_chars procedure :: parse_object procedure :: parse_array procedure :: annotate_invalid_json procedure :: pop_char procedure :: push_char procedure :: get_current_line_from_file_stream procedure :: get_current_line_from_file_sequential end type json_core","tags":"","loc":"type/json_core.html","title":"json_core â€“ JSON-Fortran "},{"text":"abstract interface public subroutine json_array_callback_func(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description Array element callback function.  Used by json_get_array","tags":"","loc":"interface/json_array_callback_func.html","title":"json_array_callback_func â€“ JSON-Fortran"},{"text":"abstract interface public subroutine json_traverse_callback_func(json, p, finished) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: finished set true to stop traversing Description Callback function used by json_traverse","tags":"","loc":"interface/json_traverse_callback_func.html","title":"json_traverse_callback_func â€“ JSON-Fortran"},{"text":"private pure function json_file_failed(me) result(failed) Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me Return Value logical(kind=LK) will be true if there has been an error. Description Check error status in the file. Source Code pure function json_file_failed ( me ) result ( failed ) implicit none class ( json_file ), intent ( in ) :: me logical ( LK ) :: failed !! will be true if there has been an error. failed = me % core % failed () end function json_file_failed","tags":"","loc":"proc/json_file_failed.html","title":"json_file_failed â€“ JSON-Fortran"},{"text":"private function initialize_json_file(p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_file ) Description Cast a json_value object as a json_file object.\n  It also calls the initialize() method. Note initialize_json_core , json_initialize , initialize_json_core_in_file , and initialize_json_file all have a similar interface. Called By proc~~initialize_json_file~~CalledByGraph proc~initialize_json_file initialize_json_file interface~json_file json_file interface~json_file->proc~initialize_json_file Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function initialize_json_file ( p , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , optional , intent ( in ) :: p !! `json_value` object to cast !! as a `json_file` object logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call file_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) if ( present ( p )) file_object % p => p end function initialize_json_file","tags":"","loc":"proc/initialize_json_file.html","title":"initialize_json_file â€“ JSON-Fortran"},{"text":"private function initialize_json_file_v2(json_value_object, json_core_object) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Description Cast a json_value pointer and a json_core object\n  as a json_file object. Called By proc~~initialize_json_file_v2~~CalledByGraph proc~initialize_json_file_v2 initialize_json_file_v2 interface~json_file json_file interface~json_file->proc~initialize_json_file_v2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function initialize_json_file_v2 ( json_value_object , json_core_object ) & result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , intent ( in ) :: json_value_object type ( json_core ), intent ( in ) :: json_core_object file_object % p => json_value_object file_object % core = json_core_object end function initialize_json_file_v2","tags":"","loc":"proc/initialize_json_file_v2.html","title":"initialize_json_file_v2 â€“ JSON-Fortran"},{"text":"private subroutine json_file_check_for_errors(me, status_ok, error_msg) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Description Retrieve error status and message from the class. Source Code subroutine json_file_check_for_errors ( me , status_ok , error_msg ) implicit none class ( json_file ), intent ( inout ) :: me logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) call me % core % check_for_errors ( status_ok , error_msg ) end subroutine json_file_check_for_errors","tags":"","loc":"proc/json_file_check_for_errors.html","title":"json_file_check_for_errors â€“ JSON-Fortran"},{"text":"private pure subroutine json_file_clear_exceptions(me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Clear exceptions in the class. Source Code pure subroutine json_file_clear_exceptions ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % core % clear_exceptions () end subroutine json_file_clear_exceptions","tags":"","loc":"proc/json_file_clear_exceptions.html","title":"json_file_clear_exceptions â€“ JSON-Fortran"},{"text":"private subroutine json_file_print_error_message(me, io_unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer, intent(in), optional :: io_unit Description This is a wrapper for json_print_error_message . Source Code subroutine json_file_print_error_message ( me , io_unit ) implicit none class ( json_file ), intent ( inout ) :: me integer , intent ( in ), optional :: io_unit call me % core % print_error_message ( io_unit ) end subroutine json_file_print_error_message","tags":"","loc":"proc/json_file_print_error_message.html","title":"json_file_print_error_message â€“ JSON-Fortran"},{"text":"private subroutine initialize_json_core_in_file(me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Description Initialize the json_core for this json_file .\n  This is just a wrapper for json_initialize . Note : This does not destroy the data in the file. Note initialize_json_core , json_initialize , initialize_json_core_in_file , and initialize_json_file all have a similar interface. Source Code subroutine initialize_json_core_in_file ( me , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) implicit none class ( json_file ), intent ( inout ) :: me logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call me % core % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) end subroutine initialize_json_core_in_file","tags":"","loc":"proc/initialize_json_core_in_file.html","title":"initialize_json_core_in_file â€“ JSON-Fortran"},{"text":"private subroutine set_json_core_in_file(me, core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_core ), intent(in) :: core Description Set the json_core for this json_file . Note : This does not destroy the data in the file. Note : This one is used if you want to initialize the file with\n       an already-existing json_core (presumably, this was already\n       initialized by a call to initialize_json_core or similar). Source Code subroutine set_json_core_in_file ( me , core ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_core ), intent ( in ) :: core me % core = core end subroutine set_json_core_in_file","tags":"","loc":"proc/set_json_core_in_file.html","title":"set_json_core_in_file â€“ JSON-Fortran"},{"text":"private subroutine get_json_core_in_file(me, core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me type( json_core ), intent(out) :: core Description Get a copy of the json_core in this json_file . Source Code subroutine get_json_core_in_file ( me , core ) implicit none class ( json_file ), intent ( in ) :: me type ( json_core ), intent ( out ) :: core core = me % core end subroutine get_json_core_in_file","tags":"","loc":"proc/get_json_core_in_file.html","title":"get_json_core_in_file â€“ JSON-Fortran"},{"text":"private subroutine json_file_destroy(me, destroy_core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical, intent(in), optional :: destroy_core to also destroy the json_core .\n default is to leave it as is. Description Destroy the json_value data in a json_file .\n  This must be done when the variable is no longer needed,\n  or will be reused to open a different file.\n  Otherwise a memory leak will occur. Optionally, also destroy the json_core instance (this\n  is not necessary to prevent memory leaks, since a json_core does not use pointers). History 12/9/2013 : Created 4/26/2016 : Added optional destroy_core argument Source Code subroutine json_file_destroy ( me , destroy_core ) implicit none class ( json_file ), intent ( inout ) :: me logical , intent ( in ), optional :: destroy_core !! to also destroy the [[json_core]]. !! default is to leave it as is. if ( associated ( me % p )) call me % core % destroy ( me % p ) if ( present ( destroy_core )) then if ( destroy_core ) call me % core % destroy () end if end subroutine json_file_destroy","tags":"","loc":"proc/json_file_destroy.html","title":"json_file_destroy â€“ JSON-Fortran"},{"text":"private subroutine json_file_move_pointer(to, from) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from Description Move the json_value pointer from one json_file to another.\n  The \"from\" pointer is then nullified, but not destroyed. Note If \"from%p\" is not associated, then an error is thrown. Source Code subroutine json_file_move_pointer ( to , from ) implicit none class ( json_file ), intent ( inout ) :: to class ( json_file ), intent ( inout ) :: from if ( associated ( from % p )) then if ( from % failed ()) then !Don't get the data if the FROM file has an !active exception, since it may not be valid. call to % core % throw_exception ( 'Error in json_file_move_pointer: ' // & 'error exception in FROM file.' ) else call to % initialize () !initialize and clear any exceptions that may be present to % p => from % p nullify ( from % p ) end if else call to % core % throw_exception ( 'Error in json_file_move_pointer: ' // & 'pointer is not associated.' ) end if end subroutine json_file_move_pointer","tags":"","loc":"proc/json_file_move_pointer.html","title":"json_file_move_pointer â€“ JSON-Fortran"},{"text":"private subroutine json_file_load(me, filename, unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use (if not present, a newunit is used) Description Load the JSON data from a file. Example program main use json_module implicit none type ( json_file ) :: f call f % load_file ( 'my_file.json' ) !... call f % destroy () end program main Source Code subroutine json_file_load ( me , filename , unit ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to open integer ( IK ), intent ( in ), optional :: unit !! the unit number to use (if not present, a newunit is used) call me % core % parse ( file = filename , p = me % p , unit = unit ) end subroutine json_file_load","tags":"","loc":"proc/json_file_load.html","title":"json_file_load â€“ JSON-Fortran"},{"text":"private subroutine json_file_load_from_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from Description Load the JSON data from a string. Example Load JSON from a string: type ( json_file ) :: f call f % load_from_string ( '{ \"name\": \"Leonidas\" }' ) Source Code subroutine json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: str !! string to load JSON data from call me % core % parse ( str = str , p = me % p ) end subroutine json_file_load_from_string","tags":"","loc":"proc/json_file_load_from_string.html","title":"json_file_load_from_string â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_load_from_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: str Description Alternate version of json_file_load_from_string , where \"str\" is kind=CDK. Calls proc~~wrap_json_file_load_from_string~~CallsGraph proc~wrap_json_file_load_from_string wrap_json_file_load_from_string interface~to_unicode to_unicode proc~wrap_json_file_load_from_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: str call me % load_from_string ( to_unicode ( str )) end subroutine wrap_json_file_load_from_string","tags":"","loc":"proc/wrap_json_file_load_from_string.html","title":"wrap_json_file_load_from_string â€“ JSON-Fortran"},{"text":"private subroutine json_file_print_to_console(me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Print the JSON file to the console. Source Code subroutine json_file_print_to_console ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % core % print ( me % p , iunit = output_unit ) end subroutine json_file_print_to_console","tags":"","loc":"proc/json_file_print_to_console.html","title":"json_file_print_to_console â€“ JSON-Fortran"},{"text":"private subroutine json_file_print_1(me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) Description Prints the JSON file to the specified file unit number. Source Code subroutine json_file_print_1 ( me , iunit ) implicit none class ( json_file ), intent ( inout ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit number (must not be -1) if ( iunit /= unit2str ) then call me % core % print ( me % p , iunit = iunit ) else call me % core % throw_exception ( 'Error in json_file_print_1: iunit must not be -1.' ) end if end subroutine json_file_print_1","tags":"","loc":"proc/json_file_print_1.html","title":"json_file_print_1 â€“ JSON-Fortran"},{"text":"private subroutine json_file_print_2(me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to Description Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. Example Example loading a JSON file, changing a value, and then printing\n  result to a new file: type ( json_file ) :: f logical :: found call f % load_file ( 'my_file.json' ) !open the original file call f % update ( 'version' , 4 , found ) !change the value of a variable call f % print_file ( 'my_file_2.json' ) !save file as new name Source Code subroutine json_file_print_2 ( me , filename ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! filename to print to call me % core % print ( me % p , filename ) end subroutine json_file_print_2","tags":"","loc":"proc/json_file_print_2.html","title":"json_file_print_2 â€“ JSON-Fortran"},{"text":"private subroutine json_file_print_to_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to Description Print the JSON file to a string. Example Open a JSON file, and then print the contents to a string: type ( json_file ) :: f character ( kind = CK , len = :), allocatable :: str call f % load_file ( 'my_file.json' ) call f % print_file ( str ) Source Code subroutine json_file_print_to_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: str !! string to print JSON data to call me % core % print_to_string ( me % p , str ) end subroutine json_file_print_to_string","tags":"","loc":"proc/json_file_print_to_string.html","title":"json_file_print_to_string â€“ JSON-Fortran"},{"text":"private subroutine json_file_variable_info(me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children Description Returns information about a variable in a json_file . Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: found !! the variable exists in the structure integer ( IK ), intent ( out ) :: var_type !! variable type integer ( IK ), intent ( out ) :: n_children !! number of children type ( json_value ), pointer :: p !initialize: nullify ( p ) !get a pointer to the variable (if it is there): call me % get ( path , p , found ) if ( found ) then !get info: call me % core % info ( p , var_type , n_children ) else !set to dummy values: var_type = json_unknown n_children = 0 end if !cleanup: nullify ( p ) end subroutine json_file_variable_info","tags":"","loc":"proc/json_file_variable_info.html","title":"json_file_variable_info â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_variable_info(me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: found integer(kind=IK), intent(out) :: var_type integer(kind=IK), intent(out) :: n_children Description Alternate version of json_file_variable_info , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_variable_info~~CallsGraph proc~wrap_json_file_variable_info wrap_json_file_variable_info interface~to_unicode to_unicode proc~wrap_json_file_variable_info->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: found integer ( IK ), intent ( out ) :: var_type integer ( IK ), intent ( out ) :: n_children call me % info ( to_unicode ( path ), found , var_type , n_children ) end subroutine wrap_json_file_variable_info","tags":"","loc":"proc/wrap_json_file_variable_info.html","title":"wrap_json_file_variable_info â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_root(me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable Description Get a json_value pointer to the JSON file root. Note This is equivalent to calling json_file %get('$',p) Source Code subroutine json_file_get_root ( me , p ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable p => me % p end subroutine json_file_get_root","tags":"","loc":"proc/json_file_get_root.html","title":"json_file_get_root â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_object(me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Description Get a json_value pointer to an object from a JSON file. Source Code subroutine json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , p = p , found = found ) end subroutine json_file_get_object","tags":"","loc":"proc/json_file_get_object.html","title":"json_file_get_object â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_object(me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_object , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_object~~CallsGraph proc~wrap_json_file_get_object wrap_json_file_get_object interface~to_unicode to_unicode proc~wrap_json_file_get_object->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), p , found ) end subroutine wrap_json_file_get_object","tags":"","loc":"proc/wrap_json_file_get_object.html","title":"wrap_json_file_get_object â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_integer(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Description Get an integer value from a JSON file. Source Code subroutine json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_integer","tags":"","loc":"proc/json_file_get_integer.html","title":"json_file_get_integer â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_integer(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_integer~~CallsGraph proc~wrap_json_file_get_integer wrap_json_file_get_integer interface~to_unicode to_unicode proc~wrap_json_file_get_integer->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_integer","tags":"","loc":"proc/wrap_json_file_get_integer.html","title":"wrap_json_file_get_integer â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_integer_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Description Get an integer vector from a JSON file. Source Code subroutine json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_integer_vec","tags":"","loc":"proc/json_file_get_integer_vec.html","title":"json_file_get_integer_vec â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_integer_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer_vec , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_integer_vec~~CallsGraph proc~wrap_json_file_get_integer_vec wrap_json_file_get_integer_vec interface~to_unicode to_unicode proc~wrap_json_file_get_integer_vec->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_integer_vec","tags":"","loc":"proc/wrap_json_file_get_integer_vec.html","title":"wrap_json_file_get_integer_vec â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_double(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Get a real(RK) variable value from a JSON file. Source Code subroutine json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_double","tags":"","loc":"proc/json_file_get_double.html","title":"json_file_get_double â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_double(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_double~~CallsGraph proc~wrap_json_file_get_double wrap_json_file_get_double interface~to_unicode to_unicode proc~wrap_json_file_get_double->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_double","tags":"","loc":"proc/wrap_json_file_get_double.html","title":"wrap_json_file_get_double â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_double_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a real(RK) vector from a JSON file. Source Code subroutine json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_double_vec","tags":"","loc":"proc/json_file_get_double_vec.html","title":"json_file_get_double_vec â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_double_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double_vec , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_double_vec~~CallsGraph proc~wrap_json_file_get_double_vec wrap_json_file_get_double_vec interface~to_unicode to_unicode proc~wrap_json_file_get_double_vec->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_double_vec","tags":"","loc":"proc/wrap_json_file_get_double_vec.html","title":"wrap_json_file_get_double_vec â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_logical(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Get a logical(LK) value from a JSON file. Source Code subroutine json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_logical","tags":"","loc":"proc/json_file_get_logical.html","title":"json_file_get_logical â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_logical(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_logical~~CallsGraph proc~wrap_json_file_get_logical wrap_json_file_get_logical interface~to_unicode to_unicode proc~wrap_json_file_get_logical->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_logical","tags":"","loc":"proc/wrap_json_file_get_logical.html","title":"wrap_json_file_get_logical â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_logical_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical(LK) vector from a JSON file. Source Code subroutine json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_logical_vec","tags":"","loc":"proc/json_file_get_logical_vec.html","title":"json_file_get_logical_vec â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_logical_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical_vec , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_logical_vec~~CallsGraph proc~wrap_json_file_get_logical_vec wrap_json_file_get_logical_vec interface~to_unicode to_unicode proc~wrap_json_file_get_logical_vec->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_logical_vec","tags":"","loc":"proc/wrap_json_file_get_logical_vec.html","title":"wrap_json_file_get_logical_vec â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_string(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Get a character string from a json file.\n  The output val is an allocatable character string. Source Code subroutine json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_string","tags":"","loc":"proc/json_file_get_string.html","title":"json_file_get_string â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_string(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_string~~CallsGraph proc~wrap_json_file_get_string wrap_json_file_get_string interface~to_unicode to_unicode proc~wrap_json_file_get_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_string","tags":"","loc":"proc/wrap_json_file_get_string.html","title":"wrap_json_file_get_string â€“ JSON-Fortran"},{"text":"private subroutine json_file_get_string_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a JSON file. Source Code subroutine json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_string_vec","tags":"","loc":"proc/json_file_get_string_vec.html","title":"json_file_get_string_vec â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_get_string_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string_vec , where \"path\" is kind=CDK. Calls proc~~wrap_json_file_get_string_vec~~CallsGraph proc~wrap_json_file_get_string_vec wrap_json_file_get_string_vec interface~to_unicode to_unicode proc~wrap_json_file_get_string_vec->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_string_vec","tags":"","loc":"proc/wrap_json_file_get_string_vec.html","title":"wrap_json_file_get_string_vec â€“ JSON-Fortran"},{"text":"private subroutine json_file_update_integer(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_integer Source Code subroutine json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , name , val , found ) end subroutine json_file_update_integer","tags":"","loc":"proc/json_file_update_integer.html","title":"json_file_update_integer â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_update_integer(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_integer , where \"name\" is kind=CDK. Calls proc~~wrap_json_file_update_integer~~CallsGraph proc~wrap_json_file_update_integer wrap_json_file_update_integer interface~to_unicode to_unicode proc~wrap_json_file_update_integer->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_integer","tags":"","loc":"proc/wrap_json_file_update_integer.html","title":"wrap_json_file_update_integer â€“ JSON-Fortran"},{"text":"private subroutine json_file_update_logical(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_logical Source Code subroutine json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , name , val , found ) end subroutine json_file_update_logical","tags":"","loc":"proc/json_file_update_logical.html","title":"json_file_update_logical â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_update_logical(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_logical , where \"name\" is kind=CDK. Calls proc~~wrap_json_file_update_logical~~CallsGraph proc~wrap_json_file_update_logical wrap_json_file_update_logical interface~to_unicode to_unicode proc~wrap_json_file_update_logical->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_logical","tags":"","loc":"proc/wrap_json_file_update_logical.html","title":"wrap_json_file_update_logical â€“ JSON-Fortran"},{"text":"private subroutine json_file_update_real(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_double Source Code subroutine json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , name , val , found ) end subroutine json_file_update_real","tags":"","loc":"proc/json_file_update_real.html","title":"json_file_update_real â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_update_real(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_real , where \"name\" is kind=CDK. Calls proc~~wrap_json_file_update_real~~CallsGraph proc~wrap_json_file_update_real wrap_json_file_update_real interface~to_unicode to_unicode proc~wrap_json_file_update_real->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_real","tags":"","loc":"proc/wrap_json_file_update_real.html","title":"wrap_json_file_update_real â€“ JSON-Fortran"},{"text":"private subroutine json_file_update_string(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_string Source Code subroutine json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , name , val , found ) end subroutine json_file_update_string","tags":"","loc":"proc/json_file_update_string.html","title":"json_file_update_string â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_file_update_string(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" and \"val\" are kind=CDK. Calls proc~~wrap_json_file_update_string~~CallsGraph proc~wrap_json_file_update_string wrap_json_file_update_string interface~to_unicode to_unicode proc~wrap_json_file_update_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_file_update_string","tags":"","loc":"proc/wrap_json_file_update_string.html","title":"wrap_json_file_update_string â€“ JSON-Fortran"},{"text":"private subroutine json_file_update_string_name_ascii(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" is kind=CDK. Calls proc~~json_file_update_string_name_ascii~~CallsGraph proc~json_file_update_string_name_ascii json_file_update_string_name_ascii interface~to_unicode to_unicode proc~json_file_update_string_name_ascii->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_file_update_string_name_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine json_file_update_string_name_ascii","tags":"","loc":"proc/json_file_update_string_name_ascii.html","title":"json_file_update_string_name_ascii â€“ JSON-Fortran"},{"text":"private subroutine json_file_update_string_val_ascii(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"val\" is kind=CDK. Calls proc~~json_file_update_string_val_ascii~~CallsGraph proc~json_file_update_string_val_ascii json_file_update_string_val_ascii interface~to_unicode to_unicode proc~json_file_update_string_val_ascii->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_file_update_string_val_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( name , to_unicode ( val ), found ) end subroutine json_file_update_string_val_ascii","tags":"","loc":"proc/json_file_update_string_val_ascii.html","title":"json_file_update_string_val_ascii â€“ JSON-Fortran"},{"text":"private subroutine json_file_traverse(me, traverse_callback) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure( json_traverse_callback_func ) :: traverse_callback Description Traverse the JSON structure in the file.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. Source Code subroutine json_file_traverse ( me , traverse_callback ) implicit none class ( json_file ), intent ( inout ) :: me procedure ( json_traverse_callback_func ) :: traverse_callback call me % core % traverse ( me % p , traverse_callback ) end subroutine json_file_traverse","tags":"","loc":"proc/json_file_traverse.html","title":"json_file_traverse â€“ JSON-Fortran"},{"text":"public interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object, and either the json_core settings or a json_core instance. Example ... type ( json_file ) :: my_file type ( json_value ), pointer :: json_object type ( json_core ) :: json_core_object ... ! Construct a json_object: !could do this: my_file = json_file ( json_object ) !or: my_file = json_file ( json_object , verbose = . true .) !or: my_file = json_file ( json_object , json_core_object ) Calls interface~~json_file~~CallsGraph interface~json_file json_file proc~initialize_json_file_v2 initialize_json_file_v2 interface~json_file->proc~initialize_json_file_v2 proc~initialize_json_file initialize_json_file interface~json_file->proc~initialize_json_file Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_file ) Description Author Izaak Beekman Date 07/23/2015 Cast a json_value object as a json_file object.\n  It also calls the initialize() method. private function initialize_json_file_v2 (json_value_object, json_core_object) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Description Author Jacob Williams Date 4/26/2016 Cast a json_value pointer and a json_core object\n  as a json_file object.","tags":"","loc":"interface/json_file.html","title":"json_file â€“ JSON-Fortran"},{"text":"public pure function valid_json_hex(str) result(valid) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to check. Return Value logical(kind=LK) is str a value 4-digit hex string Description Returns true if the string is a valid 4-digit hex string. Examples valid_json_hex ( '0000' ) !returns true valid_json_hex ( 'ABC4' ) !returns true valid_json_hex ( 'AB' ) !returns false (< 4 characters) valid_json_hex ( 'WXYZ' ) !returns false (invalid characters) Called By proc~~valid_json_hex~~CalledByGraph proc~valid_json_hex valid_json_hex proc~parse_string parse_string proc~parse_string->proc~valid_json_hex Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: n length of str integer(kind=IK), public :: i counter character(kind=CK,len=1), public, parameter, dimension(22) :: valid_chars = [(achar(i), i=48, 57), (achar(i), i=65, 70), (achar(i), i=97, 102)] an array of the valid hex characters Source Code pure function valid_json_hex ( str ) result ( valid ) implicit none logical ( LK ) :: valid !! is str a value 4-digit hex string character ( kind = CK , len =* ), intent ( in ) :: str !! the string to check. integer ( IK ) :: n !! length of `str` integer ( IK ) :: i !! counter !> an array of the valid hex characters character ( kind = CK , len = 1 ), dimension ( 22 ), parameter :: valid_chars = & [ ( achar ( i ), i = 48 , 57 ), & ! decimal digits ( achar ( i ), i = 65 , 70 ), & ! capital A-F ( achar ( i ), i = 97 , 102 ) ] ! lowercase a-f !initialize valid = . false . !check all the characters in the string: n = len ( str ) if ( n == 4 ) then do i = 1 , n if (. not . any ( str ( i : i ) == valid_chars )) return end do valid = . true . !all are in the set, so it is OK end if end function valid_json_hex","tags":"","loc":"proc/valid_json_hex.html","title":"valid_json_hex â€“ JSON-Fortran"},{"text":"private pure function to_uni(str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) Description Convert string to unicode (CDK to CK). Called By proc~~to_uni~~CalledByGraph proc~to_uni to_uni interface~to_unicode to_unicode interface~to_unicode->proc~to_uni proc~wrap_json_get_double_with_path wrap_json_get_double_with_path proc~wrap_json_get_double_with_path->interface~to_unicode proc~wrap_json_value_create_array wrap_json_value_create_array proc~wrap_json_value_create_array->interface~to_unicode proc~wrap_json_file_get_double wrap_json_file_get_double proc~wrap_json_file_get_double->interface~to_unicode proc~json_value_add_string_name_ascii json_value_add_string_name_ascii proc~json_value_add_string_name_ascii->interface~to_unicode proc~ucs4_join_default ucs4_join_default proc~ucs4_join_default->interface~to_unicode proc~wrap_json_value_remove_if_present wrap_json_value_remove_if_present proc~wrap_json_value_remove_if_present->interface~to_unicode proc~wrap_json_file_get_double_vec wrap_json_file_get_double_vec proc~wrap_json_file_get_double_vec->interface~to_unicode proc~wrap_json_value_create_string wrap_json_value_create_string proc~wrap_json_value_create_string->interface~to_unicode proc~wrap_json_throw_exception wrap_json_throw_exception proc~wrap_json_throw_exception->interface~to_unicode proc~default_join_ucs4 default_join_ucs4 proc~default_join_ucs4->interface~to_unicode proc~wrap_json_get_array_with_path wrap_json_get_array_with_path proc~wrap_json_get_array_with_path->interface~to_unicode proc~wrap_json_value_add_integer_vec wrap_json_value_add_integer_vec proc~wrap_json_value_add_integer_vec->interface~to_unicode proc~wrap_json_value_add_logical_vec wrap_json_value_add_logical_vec proc~wrap_json_value_add_logical_vec->interface~to_unicode proc~wrap_json_value_create_logical wrap_json_value_create_logical proc~wrap_json_value_create_logical->interface~to_unicode proc~ucs4_comp_default ucs4_comp_default proc~ucs4_comp_default->interface~to_unicode proc~json_value_add_string_vec_name_ascii json_value_add_string_vec_name_ascii proc~json_value_add_string_vec_name_ascii->interface~to_unicode proc~wrap_json_file_get_logical wrap_json_file_get_logical proc~wrap_json_file_get_logical->interface~to_unicode proc~json_value_add_string_val_ascii json_value_add_string_val_ascii proc~json_value_add_string_val_ascii->interface~to_unicode proc~default_comp_ucs4 default_comp_ucs4 proc~default_comp_ucs4->interface~to_unicode proc~wrap_json_value_add_string_vec wrap_json_value_add_string_vec proc~wrap_json_value_add_string_vec->interface~to_unicode proc~wrap_json_file_get_logical_vec wrap_json_file_get_logical_vec proc~wrap_json_file_get_logical_vec->interface~to_unicode proc~wrap_json_value_create_null wrap_json_value_create_null proc~wrap_json_value_create_null->interface~to_unicode proc~wrap_json_get_integer_vec_with_path wrap_json_get_integer_vec_with_path proc~wrap_json_get_integer_vec_with_path->interface~to_unicode proc~ucs4_neq_default ucs4_neq_default proc~ucs4_neq_default->interface~to_unicode proc~wrap_json_value_create_double wrap_json_value_create_double proc~wrap_json_value_create_double->interface~to_unicode proc~wrap_json_file_variable_info wrap_json_file_variable_info proc~wrap_json_file_variable_info->interface~to_unicode proc~wrap_json_get_integer_with_path wrap_json_get_integer_with_path proc~wrap_json_get_integer_with_path->interface~to_unicode proc~default_neq_ucs4 default_neq_ucs4 proc~default_neq_ucs4->interface~to_unicode proc~wrap_json_value_get_by_name_chars wrap_json_value_get_by_name_chars proc~wrap_json_value_get_by_name_chars->interface~to_unicode proc~wrap_json_file_get_string wrap_json_file_get_string proc~wrap_json_file_get_string->interface~to_unicode proc~wrap_json_update_logical wrap_json_update_logical proc~wrap_json_update_logical->interface~to_unicode proc~wrap_json_update_integer wrap_json_update_integer proc~wrap_json_update_integer->interface~to_unicode proc~wrap_json_get_string_vec_with_path wrap_json_get_string_vec_with_path proc~wrap_json_get_string_vec_with_path->interface~to_unicode proc~wrap_json_file_get_string_vec wrap_json_file_get_string_vec proc~wrap_json_file_get_string_vec->interface~to_unicode proc~wrap_json_value_add_double wrap_json_value_add_double proc~wrap_json_value_add_double->interface~to_unicode proc~wrap_json_get_double_vec_with_path wrap_json_get_double_vec_with_path proc~wrap_json_get_double_vec_with_path->interface~to_unicode proc~wrap_json_file_get_integer wrap_json_file_get_integer proc~wrap_json_file_get_integer->interface~to_unicode proc~wrap_json_file_update_integer wrap_json_file_update_integer proc~wrap_json_file_update_integer->interface~to_unicode proc~wrap_json_update_double wrap_json_update_double proc~wrap_json_update_double->interface~to_unicode proc~wrap_json_get_by_path wrap_json_get_by_path proc~wrap_json_get_by_path->interface~to_unicode proc~wrap_json_file_update_logical wrap_json_file_update_logical proc~wrap_json_file_update_logical->interface~to_unicode proc~wrap_json_value_add_integer wrap_json_value_add_integer proc~wrap_json_value_add_integer->interface~to_unicode proc~wrap_json_update_string wrap_json_update_string proc~wrap_json_update_string->interface~to_unicode proc~wrap_json_value_create_integer wrap_json_value_create_integer proc~wrap_json_value_create_integer->interface~to_unicode proc~wrap_json_value_create_object wrap_json_value_create_object proc~wrap_json_value_create_object->interface~to_unicode proc~json_update_string_name_ascii json_update_string_name_ascii proc~json_update_string_name_ascii->interface~to_unicode proc~wrap_json_parse_string wrap_json_parse_string proc~wrap_json_parse_string->interface~to_unicode proc~json_update_string_val_ascii json_update_string_val_ascii proc~json_update_string_val_ascii->interface~to_unicode proc~wrap_json_get_string_with_path wrap_json_get_string_with_path proc~wrap_json_get_string_with_path->interface~to_unicode proc~wrap_json_get_logical_with_path wrap_json_get_logical_with_path proc~wrap_json_get_logical_with_path->interface~to_unicode proc~wrap_json_file_update_real wrap_json_file_update_real proc~wrap_json_file_update_real->interface~to_unicode proc~wrap_json_file_update_string wrap_json_file_update_string proc~wrap_json_file_update_string->interface~to_unicode proc~wrap_json_file_get_integer_vec wrap_json_file_get_integer_vec proc~wrap_json_file_get_integer_vec->interface~to_unicode proc~wrap_json_file_get_object wrap_json_file_get_object proc~wrap_json_file_get_object->interface~to_unicode proc~wrap_json_value_rename wrap_json_value_rename proc~wrap_json_value_rename->interface~to_unicode proc~json_file_update_string_name_ascii json_file_update_string_name_ascii proc~json_file_update_string_name_ascii->interface~to_unicode proc~json_file_update_string_val_ascii json_file_update_string_val_ascii proc~json_file_update_string_val_ascii->interface~to_unicode proc~wrap_json_value_add_string wrap_json_value_add_string proc~wrap_json_value_add_string->interface~to_unicode proc~wrap_json_value_add_logical wrap_json_value_add_logical proc~wrap_json_value_add_logical->interface~to_unicode proc~wrap_json_file_load_from_string wrap_json_file_load_from_string proc~wrap_json_file_load_from_string->interface~to_unicode proc~unescape_string unescape_string proc~unescape_string->interface~to_unicode proc~wrap_json_get_logical_vec_with_path wrap_json_get_logical_vec_with_path proc~wrap_json_get_logical_vec_with_path->interface~to_unicode proc~wrap_json_value_add_double_vec wrap_json_value_add_double_vec proc~wrap_json_value_add_double_vec->interface~to_unicode proc~json_value_add_string_vec_val_ascii json_value_add_string_vec_val_ascii proc~json_value_add_string_vec_val_ascii->interface~to_unicode interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~ucs4_join_default interface~operator(SLASHSLASH)->proc~default_join_ucs4 interface~operator(==) operator(==) interface~operator(==)->proc~ucs4_comp_default interface~operator(==)->proc~default_comp_ucs4 interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~ucs4_neq_default interface~operator(SLASH=)->proc~default_neq_ucs4 proc~json_get_string json_get_string proc~json_get_string->proc~unescape_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function to_uni ( str ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: str character ( kind = CK , len = len ( str )) :: to_uni to_uni = str end function to_uni","tags":"","loc":"proc/to_uni.html","title":"to_uni â€“ JSON-Fortran"},{"text":"private pure function to_uni_vec(str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Description Convert array of strings to unicode (CDK to CK). Note JW: may be able to remove this by making to_uni PURE ELEMENTAL ? Called By proc~~to_uni_vec~~CalledByGraph proc~to_uni_vec to_uni_vec interface~to_unicode to_unicode interface~to_unicode->proc~to_uni_vec proc~wrap_json_get_double_with_path wrap_json_get_double_with_path proc~wrap_json_get_double_with_path->interface~to_unicode proc~wrap_json_value_create_array wrap_json_value_create_array proc~wrap_json_value_create_array->interface~to_unicode proc~wrap_json_file_get_double wrap_json_file_get_double proc~wrap_json_file_get_double->interface~to_unicode proc~json_value_add_string_name_ascii json_value_add_string_name_ascii proc~json_value_add_string_name_ascii->interface~to_unicode proc~ucs4_join_default ucs4_join_default proc~ucs4_join_default->interface~to_unicode proc~wrap_json_value_remove_if_present wrap_json_value_remove_if_present proc~wrap_json_value_remove_if_present->interface~to_unicode proc~wrap_json_file_get_double_vec wrap_json_file_get_double_vec proc~wrap_json_file_get_double_vec->interface~to_unicode proc~wrap_json_value_create_string wrap_json_value_create_string proc~wrap_json_value_create_string->interface~to_unicode proc~wrap_json_throw_exception wrap_json_throw_exception proc~wrap_json_throw_exception->interface~to_unicode proc~default_join_ucs4 default_join_ucs4 proc~default_join_ucs4->interface~to_unicode proc~wrap_json_get_array_with_path wrap_json_get_array_with_path proc~wrap_json_get_array_with_path->interface~to_unicode proc~wrap_json_value_add_integer_vec wrap_json_value_add_integer_vec proc~wrap_json_value_add_integer_vec->interface~to_unicode proc~wrap_json_value_add_logical_vec wrap_json_value_add_logical_vec proc~wrap_json_value_add_logical_vec->interface~to_unicode proc~wrap_json_value_create_logical wrap_json_value_create_logical proc~wrap_json_value_create_logical->interface~to_unicode proc~ucs4_comp_default ucs4_comp_default proc~ucs4_comp_default->interface~to_unicode proc~json_value_add_string_vec_name_ascii json_value_add_string_vec_name_ascii proc~json_value_add_string_vec_name_ascii->interface~to_unicode proc~wrap_json_file_get_logical wrap_json_file_get_logical proc~wrap_json_file_get_logical->interface~to_unicode proc~json_value_add_string_val_ascii json_value_add_string_val_ascii proc~json_value_add_string_val_ascii->interface~to_unicode proc~default_comp_ucs4 default_comp_ucs4 proc~default_comp_ucs4->interface~to_unicode proc~wrap_json_value_add_string_vec wrap_json_value_add_string_vec proc~wrap_json_value_add_string_vec->interface~to_unicode proc~wrap_json_file_get_logical_vec wrap_json_file_get_logical_vec proc~wrap_json_file_get_logical_vec->interface~to_unicode proc~wrap_json_value_create_null wrap_json_value_create_null proc~wrap_json_value_create_null->interface~to_unicode proc~wrap_json_get_integer_vec_with_path wrap_json_get_integer_vec_with_path proc~wrap_json_get_integer_vec_with_path->interface~to_unicode proc~ucs4_neq_default ucs4_neq_default proc~ucs4_neq_default->interface~to_unicode proc~wrap_json_value_create_double wrap_json_value_create_double proc~wrap_json_value_create_double->interface~to_unicode proc~wrap_json_file_variable_info wrap_json_file_variable_info proc~wrap_json_file_variable_info->interface~to_unicode proc~wrap_json_get_integer_with_path wrap_json_get_integer_with_path proc~wrap_json_get_integer_with_path->interface~to_unicode proc~default_neq_ucs4 default_neq_ucs4 proc~default_neq_ucs4->interface~to_unicode proc~wrap_json_value_get_by_name_chars wrap_json_value_get_by_name_chars proc~wrap_json_value_get_by_name_chars->interface~to_unicode proc~wrap_json_file_get_string wrap_json_file_get_string proc~wrap_json_file_get_string->interface~to_unicode proc~wrap_json_update_logical wrap_json_update_logical proc~wrap_json_update_logical->interface~to_unicode proc~wrap_json_update_integer wrap_json_update_integer proc~wrap_json_update_integer->interface~to_unicode proc~wrap_json_get_string_vec_with_path wrap_json_get_string_vec_with_path proc~wrap_json_get_string_vec_with_path->interface~to_unicode proc~wrap_json_file_get_string_vec wrap_json_file_get_string_vec proc~wrap_json_file_get_string_vec->interface~to_unicode proc~wrap_json_value_add_double wrap_json_value_add_double proc~wrap_json_value_add_double->interface~to_unicode proc~wrap_json_get_double_vec_with_path wrap_json_get_double_vec_with_path proc~wrap_json_get_double_vec_with_path->interface~to_unicode proc~wrap_json_file_get_integer wrap_json_file_get_integer proc~wrap_json_file_get_integer->interface~to_unicode proc~wrap_json_file_update_integer wrap_json_file_update_integer proc~wrap_json_file_update_integer->interface~to_unicode proc~wrap_json_update_double wrap_json_update_double proc~wrap_json_update_double->interface~to_unicode proc~wrap_json_get_by_path wrap_json_get_by_path proc~wrap_json_get_by_path->interface~to_unicode proc~wrap_json_file_update_logical wrap_json_file_update_logical proc~wrap_json_file_update_logical->interface~to_unicode proc~wrap_json_value_add_integer wrap_json_value_add_integer proc~wrap_json_value_add_integer->interface~to_unicode proc~wrap_json_update_string wrap_json_update_string proc~wrap_json_update_string->interface~to_unicode proc~wrap_json_value_create_integer wrap_json_value_create_integer proc~wrap_json_value_create_integer->interface~to_unicode proc~wrap_json_value_create_object wrap_json_value_create_object proc~wrap_json_value_create_object->interface~to_unicode proc~json_update_string_name_ascii json_update_string_name_ascii proc~json_update_string_name_ascii->interface~to_unicode proc~wrap_json_parse_string wrap_json_parse_string proc~wrap_json_parse_string->interface~to_unicode proc~json_update_string_val_ascii json_update_string_val_ascii proc~json_update_string_val_ascii->interface~to_unicode proc~wrap_json_get_string_with_path wrap_json_get_string_with_path proc~wrap_json_get_string_with_path->interface~to_unicode proc~wrap_json_get_logical_with_path wrap_json_get_logical_with_path proc~wrap_json_get_logical_with_path->interface~to_unicode proc~wrap_json_file_update_real wrap_json_file_update_real proc~wrap_json_file_update_real->interface~to_unicode proc~wrap_json_file_update_string wrap_json_file_update_string proc~wrap_json_file_update_string->interface~to_unicode proc~wrap_json_file_get_integer_vec wrap_json_file_get_integer_vec proc~wrap_json_file_get_integer_vec->interface~to_unicode proc~wrap_json_file_get_object wrap_json_file_get_object proc~wrap_json_file_get_object->interface~to_unicode proc~wrap_json_value_rename wrap_json_value_rename proc~wrap_json_value_rename->interface~to_unicode proc~json_file_update_string_name_ascii json_file_update_string_name_ascii proc~json_file_update_string_name_ascii->interface~to_unicode proc~json_file_update_string_val_ascii json_file_update_string_val_ascii proc~json_file_update_string_val_ascii->interface~to_unicode proc~wrap_json_value_add_string wrap_json_value_add_string proc~wrap_json_value_add_string->interface~to_unicode proc~wrap_json_value_add_logical wrap_json_value_add_logical proc~wrap_json_value_add_logical->interface~to_unicode proc~wrap_json_file_load_from_string wrap_json_file_load_from_string proc~wrap_json_file_load_from_string->interface~to_unicode proc~unescape_string unescape_string proc~unescape_string->interface~to_unicode proc~wrap_json_get_logical_vec_with_path wrap_json_get_logical_vec_with_path proc~wrap_json_get_logical_vec_with_path->interface~to_unicode proc~wrap_json_value_add_double_vec wrap_json_value_add_double_vec proc~wrap_json_value_add_double_vec->interface~to_unicode proc~json_value_add_string_vec_val_ascii json_value_add_string_vec_val_ascii proc~json_value_add_string_vec_val_ascii->interface~to_unicode interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~ucs4_join_default interface~operator(SLASHSLASH)->proc~default_join_ucs4 interface~operator(==) operator(==) interface~operator(==)->proc~ucs4_comp_default interface~operator(==)->proc~default_comp_ucs4 interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~ucs4_neq_default interface~operator(SLASH=)->proc~default_neq_ucs4 proc~json_get_string json_get_string proc~json_get_string->proc~unescape_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function to_uni_vec ( str ) implicit none character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: str character ( kind = CK , len = len ( str )), dimension ( size ( str )) :: to_uni_vec to_uni_vec = str end function to_uni_vec","tags":"","loc":"proc/to_uni_vec.html","title":"to_uni_vec â€“ JSON-Fortran"},{"text":"private pure function ucs4_join_default(ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value character(kind=CK,len=(len(ucs4_str)+len(def_str))) Description CK // CDK operator. Calls proc~~ucs4_join_default~~CallsGraph proc~ucs4_join_default ucs4_join_default interface~to_unicode to_unicode proc~ucs4_join_default->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~ucs4_join_default~~CalledByGraph proc~ucs4_join_default ucs4_join_default interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~ucs4_join_default Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function ucs4_join_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len = ( len ( ucs4_str ) + len ( def_str ))) :: res res = ucs4_str // to_unicode ( def_str ) end function ucs4_join_default","tags":"","loc":"proc/ucs4_join_default.html","title":"ucs4_join_default â€“ JSON-Fortran"},{"text":"private pure function default_join_ucs4(def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value character(kind=CK,len=(len(def_str)+len(ucs4_str))) Description CDK // CK operator. Calls proc~~default_join_ucs4~~CallsGraph proc~default_join_ucs4 default_join_ucs4 interface~to_unicode to_unicode proc~default_join_ucs4->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~default_join_ucs4~~CalledByGraph proc~default_join_ucs4 default_join_ucs4 interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~default_join_ucs4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function default_join_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CK , len = ( len ( def_str ) + len ( ucs4_str ))) :: res res = to_unicode ( def_str ) // ucs4_str end function default_join_ucs4","tags":"","loc":"proc/default_join_ucs4.html","title":"default_join_ucs4 â€“ JSON-Fortran"},{"text":"private pure elemental function ucs4_comp_default(ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description CK == CDK operator. Calls proc~~ucs4_comp_default~~CallsGraph proc~ucs4_comp_default ucs4_comp_default interface~to_unicode to_unicode proc~ucs4_comp_default->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~ucs4_comp_default~~CalledByGraph proc~ucs4_comp_default ucs4_comp_default interface~operator(==) operator(==) interface~operator(==)->proc~ucs4_comp_default Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function ucs4_comp_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str == to_unicode ( def_str ) ) end function ucs4_comp_default","tags":"","loc":"proc/ucs4_comp_default.html","title":"ucs4_comp_default â€“ JSON-Fortran"},{"text":"private pure elemental function default_comp_ucs4(def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description CDK == CK operator. Calls proc~~default_comp_ucs4~~CallsGraph proc~default_comp_ucs4 default_comp_ucs4 interface~to_unicode to_unicode proc~default_comp_ucs4->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~default_comp_ucs4~~CalledByGraph proc~default_comp_ucs4 default_comp_ucs4 interface~operator(==) operator(==) interface~operator(==)->proc~default_comp_ucs4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function default_comp_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) == ucs4_str ) end function default_comp_ucs4","tags":"","loc":"proc/default_comp_ucs4.html","title":"default_comp_ucs4 â€“ JSON-Fortran"},{"text":"private pure elemental function ucs4_neq_default(ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description CK /= CDK operator. Calls proc~~ucs4_neq_default~~CallsGraph proc~ucs4_neq_default ucs4_neq_default interface~to_unicode to_unicode proc~ucs4_neq_default->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~ucs4_neq_default~~CalledByGraph proc~ucs4_neq_default ucs4_neq_default interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~ucs4_neq_default Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function ucs4_neq_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str /= to_unicode ( def_str ) ) end function ucs4_neq_default","tags":"","loc":"proc/ucs4_neq_default.html","title":"ucs4_neq_default â€“ JSON-Fortran"},{"text":"private pure elemental function default_neq_ucs4(def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description CDK /= CK operator. Calls proc~~default_neq_ucs4~~CallsGraph proc~default_neq_ucs4 default_neq_ucs4 interface~to_unicode to_unicode proc~default_neq_ucs4->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~default_neq_ucs4~~CalledByGraph proc~default_neq_ucs4 default_neq_ucs4 interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~default_neq_ucs4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function default_neq_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) /= ucs4_str ) end function default_neq_ucs4","tags":"","loc":"proc/default_neq_ucs4.html","title":"default_neq_ucs4 â€“ JSON-Fortran"},{"text":"private pure elemental function lowercase_character(c) result(c_lower) Arguments Type Intent Optional Attributes Name character(kind=CK,len=1), intent(in) :: c Return Value character(kind=CK,len=1) Description Return the lowercase version of the CK character. Called By proc~~lowercase_character~~CalledByGraph proc~lowercase_character lowercase_character proc~lowercase_string lowercase_string proc~lowercase_string->proc~lowercase_character proc~name_equal name_equal proc~name_equal->proc~lowercase_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i index in uppercase array Source Code pure elemental function lowercase_character ( c ) result ( c_lower ) implicit none character ( kind = CK , len = 1 ), intent ( in ) :: c character ( kind = CK , len = 1 ) :: c_lower integer :: i !! index in uppercase array i = index ( upper , c ) c_lower = merge ( lower ( i : i ), c , i > 0 ) end function lowercase_character","tags":"","loc":"proc/lowercase_character.html","title":"lowercase_character â€“ JSON-Fortran"},{"text":"public pure elemental function lowercase_string(str) result(s_lower) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str input string Return Value character(kind=CK,len=(len(str))) lowercase version of the string Description Returns lowercase version of the CK string. Calls proc~~lowercase_string~~CallsGraph proc~lowercase_string lowercase_string proc~lowercase_character lowercase_character proc~lowercase_string->proc~lowercase_character Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~lowercase_string~~CalledByGraph proc~lowercase_string lowercase_string proc~name_equal name_equal proc~name_equal->proc~lowercase_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i counter integer, public :: n length of input string Source Code pure elemental function lowercase_string ( str ) result ( s_lower ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! input string character ( kind = CK , len = ( len ( str ))) :: s_lower !! lowercase version of the string integer :: i !! counter integer :: n !! length of input string s_lower = '' n = len_trim ( str ) if ( n > 0 ) then do concurrent ( i = 1 : n ) s_lower ( i : i ) = lowercase_character ( str ( i : i )) end do end if end function lowercase_string","tags":"","loc":"proc/lowercase_string.html","title":"lowercase_string â€“ JSON-Fortran"},{"text":"public pure subroutine integer_to_string(ival, int_fmt, str) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: ival integer value. character(kind=CDK,len=*), intent(in) :: int_fmt format for integers character(kind=CK,len=*), intent(out) :: str ival converted to a string. Description Convert an integer to a string. Called By proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string proc~json_value_print json_value_print proc~json_value_print->proc~integer_to_string proc~push_char push_char proc~push_char->proc~integer_to_string proc~annotate_invalid_json annotate_invalid_json proc~annotate_invalid_json->proc~integer_to_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: istat Source Code pure subroutine integer_to_string ( ival , int_fmt , str ) implicit none integer ( IK ), intent ( in ) :: ival !! integer value. character ( kind = CDK , len =* ), intent ( in ) :: int_fmt !! format for integers character ( kind = CK , len =* ), intent ( out ) :: str !! `ival` converted to a string. integer ( IK ) :: istat write ( str , fmt = int_fmt , iostat = istat ) ival if ( istat == 0 ) then str = adjustl ( str ) else str = repeat ( star , len ( str )) end if end subroutine integer_to_string","tags":"","loc":"proc/integer_to_string.html","title":"integer_to_string â€“ JSON-Fortran"},{"text":"public subroutine real_to_string(rval, real_fmt, compact_real, str) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: rval real value. character(kind=CDK,len=*), intent(in) :: real_fmt format for real numbers logical(kind=LK), intent(in) :: compact_real compact the string so that it is\n displayed with fewer characters character(kind=CK,len=*), intent(out) :: str rval converted to a string. Description Convert a real value to a string. Modified Izaak Beekman : 02/24/2015 : added the compact option. Jacob Williams : 10/27/2015 : added the star option. Calls proc~~real_to_string~~CallsGraph proc~real_to_string real_to_string proc~compact_real_string compact_real_string proc~real_to_string->proc~compact_real_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~real_to_string~~CalledByGraph proc~real_to_string real_to_string proc~json_value_print json_value_print proc~json_value_print->proc~real_to_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: istat Source Code subroutine real_to_string ( rval , real_fmt , compact_real , str ) implicit none real ( RK ), intent ( in ) :: rval !! real value. character ( kind = CDK , len =* ), intent ( in ) :: real_fmt !! format for real numbers logical ( LK ), intent ( in ) :: compact_real !! compact the string so that it is !! displayed with fewer characters character ( kind = CK , len =* ), intent ( out ) :: str !! `rval` converted to a string. integer ( IK ) :: istat if ( real_fmt == star ) then write ( str , fmt =* , iostat = istat ) rval else write ( str , fmt = real_fmt , iostat = istat ) rval end if if ( istat == 0 ) then !in this case, the default string will be compacted, ! so that the same value is displayed with fewer characters. if ( compact_real ) call compact_real_string ( str ) else str = repeat ( star , len ( str )) end if end subroutine real_to_string","tags":"","loc":"proc/real_to_string.html","title":"real_to_string â€“ JSON-Fortran"},{"text":"private subroutine compact_real_string(str) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(inout) :: str string representation of a real number. Description Compact a string representing a real number, so that\n  the same value is displayed with fewer characters. See also real_to_string Called By proc~~compact_real_string~~CalledByGraph proc~compact_real_string compact_real_string proc~real_to_string real_to_string proc~real_to_string->proc~compact_real_string proc~json_value_print json_value_print proc~json_value_print->proc~real_to_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CK,len=len(str)), public :: significand character(kind=CK,len=len(str)), public :: expnt character(kind=CK,len=2), public :: separator integer(kind=IK), public :: exp_start integer(kind=IK), public :: decimal_pos integer(kind=IK), public :: sig_trim integer(kind=IK), public :: exp_trim integer(kind=IK), public :: i counter Source Code subroutine compact_real_string ( str ) implicit none character ( kind = CK , len =* ), intent ( inout ) :: str !! string representation of a real number. character ( kind = CK , len = len ( str )) :: significand character ( kind = CK , len = len ( str )) :: expnt character ( kind = CK , len = 2 ) :: separator integer ( IK ) :: exp_start integer ( IK ) :: decimal_pos integer ( IK ) :: sig_trim integer ( IK ) :: exp_trim integer ( IK ) :: i !! counter str = adjustl ( str ) exp_start = scan ( str , CK_ 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , CK_ '-+' , back = . true .) decimal_pos = scan ( str , CK_ '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine compact_real_string","tags":"","loc":"proc/compact_real_string.html","title":"compact_real_string â€“ JSON-Fortran"},{"text":"public subroutine escape_string(str_in, str_out) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in character(kind=CK,len=:), intent(out), allocatable :: str_out Description Add the escape characters to a string for adding to JSON . Called By proc~~escape_string~~CalledByGraph proc~escape_string escape_string proc~json_value_add_string json_value_add_string proc~json_value_add_string->proc~escape_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i counter integer(kind=IK), public :: ipos accumulated string size\n (so we can allocate it in chunks for\n greater runtime efficiency) character(kind=CK,len=1), public :: c for reading str_in one character at a time. character(kind=CK,len=:), public, allocatable :: tmp workaround for bug in gfortran 6.1 character(kind=CK,len=*), public, parameter :: specials = quotation_mark//backslash//slash//bspace//formfeed//newline//carriage_return//horizontal_tab Source Code subroutine escape_string ( str_in , str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out integer ( IK ) :: i !! counter integer ( IK ) :: ipos !! accumulated string size !! (so we can allocate it in chunks for !! greater runtime efficiency) character ( kind = CK , len = 1 ) :: c !! for reading `str_in` one character at a time. #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! workaround for bug in gfortran 6.1 #endif character ( kind = CK , len =* ), parameter :: specials = quotation_mark // & backslash // & slash // & bspace // & formfeed // & newline // & carriage_return // & horizontal_tab !Do a quick scan for the special characters, ! if any are present, then process the string, ! otherwise, return the string as is. if ( scan ( str_in , specials ) > 0 ) then str_out = repeat ( space , chunk_size ) ipos = 1 !go through the string and look for special characters: do i = 1 , len ( str_in ) c = str_in ( i : i ) !get next character in the input string !if the string is not big enough, then add another chunk: if ( ipos + 3 > len ( str_out )) str_out = str_out // repeat ( space , chunk_size ) select case ( c ) case ( quotation_mark , backslash , slash ) str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( bspace ) str_out ( ipos : ipos + 1 ) = '\\b' ipos = ipos + 2 case ( formfeed ) str_out ( ipos : ipos + 1 ) = '\\f' ipos = ipos + 2 case ( newline ) str_out ( ipos : ipos + 1 ) = '\\n' ipos = ipos + 2 case ( carriage_return ) str_out ( ipos : ipos + 1 ) = '\\r' ipos = ipos + 2 case ( horizontal_tab ) str_out ( ipos : ipos + 1 ) = '\\t' ipos = ipos + 2 case default str_out ( ipos : ipos ) = c ipos = ipos + 1 end select end do !trim the string if necessary: if ( ipos < len ( str_out ) + 1 ) then if ( ipos == 1 ) then str_out = '' else #if defined __GFORTRAN__ tmp = str_out ( 1 : ipos - 1 ) !workaround for bug in gfortran 6.1 str_out = tmp #else str_out = str_out ( 1 : ipos - 1 ) !original #endif end if end if else str_out = str_in end if end subroutine escape_string","tags":"","loc":"proc/escape_string.html","title":"escape_string â€“ JSON-Fortran"},{"text":"public subroutine unescape_string(str_in, str_out, error_message) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in string as stored in a json_value character(kind=CK,len=:), intent(out), allocatable :: str_out decoded string character(kind=CK,len=:), intent(out), allocatable :: error_message will be allocated if there was an error Description Remove the escape characters from a JSON string and return it. The escaped characters are denoted by the '' character: '\\\"'        quotation mark\n    '\\\\'        reverse solidus\n    '\\/'        solidus\n    '\\b'        backspace\n    '\\f'        formfeed\n    '\\n'        newline (LF)\n    '\\r'        carriage return (CR)\n    '\\t'        horizontal tab\n    '\\uXXXX'    4 hexadecimal digits Calls proc~~unescape_string~~CallsGraph proc~unescape_string unescape_string interface~to_unicode to_unicode proc~unescape_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~unescape_string~~CalledByGraph proc~unescape_string unescape_string proc~json_get_string json_get_string proc~json_get_string->proc~unescape_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i counter integer, public :: n length of str_in integer, public :: m length of str_out character(kind=CK,len=1), public :: c for scanning each character in string Source Code subroutine unescape_string ( str_in , str_out , error_message ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in !! string as stored in a [[json_value]] character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out !! decoded string character ( kind = CK , len = :), allocatable , intent ( out ) :: error_message !! will be allocated if there was an error integer :: i !! counter integer :: n !! length of str_in integer :: m !! length of str_out character ( kind = CK , len = 1 ) :: c !! for scanning each character in string if ( scan ( str_in , backslash ) > 0 ) then !there is at least one escape character, so process this string: n = len ( str_in ) str_out = repeat ( space , n ) !size the output string (will be trimmed later) m = 0 !counter in str_out i = 0 !counter in str_in do i = i + 1 if ( i > n ) exit ! finished c = str_in ( i : i ) ! get next character in the string if ( c == backslash ) then if ( i < n ) then i = i + 1 c = str_in ( i : i ) !character after the escape if ( any ( c == [ quotation_mark , backslash , slash , & to_unicode ([ 'b' , 'f' , 'n' , 'r' , 't' ])])) then select case ( c ) case ( quotation_mark , backslash , slash ) !use d as is case ( CK_ 'b' ) c = bspace case ( CK_ 'f' ) c = formfeed case ( CK_ 'n' ) c = newline case ( CK_ 'r' ) c = carriage_return case ( CK_ 't' ) c = horizontal_tab end select m = m + 1 str_out ( m : m ) = c else if ( c == 'u' ) then !expecting 4 hexadecimal digits after !the escape character    [\\uXXXX] !for now, we are just returning them as is ![not checking to see if it is a valid hex value] ! ! Example: !   123456 !   \\uXXXX if ( i + 4 <= n ) then m = m + 1 str_out ( m : m + 5 ) = str_in ( i - 1 : i + 4 ) i = i + 4 m = m + 5 else error_message = 'Error in unescape_string:' // & ' Invalid hexadecimal sequence' // & ' in string: ' // str_in ( i - 1 :) if ( allocated ( str_out )) deallocate ( str_out ) return end if else !unknown escape character error_message = 'Error in unescape_string:' // & ' unknown escape sequence in string \"' // & trim ( str_in ) // '\" [' // backslash // c // ']' if ( allocated ( str_out )) deallocate ( str_out ) return end if else !an escape character is the last character in ! the string [this may not be valid syntax, ! but just keep it] m = m + 1 str_out ( m : m ) = c end if else m = m + 1 str_out ( m : m ) = c end if end do !trim trailing space: str_out = str_out ( 1 : m ) else !there are no escape characters, so return as is: str_out = str_in end if end subroutine unescape_string","tags":"","loc":"proc/unescape_string.html","title":"unescape_string â€“ JSON-Fortran"},{"text":"public interface to_unicode Convert a 'DEFAULT' kind character input to\n  'ISO_10646' kind and return it Calls interface~~to_unicode~~CallsGraph interface~to_unicode to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~to_unicode~~CalledByGraph interface~to_unicode to_unicode proc~wrap_json_get_double_with_path wrap_json_get_double_with_path proc~wrap_json_get_double_with_path->interface~to_unicode proc~wrap_json_value_create_array wrap_json_value_create_array proc~wrap_json_value_create_array->interface~to_unicode proc~wrap_json_file_get_double wrap_json_file_get_double proc~wrap_json_file_get_double->interface~to_unicode proc~json_value_add_string_name_ascii json_value_add_string_name_ascii proc~json_value_add_string_name_ascii->interface~to_unicode proc~ucs4_join_default ucs4_join_default proc~ucs4_join_default->interface~to_unicode proc~wrap_json_value_remove_if_present wrap_json_value_remove_if_present proc~wrap_json_value_remove_if_present->interface~to_unicode proc~wrap_json_file_get_double_vec wrap_json_file_get_double_vec proc~wrap_json_file_get_double_vec->interface~to_unicode proc~wrap_json_value_create_string wrap_json_value_create_string proc~wrap_json_value_create_string->interface~to_unicode proc~wrap_json_throw_exception wrap_json_throw_exception proc~wrap_json_throw_exception->interface~to_unicode proc~default_join_ucs4 default_join_ucs4 proc~default_join_ucs4->interface~to_unicode proc~wrap_json_get_array_with_path wrap_json_get_array_with_path proc~wrap_json_get_array_with_path->interface~to_unicode proc~wrap_json_value_add_integer_vec wrap_json_value_add_integer_vec proc~wrap_json_value_add_integer_vec->interface~to_unicode proc~wrap_json_value_add_logical_vec wrap_json_value_add_logical_vec proc~wrap_json_value_add_logical_vec->interface~to_unicode proc~wrap_json_value_create_logical wrap_json_value_create_logical proc~wrap_json_value_create_logical->interface~to_unicode proc~ucs4_comp_default ucs4_comp_default proc~ucs4_comp_default->interface~to_unicode proc~json_value_add_string_vec_name_ascii json_value_add_string_vec_name_ascii proc~json_value_add_string_vec_name_ascii->interface~to_unicode proc~wrap_json_file_get_logical wrap_json_file_get_logical proc~wrap_json_file_get_logical->interface~to_unicode proc~json_value_add_string_val_ascii json_value_add_string_val_ascii proc~json_value_add_string_val_ascii->interface~to_unicode proc~default_comp_ucs4 default_comp_ucs4 proc~default_comp_ucs4->interface~to_unicode proc~wrap_json_value_add_string_vec wrap_json_value_add_string_vec proc~wrap_json_value_add_string_vec->interface~to_unicode proc~wrap_json_file_get_logical_vec wrap_json_file_get_logical_vec proc~wrap_json_file_get_logical_vec->interface~to_unicode proc~wrap_json_value_create_null wrap_json_value_create_null proc~wrap_json_value_create_null->interface~to_unicode proc~wrap_json_get_integer_vec_with_path wrap_json_get_integer_vec_with_path proc~wrap_json_get_integer_vec_with_path->interface~to_unicode proc~ucs4_neq_default ucs4_neq_default proc~ucs4_neq_default->interface~to_unicode proc~wrap_json_value_create_double wrap_json_value_create_double proc~wrap_json_value_create_double->interface~to_unicode proc~wrap_json_file_variable_info wrap_json_file_variable_info proc~wrap_json_file_variable_info->interface~to_unicode proc~wrap_json_get_integer_with_path wrap_json_get_integer_with_path proc~wrap_json_get_integer_with_path->interface~to_unicode proc~default_neq_ucs4 default_neq_ucs4 proc~default_neq_ucs4->interface~to_unicode proc~wrap_json_value_get_by_name_chars wrap_json_value_get_by_name_chars proc~wrap_json_value_get_by_name_chars->interface~to_unicode proc~wrap_json_file_get_string wrap_json_file_get_string proc~wrap_json_file_get_string->interface~to_unicode proc~wrap_json_update_logical wrap_json_update_logical proc~wrap_json_update_logical->interface~to_unicode proc~wrap_json_update_integer wrap_json_update_integer proc~wrap_json_update_integer->interface~to_unicode proc~wrap_json_get_string_vec_with_path wrap_json_get_string_vec_with_path proc~wrap_json_get_string_vec_with_path->interface~to_unicode proc~wrap_json_file_get_string_vec wrap_json_file_get_string_vec proc~wrap_json_file_get_string_vec->interface~to_unicode proc~wrap_json_value_add_double wrap_json_value_add_double proc~wrap_json_value_add_double->interface~to_unicode proc~wrap_json_get_double_vec_with_path wrap_json_get_double_vec_with_path proc~wrap_json_get_double_vec_with_path->interface~to_unicode proc~wrap_json_file_get_integer wrap_json_file_get_integer proc~wrap_json_file_get_integer->interface~to_unicode proc~wrap_json_file_update_integer wrap_json_file_update_integer proc~wrap_json_file_update_integer->interface~to_unicode proc~wrap_json_update_double wrap_json_update_double proc~wrap_json_update_double->interface~to_unicode proc~wrap_json_get_by_path wrap_json_get_by_path proc~wrap_json_get_by_path->interface~to_unicode proc~wrap_json_file_update_logical wrap_json_file_update_logical proc~wrap_json_file_update_logical->interface~to_unicode proc~wrap_json_value_add_integer wrap_json_value_add_integer proc~wrap_json_value_add_integer->interface~to_unicode proc~wrap_json_update_string wrap_json_update_string proc~wrap_json_update_string->interface~to_unicode proc~wrap_json_value_create_integer wrap_json_value_create_integer proc~wrap_json_value_create_integer->interface~to_unicode proc~wrap_json_value_create_object wrap_json_value_create_object proc~wrap_json_value_create_object->interface~to_unicode proc~json_update_string_name_ascii json_update_string_name_ascii proc~json_update_string_name_ascii->interface~to_unicode proc~wrap_json_parse_string wrap_json_parse_string proc~wrap_json_parse_string->interface~to_unicode proc~json_update_string_val_ascii json_update_string_val_ascii proc~json_update_string_val_ascii->interface~to_unicode proc~wrap_json_get_string_with_path wrap_json_get_string_with_path proc~wrap_json_get_string_with_path->interface~to_unicode proc~wrap_json_get_logical_with_path wrap_json_get_logical_with_path proc~wrap_json_get_logical_with_path->interface~to_unicode proc~wrap_json_file_update_real wrap_json_file_update_real proc~wrap_json_file_update_real->interface~to_unicode proc~wrap_json_file_update_string wrap_json_file_update_string proc~wrap_json_file_update_string->interface~to_unicode proc~wrap_json_file_get_integer_vec wrap_json_file_get_integer_vec proc~wrap_json_file_get_integer_vec->interface~to_unicode proc~wrap_json_file_get_object wrap_json_file_get_object proc~wrap_json_file_get_object->interface~to_unicode proc~wrap_json_value_rename wrap_json_value_rename proc~wrap_json_value_rename->interface~to_unicode proc~json_file_update_string_name_ascii json_file_update_string_name_ascii proc~json_file_update_string_name_ascii->interface~to_unicode proc~json_file_update_string_val_ascii json_file_update_string_val_ascii proc~json_file_update_string_val_ascii->interface~to_unicode proc~wrap_json_value_add_string wrap_json_value_add_string proc~wrap_json_value_add_string->interface~to_unicode proc~wrap_json_value_add_logical wrap_json_value_add_logical proc~wrap_json_value_add_logical->interface~to_unicode proc~wrap_json_file_load_from_string wrap_json_file_load_from_string proc~wrap_json_file_load_from_string->interface~to_unicode proc~unescape_string unescape_string proc~unescape_string->interface~to_unicode proc~wrap_json_get_logical_vec_with_path wrap_json_get_logical_vec_with_path proc~wrap_json_get_logical_vec_with_path->interface~to_unicode proc~wrap_json_value_add_double_vec wrap_json_value_add_double_vec proc~wrap_json_value_add_double_vec->interface~to_unicode proc~json_value_add_string_vec_val_ascii json_value_add_string_vec_val_ascii proc~json_value_add_string_vec_val_ascii->interface~to_unicode interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~ucs4_join_default interface~operator(SLASHSLASH)->proc~default_join_ucs4 interface~operator(==) operator(==) interface~operator(==)->proc~ucs4_comp_default interface~operator(==)->proc~default_comp_ucs4 interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~ucs4_neq_default interface~operator(SLASH=)->proc~default_neq_ucs4 proc~json_get_string json_get_string proc~json_get_string->proc~unescape_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function to_uni (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) Description Author Izaak Beekman Convert string to unicode (CDK to CK). private pure function to_uni_vec (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Description Author Izaak Beekman Convert array of strings to unicode (CDK to CK).","tags":"","loc":"interface/to_unicode.html","title":"to_unicode â€“ JSON-Fortran"},{"text":"public interface operator(//) Provide a means to convert to UCS4 while\n concatenating UCS4 and default strings Calls interface~~operator(SLASHSLASH)~~CallsGraph interface~operator(SLASHSLASH) operator(//) proc~ucs4_join_default ucs4_join_default interface~operator(SLASHSLASH)->proc~ucs4_join_default proc~default_join_ucs4 default_join_ucs4 interface~operator(SLASHSLASH)->proc~default_join_ucs4 interface~to_unicode to_unicode proc~ucs4_join_default->interface~to_unicode proc~default_join_ucs4->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function ucs4_join_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value character(kind=CK,len=(len(ucs4_str)+len(def_str))) Description Author Izaak Beekman CK // CDK operator. private pure function default_join_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value character(kind=CK,len=(len(def_str)+len(ucs4_str))) Description Author Izaak Beekman CDK // CK operator.","tags":"","loc":"interface/operator(SLASHSLASH).html","title":"operator(//) â€“ JSON-Fortran"},{"text":"public interface operator(==) Provide a string == operator that works\n with mixed kinds Calls interface~~operator(==)~~CallsGraph interface~operator(==) operator(==) proc~ucs4_comp_default ucs4_comp_default interface~operator(==)->proc~ucs4_comp_default proc~default_comp_ucs4 default_comp_ucs4 interface~operator(==)->proc~default_comp_ucs4 interface~to_unicode to_unicode proc~ucs4_comp_default->interface~to_unicode proc~default_comp_ucs4->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental function ucs4_comp_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description Author Izaak Beekman CK == CDK operator. private pure elemental function default_comp_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description Author Izaak Beekman CDK == CK operator.","tags":"","loc":"interface/operator(==).html","title":"operator(==) â€“ JSON-Fortran"},{"text":"public interface operator(/=) Provide a string /= operator that works\n with mixed kinds Calls interface~~operator(SLASH=)~~CallsGraph interface~operator(SLASH=) operator(/=) proc~ucs4_neq_default ucs4_neq_default interface~operator(SLASH=)->proc~ucs4_neq_default proc~default_neq_ucs4 default_neq_ucs4 interface~operator(SLASH=)->proc~default_neq_ucs4 interface~to_unicode to_unicode proc~ucs4_neq_default->interface~to_unicode proc~default_neq_ucs4->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental function ucs4_neq_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description Author Jacob Williams CK /= CDK operator. private pure elemental function default_neq_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description Author Jacob Williams CDK /= CK operator.","tags":"","loc":"interface/operator(SLASH=).html","title":"operator(/=) â€“ JSON-Fortran"},{"text":"private function initialize_json_core(verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(json_core_object) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_core ) Description Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Note initialize_json_core , json_initialize , initialize_json_core_in_file , and initialize_json_file all have a similar interface. Called By proc~~initialize_json_core~~CalledByGraph proc~initialize_json_core initialize_json_core interface~json_core json_core interface~json_core->proc~initialize_json_core Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function initialize_json_core ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) result ( json_core_object ) implicit none type ( json_core ) :: json_core_object logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call json_core_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) end function initialize_json_core","tags":"","loc":"proc/initialize_json_core.html","title":"initialize_json_core â€“ JSON-Fortran"},{"text":"private function name_equal(json, p, name) result(is_equal) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in) :: p the json object character(kind=CK,len=*), intent(in) :: name the name to check for Return Value logical(kind=LK) true if the string are lexically equal Description Returns true if name is equal to p%name , using the specified\n  settings for case sensitivity and trailing whitespace. Calls proc~~name_equal~~CallsGraph proc~name_equal name_equal proc~lowercase_string lowercase_string proc~name_equal->proc~lowercase_string proc~lowercase_character lowercase_character proc~lowercase_string->proc~lowercase_character Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function name_equal ( json , p , name ) result ( is_equal ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), intent ( in ) :: p !! the json object character ( kind = CK , len =* ), intent ( in ) :: name !! the name to check for logical ( LK ) :: is_equal !! true if the string are lexically equal if ( allocated ( p % name )) then !must be the same length if we are treating !trailing spaces as significant, so do a !quick test of this first: if ( json % trailing_spaces_significant ) then is_equal = len ( p % name ) == len ( name ) if (. not . is_equal ) return end if if ( json % case_sensitive_keys ) then is_equal = p % name == name else is_equal = lowercase_string ( p % name ) == lowercase_string ( name ) end if else is_equal = name == '' ! check a blank name end if end function name_equal","tags":"","loc":"proc/name_equal.html","title":"name_equal â€“ JSON-Fortran"},{"text":"private pure function json_failed(json) result(failed) Arguments Type Intent Optional Attributes Name class( json_core ), intent(in) :: json Return Value logical(kind=LK) will be true if an exception\n has been thrown. Description Logical function to indicate if an exception has been thrown in a json_core . Example type ( json_core ) :: json type ( json_value ), pointer :: p logical :: status_ok character ( len = :), allocatable :: error_msg call json % parse ( filename = 'myfile.json' , p ) if ( json % failed ()) then call json % check_for_errors ( status_ok , error_msg ) write ( * , * ) 'Error: ' // error_msg call json % clear_exceptions () call json % destroy ( p ) end if Note that json_file contains a wrapper for this routine, which is used like: type ( json_file ) :: f logical :: status_ok character ( len = :), allocatable :: error_msg call f % load_file ( filename = 'myfile.json' ) if ( f % failed ()) then call f % check_for_errors ( status_ok , error_msg ) write ( * , * ) 'Error: ' // error_msg call f % clear_exceptions () call f % destroy () end if See also json_check_for_errors Source Code pure function json_failed ( json ) result ( failed ) implicit none class ( json_core ), intent ( in ) :: json logical ( LK ) :: failed !! will be true if an exception !! has been thrown. failed = json % exception_thrown end function json_failed","tags":"","loc":"proc/json_failed.html","title":"json_failed â€“ JSON-Fortran"},{"text":"private function json_value_is_child_of(json, p1, p2) result(is_child_of) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p1 type( json_value ), , pointer :: p2 Return Value logical(kind=LK) Description Returns True if p2 is a descendant of p1 (i.e, a child, or a child of child, etc.) Subroutines subroutine is_child_of_callback(json, p, finished) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: finished Description Traverse until p is p2 . Source Code function json_value_is_child_of ( json , p1 , p2 ) result ( is_child_of ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical ( LK ) :: is_child_of is_child_of = . false . if ( json % exception_thrown ) return if ( associated ( p1 ) . and . associated ( p2 )) then if ( associated ( p1 % children )) then call json % traverse ( p1 % children , is_child_of_callback ) end if end if contains subroutine is_child_of_callback ( json , p , finished ) !! Traverse until `p` is `p2`. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished is_child_of = associated ( p , p2 ) finished = is_child_of ! stop searching if found end subroutine is_child_of_callback end function json_value_is_child_of","tags":"","loc":"proc/json_value_is_child_of.html","title":"json_value_is_child_of â€“ JSON-Fortran"},{"text":"private function json_count(json, p) result(count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p Return Value integer(kind=IK) number of children Description Count the number of children. History JW : 1/4/2014 : Original routine removed.\n    Now using n_children variable.\n    Renamed from json_value_count. Source Code function json_count ( json , p ) result ( count ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ) :: count !! number of children if ( associated ( p )) then count = p % n_children else call json % throw_exception ( 'Error in json_count: ' // & 'pointer is not associated.' ) end if end function json_count","tags":"","loc":"proc/json_count.html","title":"json_count â€“ JSON-Fortran"},{"text":"private function string_to_integer(json, str) result(ival) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value integer(kind=IK) Description Convert a string into an integer. History Jacob Williams : 12/10/2013 : Rewrote routine.  Added error checking. Modified by Izaak Beekman Note Replacement for the parse_integer function in the original code. Variables Type Visibility Attributes Name Initial character(kind=CDK,len=:), public, allocatable :: digits integer(kind=IK), public :: ndigits_digits integer(kind=IK), public :: ndigits integer(kind=IK), public :: ierr Source Code function string_to_integer ( json , str ) result ( ival ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ival character ( kind = CDK , len = :), allocatable :: digits integer ( IK ) :: ndigits_digits , ndigits , ierr if (. not . json % exception_thrown ) then ! Compute how many digits we need to read ndigits = 2 * len_trim ( str ) ndigits_digits = floor ( log10 ( real ( ndigits ))) + 1 allocate ( character ( kind = CDK , len = ndigits_digits ) :: digits ) write ( digits , '(I0)' ) ndigits !gfortran will have a runtime error with * edit descriptor here ! gfortran bug: '*' edit descriptor for ISO_10646 strings does bad stuff. read ( str , '(I' // trim ( digits ) // ')' , iostat = ierr ) ival !string to integer if ( ierr /= 0 ) then !if there was an error ival = 0 call json % throw_exception ( 'Error in string_to_integer: ' // & 'string cannot be converted to an integer: ' // & trim ( str )) end if else ival = 0 end if end function string_to_integer","tags":"","loc":"proc/string_to_integer.html","title":"string_to_integer â€“ JSON-Fortran"},{"text":"private function string_to_double(json, str) result(rval) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value real(kind=RK) Description Convert a string into a double. History Jacob Williams, 10/27/2015 : Now using fmt=*, rather than\n    fmt=real_fmt, since it doesn't work for some unusual cases\n    (e.g., when str='1E-5'). Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: ierr read iostat error code Source Code function string_to_double ( json , str ) result ( rval ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str real ( RK ) :: rval integer ( IK ) :: ierr !! read iostat error code if (. not . json % exception_thrown ) then !string to double read ( str , fmt =* , iostat = ierr ) rval if ( ierr /= 0 ) then !if there was an error rval = 0.0_RK call json % throw_exception ( 'Error in string_to_double: ' // & 'string cannot be converted to a double: ' // & trim ( str )) end if else rval = 0.0_RK end if end function string_to_double","tags":"","loc":"proc/string_to_double.html","title":"string_to_double â€“ JSON-Fortran"},{"text":"private recursive function pop_char(json, unit, str, eof, skip_ws) result(popped) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) â€“ only used if unit=0 logical(kind=LK), intent(out) :: eof true if the end of the file has been reached. logical(kind=LK), intent(in), optional :: skip_ws to ignore whitespace. Return Value character(kind=CK,len=1) the popped character. Description Get the next character from the file (or string). See also push_char Note This routine ignores non-printing ASCII characters (iachar<=31) that are in strings. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: ios integer(kind=IK), public :: str_len character(kind=CK,len=1), public :: c logical(kind=LK), public :: ignore Source Code recursive function pop_char ( json , unit , str , eof , skip_ws ) result ( popped ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len = 1 ) :: popped !! the popped character. integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) -- only used if unit=0 logical ( LK ), intent ( out ) :: eof !! true if the end of the file has been reached. logical ( LK ), intent ( in ), optional :: skip_ws !! to ignore whitespace. integer ( IK ) :: ios , str_len character ( kind = CK , len = 1 ) :: c logical ( LK ) :: ignore if (. not . json % exception_thrown ) then eof = . false . if (. not . present ( skip_ws )) then ignore = . false . else ignore = skip_ws end if do if ( json % pushed_index > 0 ) then ! there is a character pushed back on, most likely ! from the number parsing. Note: this can only occur if ! reading from a file when use_unformatted_stream=.false. c = json % pushed_char ( json % pushed_index : json % pushed_index ) json % pushed_index = json % pushed_index - 1 else if ( unit /= 0 ) then !read from the file !read the next character: if ( use_unformatted_stream ) then read ( unit = unit , pos = json % ipos , iostat = ios ) c else read ( unit = unit , fmt = '(A1)' , advance = 'NO' , iostat = ios ) c end if json % ipos = json % ipos + 1 !....note: maybe try read the file in chunks... !.... or use asynchronous read with double buffering !     (see Modern Fortran: Style and Usage) else !read from the string str_len = len ( str ) !length of the string if ( json % ipos <= str_len ) then c = str ( json % ipos : json % ipos ) ios = 0 else ios = IOSTAT_END !end of the string end if json % ipos = json % ipos + 1 end if json % char_count = json % char_count + 1 !character count in the current line if ( IS_IOSTAT_END ( ios )) then !end of file json % char_count = 0 eof = . true . exit else if ( IS_IOSTAT_EOR ( ios ) . or . c == newline ) then !end of record json % char_count = 0 json % line_count = json % line_count + 1 cycle end if end if if ( any ( c == control_chars )) then ! non printing ascii characters cycle else if ( ignore . and . c == space ) then cycle else popped = c exit end if end do end if end function pop_char","tags":"","loc":"proc/pop_char.html","title":"pop_char â€“ JSON-Fortran"},{"text":"private subroutine destroy_json_core(me) Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me Description Destructor for the json_core type. Source Code subroutine destroy_json_core ( me ) implicit none class ( json_core ), intent ( out ) :: me end subroutine destroy_json_core","tags":"","loc":"proc/destroy_json_core.html","title":"destroy_json_core â€“ JSON-Fortran"},{"text":"private subroutine json_initialize(json, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Description Initialize the json_core instance. The routine may be called before any of the json_core methods are used in\n  order to specify certain parameters. If it is not called, then the defaults\n  are used. This routine is also called internally by various routines.\n  It can also be called to clear exceptions, or to reset some\n  of the variables (note that only the arguments present are changed). Modified Izaak Beekman : 02/24/2015 Note initialize_json_core , json_initialize , initialize_json_core_in_file , and initialize_json_file all have a similar interface. Variables Type Visibility Attributes Name Initial character(kind=CDK,len=10), public :: w character(kind=CDK,len=10), public :: d character(kind=CDK,len=10), public :: e character(kind=CDK,len=2), public :: sgn character(kind=CDK,len=2), public :: rl_edit_desc integer(kind=IK), public :: istat logical(kind=LK), public :: sgn_prnt Source Code subroutine json_initialize ( json , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) implicit none class ( json_core ), intent ( inout ) :: json logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. character ( kind = CDK , len = 10 ) :: w , d , e character ( kind = CDK , len = 2 ) :: sgn , rl_edit_desc integer ( IK ) :: istat logical ( LK ) :: sgn_prnt !reset exception to false: call json % clear_exceptions () !Just in case, clear these global variables also: json % pushed_index = 0 json % pushed_char = '' json % char_count = 0 json % line_count = 1 json % ipos = 1 #ifdef USE_UCS4 ! reopen stdout and stderr with utf-8 encoding open ( output_unit , encoding = 'utf-8' ) open ( error_unit , encoding = 'utf-8' ) #endif !various optional inputs: if ( present ( spaces_per_tab )) & json % spaces_per_tab = spaces_per_tab if ( present ( verbose )) & json % is_verbose = verbose if ( present ( strict_type_checking )) & json % strict_type_checking = strict_type_checking if ( present ( trailing_spaces_significant )) & json % trailing_spaces_significant = trailing_spaces_significant if ( present ( case_sensitive_keys )) & json % case_sensitive_keys = case_sensitive_keys !Set the format for real numbers: ! [if not changing it, then it remains the same] if ( (. not . allocated ( json % real_fmt )) . or . & ! if this hasn't been done yet present ( compact_reals ) . or . & present ( print_signs ) . or . & present ( real_format ) ) then !allow the special case where real format is '*': ! [this overrides the other options] if ( present ( real_format )) then if ( real_format == star ) then json % compact_real = . false . json % real_fmt = star return end if end if if ( present ( compact_reals )) json % compact_real = compact_reals !set defaults sgn_prnt = . false . if ( present ( print_signs ) ) sgn_prnt = print_signs if ( sgn_prnt ) then sgn = 'sp' else sgn = 'ss' end if rl_edit_desc = 'E' if ( present ( real_format ) ) then select case ( real_format ) case ( 'g' , 'G' , 'e' , 'E' , 'en' , 'EN' , 'es' , 'ES' ) rl_edit_desc = real_format case default call json % throw_exception ( 'Invalid real format, \"' // & trim ( real_format ) // '\", passed to json_initialize.' // & new_line ( 'a' ) // 'Acceptable formats are: \"G\", \"E\", \"EN\", and \"ES\".' ) end select end if ! set the default output/input format for reals: write ( w , '(ss,I0)' , iostat = istat ) max_numeric_str_len if ( istat == 0 ) write ( d , '(ss,I0)' , iostat = istat ) real_precision if ( istat == 0 ) write ( e , '(ss,I0)' , iostat = istat ) real_exponent_digits if ( istat == 0 ) then json % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & trim ( w ) // '.' // trim ( d ) // 'E' // trim ( e ) // ')' else json % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & '30.16E3)' !just use this one (should never happen) end if end if end subroutine json_initialize","tags":"","loc":"proc/json_initialize.html","title":"json_initialize â€“ JSON-Fortran"},{"text":"private subroutine json_clone(json, from, to) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: from this is the structure to clone type( json_value ), , pointer :: to the clone is put here\n (it must not already be associated) Description Create a deep copy of a json_value linked-list structure. Example program test use json_module implicit none type ( json_core ) :: json type ( json_value ), pointer :: j1 , j2 call json % parse ( '../files/inputs/test1.json' , j1 ) call json % clone ( j1 , j2 ) !now have two independent copies call json % destroy ( j1 ) !destroys j1, but j2 remains call json % print ( j2 , 'j2.json' ) call json % destroy ( j2 ) end program test Calls proc~~json_clone~~CallsGraph proc~json_clone json_clone proc~json_value_clone_func json_value_clone_func proc~json_clone->proc~json_value_clone_func proc~json_value_clone_func->proc~json_value_clone_func Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_clone ( json , from , to ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here !! (it must not already be associated) !call the main function: ! [note: this is not part of json_core class] call json_value_clone_func ( from , to ) end subroutine json_clone","tags":"","loc":"proc/json_clone.html","title":"json_clone â€“ JSON-Fortran"},{"text":"private recursive subroutine json_value_clone_func(from, to, parent, previous, next, children, tail) Arguments Type Intent Optional Attributes Name type( json_value ), , pointer :: from this is the structure to clone type( json_value ), , pointer :: to the clone is put here\n (it must not already be associated) type( json_value ), , optional pointer :: parent to%parent type( json_value ), , optional pointer :: previous to%previous type( json_value ), , optional pointer :: next to%next type( json_value ), , optional pointer :: children to%children logical , optional :: tail if \"to\" is the tail of its parent's children Description Recursive deep copy function called by json_clone . Note If new data is added to the json_value type,\n      then this would need to be updated. Called By proc~~json_value_clone_func~~CalledByGraph proc~json_value_clone_func json_value_clone_func proc~json_value_clone_func->proc~json_value_clone_func proc~json_clone json_clone proc~json_clone->proc~json_value_clone_func Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine json_value_clone_func ( from , to , parent , previous , next , children , tail ) implicit none type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here !! (it must not already be associated) type ( json_value ), pointer , optional :: parent !! to%parent type ( json_value ), pointer , optional :: previous !! to%previous type ( json_value ), pointer , optional :: next !! to%next type ( json_value ), pointer , optional :: children !! to%children logical , optional :: tail !! if \"to\" is the tail of its parent's children nullify ( to ) if ( associated ( from )) then allocate ( to ) !copy over the data variables: ! [note: the allocate() statements don't work here for the !  deferred-length characters in gfortran-4.9] if ( allocated ( from % name )) to % name = from % name if ( allocated ( from % dbl_value )) allocate ( to % dbl_value , source = from % dbl_value ) if ( allocated ( from % log_value )) allocate ( to % log_value , source = from % log_value ) if ( allocated ( from % str_value )) to % str_value = from % str_value if ( allocated ( from % int_value )) allocate ( to % int_value , source = from % int_value ) to % var_type = from % var_type to % n_children = from % n_children !allocate and associate the pointers as necessary: if ( present ( parent )) to % parent => parent if ( present ( previous )) to % previous => previous if ( present ( next )) to % next => next if ( present ( children )) to % children => children if ( present ( tail )) then if ( tail ) to % parent % tail => to end if if ( associated ( from % next )) then allocate ( to % next ) call json_value_clone_func ( from % next ,& to % next ,& previous = to ,& parent = to % parent ,& tail = (. not . associated ( from % next % next ))) end if if ( associated ( from % children )) then allocate ( to % children ) call json_value_clone_func ( from % children ,& to % children ,& parent = to ,& tail = (. not . associated ( from % children % next ))) end if end if end subroutine json_value_clone_func","tags":"","loc":"proc/json_value_clone_func.html","title":"json_value_clone_func â€“ JSON-Fortran"},{"text":"private subroutine destroy_json_data(d) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: d Description Destroy the data within a json_value , and reset type to json_unknown . Called By proc~~destroy_json_data~~CalledByGraph proc~destroy_json_data destroy_json_data proc~json_value_destroy json_value_destroy proc~json_value_destroy->proc~destroy_json_data proc~json_value_destroy->proc~json_value_destroy proc~to_null to_null proc~to_null->proc~destroy_json_data proc~to_array to_array proc~to_array->proc~destroy_json_data proc~to_string to_string proc~to_string->proc~destroy_json_data proc~to_integer to_integer proc~to_integer->proc~destroy_json_data proc~to_double to_double proc~to_double->proc~destroy_json_data proc~to_object to_object proc~to_object->proc~destroy_json_data proc~to_logical to_logical proc~to_logical->proc~destroy_json_data proc~parse_value parse_value proc~parse_value->proc~to_null proc~parse_value->proc~to_array proc~parse_value->proc~to_string proc~parse_value->proc~to_object proc~parse_value->proc~to_logical proc~json_value_create_null json_value_create_null proc~json_value_create_null->proc~to_null proc~json_value_create_array json_value_create_array proc~json_value_create_array->proc~to_array proc~json_update_string json_update_string proc~json_update_string->proc~to_string proc~json_value_create_string json_value_create_string proc~json_value_create_string->proc~to_string proc~json_value_create_integer json_value_create_integer proc~json_value_create_integer->proc~to_integer proc~json_update_integer json_update_integer proc~json_update_integer->proc~to_integer proc~parse_number parse_number proc~parse_number->proc~to_integer proc~parse_number->proc~to_double proc~json_update_double json_update_double proc~json_update_double->proc~to_double proc~json_value_create_double json_value_create_double proc~json_value_create_double->proc~to_double proc~json_value_create_object json_value_create_object proc~json_value_create_object->proc~to_object proc~json_update_logical json_update_logical proc~json_update_logical->proc~to_logical proc~json_value_create_logical json_value_create_logical proc~json_value_create_logical->proc~to_logical Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_json_data ( d ) implicit none type ( json_value ), intent ( inout ) :: d d % var_type = json_unknown if ( allocated ( d % log_value )) deallocate ( d % log_value ) if ( allocated ( d % int_value )) deallocate ( d % int_value ) if ( allocated ( d % dbl_value )) deallocate ( d % dbl_value ) if ( allocated ( d % str_value )) deallocate ( d % str_value ) end subroutine destroy_json_data","tags":"","loc":"proc/destroy_json_data.html","title":"destroy_json_data â€“ JSON-Fortran"},{"text":"private subroutine json_info(json, p, var_type, n_children, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Description Returns information about a json_value . Source Code subroutine json_info ( json , p , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name if ( present ( var_type )) var_type = p % var_type if ( present ( n_children )) n_children = json % count ( p ) if ( present ( name )) then if ( allocated ( p % name )) then name = p % name else name = '' end if end if end subroutine json_info","tags":"","loc":"proc/json_info.html","title":"json_info â€“ JSON-Fortran"},{"text":"private subroutine json_value_rename(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name Description Rename a json_value . Source Code subroutine json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! new variable name p % name = name end subroutine json_value_rename","tags":"","loc":"proc/json_value_rename.html","title":"json_value_rename â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_rename(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name new variable name Description Alternate version of json_value_rename , where name is kind=CDK. Calls proc~~wrap_json_value_rename~~CallsGraph proc~wrap_json_value_rename wrap_json_value_rename interface~to_unicode to_unicode proc~wrap_json_value_rename->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! new variable name call json % rename ( p , to_unicode ( name )) end subroutine wrap_json_value_rename","tags":"","loc":"proc/wrap_json_value_rename.html","title":"wrap_json_value_rename â€“ JSON-Fortran"},{"text":"private pure subroutine json_clear_exceptions(json) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json Description Clear exceptions in the json_core . Source Code pure subroutine json_clear_exceptions ( json ) implicit none class ( json_core ), intent ( inout ) :: json !clear the flag and message: json % exception_thrown = . false . json % err_message = '' end subroutine json_clear_exceptions","tags":"","loc":"proc/json_clear_exceptions.html","title":"json_clear_exceptions â€“ JSON-Fortran"},{"text":"private subroutine json_throw_exception(json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message Description Throw an exception in the json_core .\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. Note If is_verbose is true, this will also print a\n      traceback if the Intel compiler is used. Source Code subroutine json_throw_exception ( json , msg ) #ifdef __INTEL_COMPILER use ifcore , only : tracebackqq #endif implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: msg !! the error message json % exception_thrown = . true . json % err_message = trim ( msg ) if ( json % is_verbose ) then write ( output_unit , '(A)' ) '***********************' write ( output_unit , '(A)' ) 'JSON-Fortran Exception: ' // trim ( msg ) !call backtrace()     ! gfortran (use -fbacktrace -fall-intrinsics flags) #ifdef __INTEL_COMPILER call tracebackqq ( user_exit_code =- 1 ) ! print a traceback and return #endif write ( output_unit , '(A)' ) '***********************' end if end subroutine json_throw_exception","tags":"","loc":"proc/json_throw_exception.html","title":"json_throw_exception â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_throw_exception(json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: msg the error message Description Alternate version of json_throw_exception , where msg is kind=CDK. Calls proc~~wrap_json_throw_exception~~CallsGraph proc~wrap_json_throw_exception wrap_json_throw_exception interface~to_unicode to_unicode proc~wrap_json_throw_exception->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_throw_exception ( json , msg ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: msg !! the error message call json % throw_exception ( to_unicode ( msg )) end subroutine wrap_json_throw_exception","tags":"","loc":"proc/wrap_json_throw_exception.html","title":"wrap_json_throw_exception â€“ JSON-Fortran"},{"text":"private subroutine json_check_for_errors(json, status_ok, error_msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Description Retrieve error code from the json_core .\n  This should be called after parse to check for errors.\n  If an error is thrown, before using the class again, json_initialize should be called to clean up before it is used again. Example type ( json_file ) :: json logical :: status_ok character ( kind = CK , len = :), allocatable :: error_msg call json % load_file ( filename = 'myfile.json' ) call json % check_for_errors ( status_ok , error_msg ) if (. not . status_ok ) then write ( * , * ) 'Error: ' // error_msg call json % clear_exceptions () call json % destroy () end if See also json_failed Source Code subroutine json_check_for_errors ( json , status_ok , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) status_ok = . not . json % exception_thrown if (. not . status_ok ) then if ( allocated ( json % err_message )) then error_msg = json % err_message else error_msg = 'Unknown error.' end if else error_msg = '' end if end subroutine json_check_for_errors","tags":"","loc":"proc/json_check_for_errors.html","title":"json_check_for_errors â€“ JSON-Fortran"},{"text":"private subroutine json_value_create(p) Arguments Type Intent Optional Attributes Name type( json_value ), , pointer :: p Description Allocate a json_value pointer variable.\n  This should be called before adding data to it. Example type ( json_value ), pointer :: var call json_value_create ( var ) call to_double ( var , 1.0_RK ) Notes This routine does not check for exceptions. The pointer should not already be allocated, or a memory leak will occur. Called By proc~~json_value_create~~CalledByGraph proc~json_value_create json_value_create proc~parse_array parse_array proc~parse_array->proc~json_value_create proc~json_value_create_null json_value_create_null proc~json_value_create_null->proc~json_value_create proc~json_value_create_string json_value_create_string proc~json_value_create_string->proc~json_value_create proc~json_parse_string json_parse_string proc~json_parse_string->proc~json_value_create proc~json_value_create_logical json_value_create_logical proc~json_value_create_logical->proc~json_value_create proc~json_parse_file json_parse_file proc~json_parse_file->proc~json_value_create proc~parse_object parse_object proc~parse_object->proc~json_value_create proc~json_value_create_array json_value_create_array proc~json_value_create_array->proc~json_value_create proc~json_value_create_object json_value_create_object proc~json_value_create_object->proc~json_value_create proc~json_value_create_integer json_value_create_integer proc~json_value_create_integer->proc~json_value_create proc~json_value_create_double json_value_create_double proc~json_value_create_double->proc~json_value_create Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_create ( p ) implicit none type ( json_value ), pointer :: p nullify ( p ) allocate ( p ) end subroutine json_value_create","tags":"","loc":"proc/json_value_create.html","title":"json_value_create â€“ JSON-Fortran"},{"text":"private recursive subroutine json_value_destroy(json, p, destroy_next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) Description Destroy a json_value linked-list structure. Note The original FSON version of this\n      routine was not properly freeing the memory.\n      It was rewritten. Calls proc~~json_value_destroy~~CallsGraph proc~json_value_destroy json_value_destroy proc~json_value_destroy->proc~json_value_destroy proc~destroy_json_data destroy_json_data proc~json_value_destroy->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: des_next type( json_value ), public, pointer :: child Source Code recursive subroutine json_value_destroy ( json , p , destroy_next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! variable to destroy logical ( LK ), intent ( in ), optional :: destroy_next !! if true, then `p%next` !! is also destroyed (default is true) logical ( LK ) :: des_next type ( json_value ), pointer :: child if ( associated ( p )) then if ( present ( destroy_next )) then des_next = destroy_next else des_next = . true . end if if ( allocated ( p % name )) deallocate ( p % name ) call destroy_json_data ( p ) if ( associated ( p % children )) then do while ( p % n_children > 0 ) child => p % children if ( associated ( child )) then p % children => p % children % next p % n_children = p % n_children - 1 call json_value_destroy ( json , child ,. false .) else call json % throw_exception ( 'Error in json_value_destroy: ' // & 'Malformed JSON linked list' ) exit end if end do nullify ( p % children ) nullify ( child ) end if if ( associated ( p % next ) . and . des_next ) call json_value_destroy ( json , p % next ) if ( associated ( p % previous )) nullify ( p % previous ) if ( associated ( p % parent )) nullify ( p % parent ) if ( associated ( p % tail )) nullify ( p % tail ) deallocate ( p ) nullify ( p ) end if end subroutine json_value_destroy","tags":"","loc":"proc/json_value_destroy.html","title":"json_value_destroy â€“ JSON-Fortran"},{"text":"private subroutine json_value_remove(json, p, destroy) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. Description Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure. Examples To extract an object from one JSON structure, and add it to another: type ( json_core ) :: json type ( json_value ), pointer :: json1 , json2 , p logical :: found !create and populate json1 and json2 call json % get ( json1 , 'name' , p , found ) ! get pointer to name element of json1 call json % remove ( p , destroy = . false .) ! remove it from json1 (don't destroy) call json % add ( json2 , p ) ! add it to json2 To remove an object from a JSON structure (and destroy it): type ( json_core ) :: json type ( json_value ), pointer :: json1 , p logical :: found !create and populate json1 call json % get ( json1 , 'name' , p , found ) ! get pointer to name element of json1 call json % remove ( p ) ! remove and destroy it History Jacob Williams : 12/28/2014 : added destroy optional argument. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: parent type( json_value ), public, pointer :: previous type( json_value ), public, pointer :: next logical(kind=LK), public :: destroy_it Source Code subroutine json_value_remove ( json , p , destroy ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ), optional :: destroy !! If destroy is not present, it is also destroyed. !! If destroy is present and true, it is destroyed. !! If destroy is present and false, it is not destroyed. type ( json_value ), pointer :: parent , previous , next logical ( LK ) :: destroy_it if ( associated ( p )) then !optional input argument: if ( present ( destroy )) then destroy_it = destroy else destroy_it = . true . end if if ( associated ( p % parent )) then parent => p % parent if ( associated ( p % next )) then !there are later items in the list: next => p % next nullify ( p % next ) if ( associated ( p % previous )) then !there are earlier items in the list previous => p % previous previous % next => next next % previous => previous else !this is the first item in the list parent % children => next nullify ( next % previous ) end if else if ( associated ( p % previous )) then !there are earlier items in the list: previous => p % previous nullify ( previous % next ) parent % tail => previous else !this is the only item in the list: nullify ( parent % children ) nullify ( parent % tail ) end if end if parent % n_children = parent % n_children - 1 end if if ( destroy_it ) call json % destroy ( p ) end if end subroutine json_value_remove","tags":"","loc":"proc/json_value_remove.html","title":"json_value_remove â€“ JSON-Fortran"},{"text":"private subroutine json_value_swap(json, p1, p2) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p1 type( json_value ), , pointer :: p2 Description Swap two elements in a JSON structure.\n  All of the children are carried along as well. Note If both are not associated, then an error is thrown. Note The assumption here is that both variables are part of a valid json_value linked list (so the normal parent , previous , next , etc. pointers are properly associated if necessary). Warning This cannot be used to swap a parent/child pair, since that\n         could lead to a circular linkage. An exception is thrown if\n         this is tried. Warning There are also other situations where using this routine may\n         produce a malformed JSON structure, such as moving an array\n         element outside of an array. This is not checked for. Note If p1 and p2 have a common parent, it is always safe to swap them. Calls proc~~json_value_swap~~CallsGraph proc~json_value_swap json_value_swap none~swap_pointers swap_pointers proc~json_value_swap->none~swap_pointers Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: same_parent logical, public :: first_last logical, public :: adjacent type( json_value ), public, pointer :: a type( json_value ), public, pointer :: b Subroutines pure subroutine swap_pointers(s1, s2) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: s1 type( json_value ), intent(inout), pointer :: s2 Source Code subroutine json_value_swap ( json , p1 , p2 ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical :: same_parent , first_last , adjacent type ( json_value ), pointer :: a , b if ( json % exception_thrown ) return !both have to be associated: if ( associated ( p1 ) . and . associated ( p2 )) then !simple check to make sure that they both !aren't pointing to the same thing: if (. not . associated ( p1 , p2 )) then !we will not allow swapping an item with one of its descendants: if ( json % is_child_of ( p1 , p2 ) . or . json % is_child_of ( p2 , p1 )) then call json % throw_exception ( 'Error in json_value_swap: ' // & 'cannot swap an item with one of its descendants' ) else same_parent = ( associated ( p1 % parent ) . and . & associated ( p2 % parent ) . and . & associated ( p1 % parent , p2 % parent ) ) if ( same_parent ) then !if p1,p2 are the first,last or last,first !children of a common parent first_last = ( associated ( p1 % parent % children , p1 ) . and . & associated ( p2 % parent % tail , p2 )) . or . & ( associated ( p1 % parent % tail , p1 ) . and . & associated ( p2 % parent % children , p2 )) else first_last = . false . end if !first, we fix children,tail pointers: if ( same_parent . and . first_last ) then !this is all we have to do for the parent in this case: call swap_pointers ( p1 % parent % children , p2 % parent % tail ) else if ( same_parent . and . . not . first_last ) then if ( associated ( p1 % parent % children , p1 )) then p1 % parent % children => p2 ! p1 is the first child of the parent else if ( associated ( p1 % parent % children , p2 )) then p1 % parent % children => p1 ! p2 is the first child of the parent end if if ( associated ( p1 % parent % tail , p1 )) then p1 % parent % tail => p2 ! p1 is the last child of the parent else if ( associated ( p1 % parent % tail , p2 )) then p1 % parent % tail => p1 ! p2 is the last child of the parent end if else ! general case: different parents if ( associated ( p1 % parent )) then if ( associated ( p1 % parent % children , p1 )) p1 % parent % children => p2 if ( associated ( p1 % parent % tail , p1 )) p1 % parent % tail => p2 end if if ( associated ( p2 % parent )) then if ( associated ( p2 % parent % children , p2 )) p2 % parent % children => p1 if ( associated ( p2 % parent % tail , p2 )) p2 % parent % tail => p1 end if call swap_pointers ( p1 % parent , p2 % parent ) end if !now, have to fix previous,next pointers: !first, see if they are adjacent: adjacent = associated ( p1 % next , p2 ) . or . & associated ( p2 % next , p1 ) if ( associated ( p2 % next , p1 )) then !p2,p1 a => p2 b => p1 else !p1,p2 (or not adjacent) a => p1 b => p2 end if if ( associated ( a % previous )) a % previous % next => b if ( associated ( b % next )) b % next % previous => a if ( adjacent ) then !a comes before b in the original list b % previous => a % previous a % next => b % next a % previous => b b % next => a else if ( associated ( a % next )) a % next % previous => b if ( associated ( b % previous )) b % previous % next => a call swap_pointers ( a % previous , b % previous ) call swap_pointers ( a % next , b % next ) end if end if else call json % throw_exception ( 'Error in json_value_swap: ' // & 'both pointers must be associated' ) end if end if contains pure subroutine swap_pointers ( s1 , s2 ) implicit none type ( json_value ), pointer , intent ( inout ) :: s1 type ( json_value ), pointer , intent ( inout ) :: s2 type ( json_value ), pointer :: tmp !! temporary pointer if (. not . associated ( s1 , s2 )) then tmp => s1 s1 => s2 s2 => tmp end if end subroutine swap_pointers end subroutine json_value_swap","tags":"","loc":"proc/json_value_swap.html","title":"json_value_swap â€“ JSON-Fortran"},{"text":"private subroutine json_value_validate(json, p, is_valid, error_msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: is_valid True if the structure is valid. character(kind=CK,len=:), , allocatable :: error_msg if not valid, this will contain\n a description of the problem Description Validate a json_value linked list by checking to make sure\n  all the pointers are properly associated, arrays and objects\n  have the correct number of children, and the correct data is\n  allocated for the variable types. It recursively traverses the entire structure and checks every element. Note This routine does not check or throw any exceptions. Calls proc~~json_value_validate~~CallsGraph proc~json_value_validate json_value_validate none~check_if_valid check_if_valid proc~json_value_validate->none~check_if_valid none~check_if_valid->none~check_if_valid Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines recursive subroutine check_if_valid(p, require_parent) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: p logical, intent(in) :: require_parent the first one may be a root (so no parent),\n but all descendants must have a parent. Source Code subroutine json_value_validate ( json , p , is_valid , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: is_valid !! True if the structure is valid. character ( kind = CK , len = :), allocatable :: error_msg !! if not valid, this will contain !! a description of the problem if ( associated ( p )) then is_valid = . true . call check_if_valid ( p , require_parent = associated ( p % parent )) else error_msg = 'The pointer is not associated' is_valid = . false . end if contains recursive subroutine check_if_valid ( p , require_parent ) implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( in ) :: require_parent !! the first one may be a root (so no parent), !! but all descendants must have a parent. integer :: i !! counter type ( json_value ), pointer :: element type ( json_value ), pointer :: previous if ( is_valid . and . associated ( p )) then ! data type: select case ( p % var_type ) case ( json_null , json_object , json_array ) if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for ' // & 'json_null, json_object, or json_array variable type' is_valid = . false . return end if case ( json_logical ) if (. not . allocated ( p % log_value )) then error_msg = 'log_value should be allocated for json_logical variable type' is_valid = . false . return else if ( allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_logical variable type' is_valid = . false . return end if case ( json_integer ) if (. not . allocated ( p % int_value )) then error_msg = 'int_value should be allocated for json_integer variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_integer variable type' is_valid = . false . return end if case ( json_double ) if (. not . allocated ( p % dbl_value )) then error_msg = 'dbl_value should be allocated for json_double variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_double variable type' is_valid = . false . return end if case ( json_string ) if (. not . allocated ( p % str_value )) then error_msg = 'str_value should be allocated for json_string variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value )) then error_msg = 'incorrect data allocated for json_string variable type' is_valid = . false . return end if case default error_msg = 'invalid JSON variable type' is_valid = . false . return end select if ( require_parent . and . . not . associated ( p % parent )) then error_msg = 'parent pointer is not associated' is_valid = . false . return end if if (. not . allocated ( p % name )) then if ( associated ( p % parent )) then if ( p % parent % var_type /= json_array ) then error_msg = 'JSON variable must have a name if not an ' // & 'array element or the root' is_valid = . false . return end if end if end if if ( associated ( p % children ) . neqv . associated ( p % tail )) then error_msg = 'both children and tail pointers must be associated' is_valid = . false . return end if ! now, check next one: if ( associated ( p % next )) then call check_if_valid ( p % next , require_parent = require_parent ) end if if ( associated ( p % children )) then if ( p % var_type /= json_array . and . p % var_type /= json_object ) then error_msg = 'only arrays and objects can have children' is_valid = . false . return end if ! first validate children pointers: previous => null () element => p % children do i = 1 , p % n_children if (. not . associated ( element % parent , p )) then error_msg = 'child''s parent pointer not properly associated' is_valid = . false . return end if if ( i == 1 . and . associated ( element % previous )) then error_msg = 'first child shouldn''t have a previous' is_valid = . false . return end if if ( i < p % n_children . and . . not . associated ( element % next )) then error_msg = 'not enough children' is_valid = . false . return end if if ( i == p % n_children . and . associated ( element % next )) then error_msg = 'too many children' is_valid = . false . return end if if ( i > 1 ) then if (. not . associated ( previous , element % previous )) then error_msg = 'previous pointer not properly associated' is_valid = . false . return end if end if if ( i == p % n_children . and . & . not . associated ( element % parent % tail , element )) then error_msg = 'parent''s tail pointer not properly associated' is_valid = . false . return end if if ( i < p % n_children ) then !setup next case: previous => element element => element % next end if end do !now check all the children: call check_if_valid ( p % children , require_parent = . true .) end if end if end subroutine check_if_valid end subroutine json_value_validate","tags":"","loc":"proc/json_value_validate.html","title":"json_value_validate â€“ JSON-Fortran"},{"text":"private subroutine json_value_remove_if_present(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Given the path string, remove the variable from\n  the json_value structure, if it exists. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var logical(kind=LK), public :: found Source Code subroutine json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p_var logical ( LK ) :: found call json % get ( p , name , p_var , found ) if ( found ) call json % remove ( p_var ) end subroutine json_value_remove_if_present","tags":"","loc":"proc/json_value_remove_if_present.html","title":"json_value_remove_if_present â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_remove_if_present(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Alternate version of json_value_remove_if_present , where name is kind=CDK. Calls proc~~wrap_json_value_remove_if_present~~CallsGraph proc~wrap_json_value_remove_if_present wrap_json_value_remove_if_present interface~to_unicode to_unicode proc~wrap_json_value_remove_if_present->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % remove_if_present ( p , to_unicode ( name )) end subroutine wrap_json_value_remove_if_present","tags":"","loc":"proc/wrap_json_value_remove_if_present.html","title":"wrap_json_value_remove_if_present â€“ JSON-Fortran"},{"text":"private subroutine json_update_logical(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Calls proc~~json_update_logical~~CallsGraph proc~json_update_logical json_update_logical proc~to_logical to_logical proc~json_update_logical->proc~to_logical proc~destroy_json_data destroy_json_data proc~to_logical->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var integer(kind=IK), public :: var_type Source Code subroutine json_update_logical ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_logical ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_logical: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_logical","tags":"","loc":"proc/json_update_logical.html","title":"json_update_logical â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_update_logical(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_logical , where name is kind=CDK. Calls proc~~wrap_json_update_logical~~CallsGraph proc~wrap_json_update_logical wrap_json_update_logical interface~to_unicode to_unicode proc~wrap_json_update_logical->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_update_logical ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_logical","tags":"","loc":"proc/wrap_json_update_logical.html","title":"wrap_json_update_logical â€“ JSON-Fortran"},{"text":"private subroutine json_update_double(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Calls proc~~json_update_double~~CallsGraph proc~json_update_double json_update_double proc~to_double to_double proc~json_update_double->proc~to_double proc~destroy_json_data destroy_json_data proc~to_double->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var integer(kind=IK), public :: var_type Source Code subroutine json_update_double ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_double ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_double: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_double","tags":"","loc":"proc/json_update_double.html","title":"json_update_double â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_update_double(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_double , where name is kind=CDK. Calls proc~~wrap_json_update_double~~CallsGraph proc~wrap_json_update_double wrap_json_update_double interface~to_unicode to_unicode proc~wrap_json_update_double->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_update_double ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_double","tags":"","loc":"proc/wrap_json_update_double.html","title":"wrap_json_update_double â€“ JSON-Fortran"},{"text":"private subroutine json_update_integer(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Calls proc~~json_update_integer~~CallsGraph proc~json_update_integer json_update_integer proc~to_integer to_integer proc~json_update_integer->proc~to_integer proc~destroy_json_data destroy_json_data proc~to_integer->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var integer(kind=IK), public :: var_type Source Code subroutine json_update_integer ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_integer ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_integer: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_integer","tags":"","loc":"proc/json_update_integer.html","title":"json_update_integer â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_update_integer(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_integer , where name is kind=CDK. Calls proc~~wrap_json_update_integer~~CallsGraph proc~wrap_json_update_integer wrap_json_update_integer interface~to_unicode to_unicode proc~wrap_json_update_integer->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_update_integer ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_integer","tags":"","loc":"proc/wrap_json_update_integer.html","title":"wrap_json_update_integer â€“ JSON-Fortran"},{"text":"private subroutine json_update_string(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Calls proc~~json_update_string~~CallsGraph proc~json_update_string json_update_string proc~to_string to_string proc~json_update_string->proc~to_string proc~destroy_json_data destroy_json_data proc~to_string->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var integer(kind=IK), public :: var_type Source Code subroutine json_update_string ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_string ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_string: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_string","tags":"","loc":"proc/json_update_string.html","title":"json_update_string â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_update_string(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where name and value are kind=CDK. Calls proc~~wrap_json_update_string~~CallsGraph proc~wrap_json_update_string wrap_json_update_string interface~to_unicode to_unicode proc~wrap_json_update_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_update_string ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_update_string","tags":"","loc":"proc/wrap_json_update_string.html","title":"wrap_json_update_string â€“ JSON-Fortran"},{"text":"private subroutine json_update_string_name_ascii(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where name is kind=CDK. Calls proc~~json_update_string_name_ascii~~CallsGraph proc~json_update_string_name_ascii json_update_string_name_ascii interface~to_unicode to_unicode proc~json_update_string_name_ascii->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_update_string_name_ascii ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine json_update_string_name_ascii","tags":"","loc":"proc/json_update_string_name_ascii.html","title":"json_update_string_name_ascii â€“ JSON-Fortran"},{"text":"private subroutine json_update_string_val_ascii(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where val is kind=CDK. Calls proc~~json_update_string_val_ascii~~CallsGraph proc~json_update_string_val_ascii json_update_string_val_ascii interface~to_unicode to_unicode proc~json_update_string_val_ascii->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_update_string_val_ascii ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , name , to_unicode ( val ), found ) end subroutine json_update_string_val_ascii","tags":"","loc":"proc/json_update_string_val_ascii.html","title":"json_update_string_val_ascii â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_member(json, p, member) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p type( json_value ), , pointer :: member the child member to add Description Adds member as a child of p . Source Code subroutine json_value_add_member ( json , p , member ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p type ( json_value ), pointer :: member !! the child member to add if (. not . json % exception_thrown ) then ! associate the parent member % parent => p ! add to linked list if ( associated ( p % children )) then p % tail % next => member member % previous => p % tail else p % children => member member % previous => null () !first in the list end if ! new member is now the last one in the list p % tail => member p % n_children = p % n_children + 1 end if end subroutine json_value_add_member","tags":"","loc":"proc/json_value_add_member.html","title":"json_value_add_member â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_double(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Add a real value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var Source Code subroutine json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value type ( json_value ), pointer :: var !create the variable: call json % create_double ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_double","tags":"","loc":"proc/json_value_add_double.html","title":"json_value_add_double â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_add_double(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Alternate version of json_value_add_double where name is kind=CDK. Calls proc~~wrap_json_value_add_double~~CallsGraph proc~wrap_json_value_add_double wrap_json_value_add_double interface~to_unicode to_unicode proc~wrap_json_value_add_double->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double","tags":"","loc":"proc/wrap_json_value_add_double.html","title":"wrap_json_value_add_double â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_double_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Add a real vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var integer(kind=IK), public :: i counter Source Code subroutine json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_double_vec","tags":"","loc":"proc/json_value_add_double_vec.html","title":"json_value_add_double_vec â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_add_double_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Alternate version of json_value_add_double_vec where name is kind=CDK. Calls proc~~wrap_json_value_add_double_vec~~CallsGraph proc~wrap_json_value_add_double_vec wrap_json_value_add_double_vec interface~to_unicode to_unicode proc~wrap_json_value_add_double_vec->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double_vec","tags":"","loc":"proc/wrap_json_value_add_double_vec.html","title":"wrap_json_value_add_double_vec â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_integer(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val Description Add an integer value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var Source Code subroutine json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val type ( json_value ), pointer :: var !create the variable: call json % create_integer ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_integer","tags":"","loc":"proc/json_value_add_integer.html","title":"json_value_add_integer â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_add_integer(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in) :: val value Description Alternate version of json_value_add_integer where name is kind=CDK. Calls proc~~wrap_json_value_add_integer~~CallsGraph proc~wrap_json_value_add_integer wrap_json_value_add_integer interface~to_unicode to_unicode proc~wrap_json_value_add_integer->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer","tags":"","loc":"proc/wrap_json_value_add_integer.html","title":"wrap_json_value_add_integer â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_integer_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Add an integer vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var integer(kind=IK), public :: i counter Source Code subroutine json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create a variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_integer_vec","tags":"","loc":"proc/json_value_add_integer_vec.html","title":"json_value_add_integer_vec â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_add_integer_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_integer_vec where name is kind=CDK. Calls proc~~wrap_json_value_add_integer_vec~~CallsGraph proc~wrap_json_value_add_integer_vec wrap_json_value_add_integer_vec interface~to_unicode to_unicode proc~wrap_json_value_add_integer_vec->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer_vec","tags":"","loc":"proc/wrap_json_value_add_integer_vec.html","title":"wrap_json_value_add_integer_vec â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_logical(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Add a logical value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var Source Code subroutine json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value type ( json_value ), pointer :: var !create the variable: call json % create_logical ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_logical","tags":"","loc":"proc/json_value_add_logical.html","title":"json_value_add_logical â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_add_logical(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Alternate version of json_value_add_logical where name is kind=CDK. Calls proc~~wrap_json_value_add_logical~~CallsGraph proc~wrap_json_value_add_logical wrap_json_value_add_logical interface~to_unicode to_unicode proc~wrap_json_value_add_logical->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical","tags":"","loc":"proc/wrap_json_value_add_logical.html","title":"wrap_json_value_add_logical â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_logical_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value Description Add a logical vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var integer(kind=IK), public :: i counter Source Code subroutine json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the vector logical ( LK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_logical_vec","tags":"","loc":"proc/json_value_add_logical_vec.html","title":"json_value_add_logical_vec â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_add_logical_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_logical_vec where name is kind=CDK. Calls proc~~wrap_json_value_add_logical_vec~~CallsGraph proc~wrap_json_value_add_logical_vec wrap_json_value_add_logical_vec interface~to_unicode to_unicode proc~wrap_json_value_add_logical_vec->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical_vec","tags":"","loc":"proc/wrap_json_value_add_logical_vec.html","title":"wrap_json_value_add_logical_vec â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_string(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Add a character string child to the json_value variable. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Calls proc~~json_value_add_string~~CallsGraph proc~json_value_add_string json_value_add_string proc~escape_string escape_string proc~json_value_add_string->proc~escape_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var character(kind=CK,len=:), public, allocatable :: str Source Code subroutine json_value_add_string ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value type ( json_value ), pointer :: var character ( kind = CK , len = :), allocatable :: str !add escape characters if necessary: call escape_string ( val , str ) !create the variable: call json % create_string ( var , str , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_string","tags":"","loc":"proc/json_value_add_string.html","title":"json_value_add_string â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_add_string(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where name and val are kind=CDK. Calls proc~~wrap_json_value_add_string~~CallsGraph proc~wrap_json_value_add_string wrap_json_value_add_string interface~to_unicode to_unicode proc~wrap_json_value_add_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_add_string ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), to_unicode ( val )) end subroutine wrap_json_value_add_string","tags":"","loc":"proc/wrap_json_value_add_string.html","title":"wrap_json_value_add_string â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_string_name_ascii(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where name is kind=CDK. Calls proc~~json_value_add_string_name_ascii~~CallsGraph proc~json_value_add_string_name_ascii json_value_add_string_name_ascii interface~to_unicode to_unicode proc~json_value_add_string_name_ascii->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_add_string_name_ascii ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine json_value_add_string_name_ascii","tags":"","loc":"proc/json_value_add_string_name_ascii.html","title":"json_value_add_string_name_ascii â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_string_val_ascii(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where val is kind=CDK. Calls proc~~json_value_add_string_val_ascii~~CallsGraph proc~json_value_add_string_val_ascii json_value_add_string_val_ascii interface~to_unicode to_unicode proc~json_value_add_string_val_ascii->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_add_string_val_ascii ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json % add ( p , name , to_unicode ( val )) end subroutine json_value_add_string_val_ascii","tags":"","loc":"proc/json_value_add_string_val_ascii.html","title":"json_value_add_string_val_ascii â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_string_vec(json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Description Add an array of character strings to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var integer(kind=IK), public :: i logical(kind=LK), public :: trim_string logical(kind=LK), public :: adjustl_string character(kind=CK,len=:), public, allocatable :: str Source Code subroutine json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val !! array of strings logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: var integer ( IK ) :: i logical ( LK ) :: trim_string , adjustl_string character ( kind = CK , len = :), allocatable :: str !if the string is to be trimmed or not: if ( present ( trim_str )) then trim_string = trim_str else trim_string = . false . end if if ( present ( adjustl_str )) then adjustl_string = adjustl_str else adjustl_string = . false . end if !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) !the string to write: str = val ( i ) if ( adjustl_string ) str = adjustl ( str ) if ( trim_string ) str = trim ( str ) !write it: call json % add ( var , '' , str ) !cleanup deallocate ( str ) end do !add it: call json % add ( p , var ) end subroutine json_value_add_string_vec","tags":"","loc":"proc/json_value_add_string_vec.html","title":"json_value_add_string_vec â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_add_string_vec(json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where name and val are kind=CDK. Calls proc~~wrap_json_value_add_string_vec~~CallsGraph proc~wrap_json_value_add_string_vec wrap_json_value_add_string_vec interface~to_unicode to_unicode proc~wrap_json_value_add_string_vec->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string_vec","tags":"","loc":"proc/wrap_json_value_add_string_vec.html","title":"wrap_json_value_add_string_vec â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_string_vec_name_ascii(json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where name is kind=CDK. Calls proc~~json_value_add_string_vec_name_ascii~~CallsGraph proc~json_value_add_string_vec_name_ascii json_value_add_string_vec_name_ascii interface~to_unicode to_unicode proc~json_value_add_string_vec_name_ascii->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_add_string_vec_name_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_vec_name_ascii","tags":"","loc":"proc/json_value_add_string_vec_name_ascii.html","title":"json_value_add_string_vec_name_ascii â€“ JSON-Fortran"},{"text":"private subroutine json_value_add_string_vec_val_ascii(json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where val is kind=CDK. Calls proc~~json_value_add_string_vec_val_ascii~~CallsGraph proc~json_value_add_string_vec_val_ascii json_value_add_string_vec_val_ascii interface~to_unicode to_unicode proc~json_value_add_string_vec_val_ascii->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_add_string_vec_val_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_vec_val_ascii","tags":"","loc":"proc/json_value_add_string_vec_val_ascii.html","title":"json_value_add_string_vec_val_ascii â€“ JSON-Fortran"},{"text":"private subroutine json_get_parent(json, p, parent) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: parent pointer to parent Description Returns a pointer to the parent of a json_value .\n  If there is no parent, then a null() pointer is returned. Source Code subroutine json_get_parent ( json , p , parent ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: parent !! pointer to parent if ( associated ( p )) then parent => p % parent else nullify ( parent ) call json % throw_exception ( 'Error in json_get_parent: ' // & 'pointer is not associated.' ) end if end subroutine json_get_parent","tags":"","loc":"proc/json_get_parent.html","title":"json_get_parent â€“ JSON-Fortran"},{"text":"private subroutine json_get_next(json, p, next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: next pointer to next Description Returns a pointer to the next of a json_value .\n  If there is no next, then a null() pointer is returned. Source Code subroutine json_get_next ( json , p , next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: next !! pointer to next if ( associated ( p )) then next => p % next else nullify ( next ) call json % throw_exception ( 'Error in json_get_next: ' // & 'pointer is not associated.' ) end if end subroutine json_get_next","tags":"","loc":"proc/json_get_next.html","title":"json_get_next â€“ JSON-Fortran"},{"text":"private subroutine json_get_previous(json, p, previous) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: previous pointer to previous Description Returns a pointer to the previous of a json_value .\n  If there is no previous, then a null() pointer is returned. Source Code subroutine json_get_previous ( json , p , previous ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: previous !! pointer to previous if ( associated ( p )) then previous => p % previous else nullify ( previous ) call json % throw_exception ( 'Error in json_get_previous: ' // & 'pointer is not associated.' ) end if end subroutine json_get_previous","tags":"","loc":"proc/json_get_previous.html","title":"json_get_previous â€“ JSON-Fortran"},{"text":"private subroutine json_get_tail(json, p, tail) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: tail pointer to tail Description Returns a pointer to the tail of a json_value (the last child of an array of object).\n  If there is no tail, then a null() pointer is returned. Source Code subroutine json_get_tail ( json , p , tail ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: tail !! pointer to tail if ( associated ( p )) then tail => p % tail else nullify ( tail ) call json % throw_exception ( 'Error in json_get_tail: ' // & 'pointer is not associated.' ) end if end subroutine json_get_tail","tags":"","loc":"proc/json_get_tail.html","title":"json_get_tail â€“ JSON-Fortran"},{"text":"private subroutine json_value_get_by_index(json, p, idx, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child type( json_value ), , pointer :: child pointer to the child Description Returns a child in the object or array given the index. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i Source Code subroutine json_value_get_by_index ( json , p , idx , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data integer ( IK ), intent ( in ) :: idx !! index of the child type ( json_value ), pointer :: child !! pointer to the child integer ( IK ) :: i nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p % children )) then child => p % children do i = 1 , idx - 1 if ( associated ( child % next )) then child => child % next else call json % throw_exception ( 'Error in json_value_get_by_index:' // & ' child%next is not associated.' ) nullify ( child ) return end if end do else call json % throw_exception ( 'Error in json_value_get_by_index:' // & ' p%children is not associated.' ) end if end if end subroutine json_value_get_by_index","tags":"","loc":"proc/json_value_get_by_index.html","title":"json_value_get_by_index â€“ JSON-Fortran"},{"text":"private subroutine json_value_get_child(json, p, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), , pointer :: child pointer to the child Description Returns pointer to the first child of the object\n  (or null() if it is not associated). Source Code subroutine json_value_get_child ( json , p , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data type ( json_value ), pointer :: child !! pointer to the child if ( associated ( p )) then child => p % children else nullify ( child ) call json % throw_exception ( 'Error in json_value_get_child: ' // & 'pointer is not associated.' ) end if end subroutine json_value_get_child","tags":"","loc":"proc/json_value_get_child.html","title":"json_value_get_child â€“ JSON-Fortran"},{"text":"private subroutine json_value_get_by_name_chars(json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), , pointer :: child pointer to the child Description Returns a child in the object or array given the name string. The name search can be case-sensitive or not, and can have significant trailing\n  whitespace or not, depending on the settings in the json_core class. Note The name input is not a path, and is not parsed like it is in json_get_by_path . Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i integer(kind=IK), public :: n_children Source Code subroutine json_value_get_by_name_chars ( json , p , name , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! the name of a child of `p` type ( json_value ), pointer :: child !! pointer to the child integer ( IK ) :: i , n_children nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p )) then if ( p % var_type == json_object ) then n_children = json % count ( p ) child => p % children !start with first one do i = 1 , n_children if (. not . associated ( child )) then call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'Malformed JSON linked list' ) return end if if ( allocated ( child % name )) then !name string matching routine: if ( json % name_equal ( child , name )) return end if child => child % next end do end if !did not find anything: call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'child variable ' // trim ( name ) // ' was not found.' ) nullify ( child ) else call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'pointer is not associated.' ) end if end if end subroutine json_value_get_by_name_chars","tags":"","loc":"proc/json_value_get_by_name_chars.html","title":"json_value_get_by_name_chars â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_get_by_name_chars(json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name type( json_value ), , pointer :: child Description Alternate version of json_value_get_by_name_chars where name is kind=CDK. Calls proc~~wrap_json_value_get_by_name_chars~~CallsGraph proc~wrap_json_value_get_by_name_chars wrap_json_value_get_by_name_chars interface~to_unicode to_unicode proc~wrap_json_value_get_by_name_chars->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_get_by_name_chars ( json , p , name , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: child call json % get ( p , to_unicode ( name ), child ) end subroutine wrap_json_value_get_by_name_chars","tags":"","loc":"proc/wrap_json_value_get_by_name_chars.html","title":"wrap_json_value_get_by_name_chars â€“ JSON-Fortran"},{"text":"private subroutine json_value_to_string(json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string Description Print the json_value structure to an allocatable string. Source Code subroutine json_value_to_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len = :), intent ( out ), allocatable :: str !! prints structure to this string str = '' call json % json_value_print ( p , iunit = unit2str , str = str , indent = 1 , colon = . true .) end subroutine json_value_to_string","tags":"","loc":"proc/json_value_to_string.html","title":"json_value_to_string â€“ JSON-Fortran"},{"text":"private subroutine json_print_1(json, p, iunit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must already have been opened, can't be -1). Description Print the json_value structure to a file. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: dummy Source Code subroutine json_print_1 ( json , p , iunit ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! the file unit (the file must already have been opened, can't be -1). character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then call json % json_value_print ( p , iunit , str = dummy , indent = 1 , colon = . true .) else call json % throw_exception ( 'Error in json_print_1: iunit must not be -1.' ) end if end subroutine json_print_1","tags":"","loc":"proc/json_print_1.html","title":"json_print_1 â€“ JSON-Fortran"},{"text":"private subroutine json_print_2(json, p, filename) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to (should not already be open) Description Print the json_value structure to a file. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: iunit integer(kind=IK), public :: istat Source Code subroutine json_print_2 ( json , p , filename ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to print to (should not already be open) integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call json % print ( p , iunit ) close ( iunit , iostat = istat ) else call json % throw_exception ( 'Error in json_print_2: could not open file: ' // & trim ( filename )) end if end subroutine json_print_2","tags":"","loc":"proc/json_print_2.html","title":"json_print_2 â€“ JSON-Fortran"},{"text":"private recursive subroutine json_value_print(json, p, iunit, str, indent, need_comma, colon, is_array_element) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit file unit to write to (6=console) character(kind=CK,len=:), intent(inout), allocatable :: str if iunit==unit2str (-1) then the structure is\n printed to this string rather than\n a file. This mode is used by json_value_to_string . integer(kind=IK), intent(in), optional :: indent indention level logical(kind=LK), intent(in), optional :: need_comma if it needs a comma after it logical(kind=LK), intent(in), optional :: colon if the colon was just written logical(kind=LK), intent(in), optional :: is_array_element if this is an array element Description Print the JSON structure to a string or a file. Notes This is an internal routine called by the various wrapper routines. The reason the str argument is non-optional is because of a\n    bug in v4.9 of the gfortran compiler. Calls proc~~json_value_print~~CallsGraph proc~json_value_print json_value_print proc~integer_to_string integer_to_string proc~json_value_print->proc~integer_to_string none~write_it write_it proc~json_value_print->none~write_it proc~real_to_string real_to_string proc~json_value_print->proc~real_to_string proc~compact_real_string compact_real_string proc~real_to_string->proc~compact_real_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CK,len=max_numeric_str_len), public :: tmp character(kind=CK,len=:), public, allocatable :: s type( json_value ), public, pointer :: element integer(kind=IK), public :: tab integer(kind=IK), public :: i integer(kind=IK), public :: count integer(kind=IK), public :: spaces logical(kind=LK), public :: print_comma logical(kind=LK), public :: write_file logical(kind=LK), public :: write_string logical(kind=LK), public :: is_array Subroutines subroutine write_it(s, advance, comma) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s string to print logical(kind=LK), intent(in), optional :: advance to add line break or not logical(kind=LK), intent(in), optional :: comma print comma after the string Description write the string to the file (or the output string) Source Code recursive subroutine json_value_print ( json , p , iunit , str , indent ,& need_comma , colon , is_array_element ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! file unit to write to (6=console) integer ( IK ), intent ( in ), optional :: indent !! indention level logical ( LK ), intent ( in ), optional :: is_array_element !! if this is an array element logical ( LK ), intent ( in ), optional :: need_comma !! if it needs a comma after it logical ( LK ), intent ( in ), optional :: colon !! if the colon was just written character ( kind = CK , len = :), intent ( inout ), allocatable :: str !! if iunit==unit2str (-1) then the structure is !! printed to this string rather than !! a file. This mode is used by !! [[json_value_to_string]]. character ( kind = CK , len = max_numeric_str_len ) :: tmp !for val to string conversions character ( kind = CK , len = :), allocatable :: s type ( json_value ), pointer :: element integer ( IK ) :: tab , i , count , spaces logical ( LK ) :: print_comma logical ( LK ) :: write_file , write_string logical ( LK ) :: is_array if (. not . json % exception_thrown ) then !whether to write a string or a file (one or the other): write_string = ( iunit == unit2str ) write_file = . not . write_string !if the comma will be printed after the value ! [comma not printed for the last elements] if ( present ( need_comma )) then print_comma = need_comma else print_comma = . false . end if !number of \"tabs\" to indent: if ( present ( indent )) then tab = indent else tab = 0 end if !convert to number of spaces: spaces = tab * json % spaces_per_tab !if this is an element in an array: if ( present ( is_array_element )) then is_array = is_array_element else is_array = . false . end if !if the colon was the last thing written if ( present ( colon )) then s = '' else s = repeat ( space , spaces ) end if select case ( p % var_type ) case ( json_object ) count = json % count ( p ) if ( count == 0 ) then !special case for empty object call write_it ( s // start_object // end_object , comma = print_comma ) else call write_it ( s // start_object ) !if an object is in an array, there is an extra tab: if ( is_array ) then tab = tab + 1 spaces = tab * json % spaces_per_tab end if nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! print the name if ( allocated ( element % name )) then call write_it ( repeat ( space , spaces ) // quotation_mark // & element % name // quotation_mark // colon_char // space ,& advance = . false .) else call json % throw_exception ( 'Error in json_value_print:' // & ' element%name not allocated' ) nullify ( element ) return end if ! recursive print of the element call json % json_value_print ( element , iunit = iunit , indent = tab + 1 , & need_comma = i < count , colon = . true ., str = str ) ! get the next child the list: element => element % next end do ! [one fewer tab if it isn't an array element] if (. not . is_array ) s = repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) call write_it ( s // end_object , comma = print_comma ) nullify ( element ) end if case ( json_array ) count = json % count ( p ) if ( count == 0 ) then !special case for empty array call write_it ( s // start_array // end_array , comma = print_comma ) else call write_it ( start_array ) nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! recursive print of the element call json % json_value_print ( element , iunit = iunit , indent = tab ,& need_comma = i < count , is_array_element = . true ., str = str ) ! get the next child the list: element => element % next end do !indent the closing array character: call write_it ( repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) // end_array ,& comma = print_comma ) nullify ( element ) end if case ( json_null ) call write_it ( s // null_str , comma = print_comma ) case ( json_string ) if ( allocated ( p % str_value )) then call write_it ( s // quotation_mark // & trim ( p % str_value ) // quotation_mark , comma = print_comma ) else call json % throw_exception ( 'Error in json_value_print:' // & ' p%value_string not allocated' ) return end if case ( json_logical ) if ( p % log_value ) then call write_it ( s // true_str , comma = print_comma ) else call write_it ( s // false_str , comma = print_comma ) end if case ( json_integer ) call integer_to_string ( p % int_value , int_fmt , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma ) case ( json_double ) if ( allocated ( json % real_fmt )) then call real_to_string ( p % dbl_value , json % real_fmt , json % compact_real , tmp ) else !use the default format (user has not called initialize() or specified one): call real_to_string ( p % dbl_value , default_real_fmt , json % compact_real , tmp ) end if call write_it ( s // trim ( tmp ), comma = print_comma ) case default call json % throw_exception ( 'Error in json_value_print: unknown data type' ) end select !cleanup: if ( allocated ( s )) deallocate ( s ) end if contains subroutine write_it ( s , advance , comma ) !! write the string to the file (or the output string) implicit none character ( kind = CK , len =* ), intent ( in ) :: s !! string to print logical ( LK ), intent ( in ), optional :: advance !! to add line break or not logical ( LK ), intent ( in ), optional :: comma !! print comma after the string logical ( LK ) :: add_line_break , add_comma character ( kind = CK , len = :), allocatable :: s2 if ( present ( comma )) then add_comma = comma else add_comma = . false . !default is not to add comma end if if ( present ( advance )) then add_line_break = advance else add_line_break = . true . !default is to advance end if !string to print: s2 = s if ( add_comma ) s2 = s2 // delimiter if ( write_file ) then if ( add_line_break ) then write ( iunit , fmt = '(A)' ) s2 else write ( iunit , fmt = '(A)' , advance = 'NO' ) s2 end if else !write string str = str // s2 if ( add_line_break ) str = str // newline end if !cleanup: if ( allocated ( s2 )) deallocate ( s2 ) end subroutine write_it end subroutine json_value_print","tags":"","loc":"proc/json_value_print.html","title":"json_value_print â€“ JSON-Fortran"},{"text":"private subroutine json_get_by_path(json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable specify by path logical(kind=LK), intent(out), optional :: found true if it was found Description Returns the json_value pointer given the path string. Example type ( json_value ), pointer :: dat , p logical :: found !... call json % get ( dat , 'data(2).version' , p , found ) Notes The following special characters are used to denote paths: $         - root\n  @         - this\n  .         - child object member\n  [] or ()  - child array element Thus, if any of these characters are present in the name key,\n  this routine cannot be used to get the value.\n  In that case, the get_child methods would need to be used. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i integer(kind=IK), public :: length integer(kind=IK), public :: child_i character(kind=CK,len=1), public :: c logical(kind=LK), public :: array type( json_value ), public, pointer :: tmp Source Code subroutine json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ) :: i integer ( IK ) :: length integer ( IK ) :: child_i character ( kind = CK , len = 1 ) :: c logical ( LK ) :: array type ( json_value ), pointer :: tmp nullify ( p ) if (. not . json % exception_thrown ) then ! default to assuming relative to this p => me child_i = 1 array = . false . !keep trailing space or not: if ( json % trailing_spaces_significant ) then length = len ( path ) else length = len_trim ( path ) end if do i = 1 , length c = path ( i : i ) select case ( c ) case ( root ) ! root do while ( associated ( p % parent )) p => p % parent end do child_i = i + 1 case ( this ) ! this p => me child_i = i + 1 case ( child ) ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path:' // & ' Error getting child member.' ) exit end if child_i = i + 1 case ( start_array , start_array_alt ) !....Modified to allow for 'var[3]' style syntax !Note: jmozmoz/fson has a slightly different version of this... ! start looking for the array element index array = . true . ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path:' // & ' Error getting array element' ) exit end if child_i = i + 1 case ( end_array , end_array_alt ) if (. not . array ) then call json % throw_exception ( 'Error in json_get_by_path: Unexpected ]' ) exit end if array = . false . child_i = json % string_to_integer ( path ( child_i : i - 1 )) nullify ( tmp ) call json % get_child ( p , child_i , tmp ) p => tmp nullify ( tmp ) child_i = i + 1 end select end do if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else ! grab the last child if present in the path if ( child_i <= length ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) end if if ( associated ( p )) then if ( present ( found )) found = . true . !everything seems to be ok else call json % throw_exception ( 'Error in json_get_by_path:' // & ' variable not found: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if end if else if ( present ( found )) found = . false . end if end subroutine json_get_by_path","tags":"","loc":"proc/json_get_by_path.html","title":"json_get_by_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_by_path(json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_by_path where \"path\" is kind=CDK. Calls proc~~wrap_json_get_by_path~~CallsGraph proc~wrap_json_get_by_path wrap_json_get_by_path interface~to_unicode to_unicode proc~wrap_json_get_by_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_get_by_path","tags":"","loc":"proc/wrap_json_get_by_path.html","title":"wrap_json_get_by_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_integer(json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value Description Get an integer value from a json_value . Source Code subroutine json_get_integer ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( out ) :: value value = 0 if ( json % exception_thrown ) return if ( me % var_type == json_integer ) then value = me % int_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_double ) value = int ( me % dbl_value ) case ( json_logical ) if ( me % log_value ) then value = 1 else value = 0 end if case default call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) end select end if end if end subroutine json_get_integer","tags":"","loc":"proc/json_get_integer.html","title":"json_get_integer â€“ JSON-Fortran"},{"text":"private subroutine json_get_integer_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get an integer value from a json_value , given the path string. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_integer_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0 if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_integer:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_integer_with_path","tags":"","loc":"proc/json_get_integer_with_path.html","title":"json_get_integer_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_integer_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_with_path , where \"path\" is kind=CDK. Calls proc~~wrap_json_get_integer_with_path~~CallsGraph proc~wrap_json_get_integer_with_path wrap_json_get_integer_with_path interface~to_unicode to_unicode proc~wrap_json_get_integer_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_integer_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_integer_with_path","tags":"","loc":"proc/wrap_json_get_integer_with_path.html","title":"wrap_json_get_integer_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_integer_vec(json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec Description Get an integer vector from a json_value . Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_int_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description callback function for integer Source Code subroutine json_get_integer_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_int_from_array ) contains subroutine get_int_from_array ( json , element , i , count ) !! callback function for integer implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec","tags":"","loc":"proc/json_get_integer_vec.html","title":"json_get_integer_vec â€“ JSON-Fortran"},{"text":"private subroutine json_get_integer_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get an integer vector from a json_value , given the path string. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_int_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description callback function for integer Source Code subroutine json_get_integer_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . call json % get ( me , path = path , array_callback = get_int_from_array , found = found ) ! need to duplicate callback function, no other way contains subroutine get_int_from_array ( json , element , i , count ) !! callback function for integer implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec_with_path","tags":"","loc":"proc/json_get_integer_vec_with_path.html","title":"json_get_integer_vec_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_integer_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_vec_with_path , where \"path\" is kind=CDK Calls proc~~wrap_json_get_integer_vec_with_path~~CallsGraph proc~wrap_json_get_integer_vec_with_path wrap_json_get_integer_vec_with_path interface~to_unicode to_unicode proc~wrap_json_get_integer_vec_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_integer_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , path = to_unicode ( path ), vec = vec , found = found ) end subroutine wrap_json_get_integer_vec_with_path","tags":"","loc":"proc/wrap_json_get_integer_vec_with_path.html","title":"wrap_json_get_integer_vec_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_double(json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out) :: value Description Get a double value from a json_value . Source Code subroutine json_get_double ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), intent ( out ) :: value value = 0.0_RK if ( json % exception_thrown ) return if ( me % var_type == json_double ) then value = me % dbl_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_logical ) if ( me % log_value ) then value = 1.0_RK else value = 0.0_RK end if case default call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) end select end if end if end subroutine json_get_double","tags":"","loc":"proc/json_get_double.html","title":"json_get_double â€“ JSON-Fortran"},{"text":"private subroutine json_get_double_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get a double value from a json_value , given the path. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_double_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0.0_RK if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_double_with_path","tags":"","loc":"proc/json_get_double_with_path.html","title":"json_get_double_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_double_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_with_path , where \"path\" is kind=CDK Calls proc~~wrap_json_get_double_with_path~~CallsGraph proc~wrap_json_get_double_with_path wrap_json_get_double_with_path interface~to_unicode to_unicode proc~wrap_json_get_double_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_double_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_double_with_path","tags":"","loc":"proc/wrap_json_get_double_with_path.html","title":"wrap_json_get_double_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_double_vec(json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec Description Get a double vector from a json_value . Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_double_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description callback function for double Source Code subroutine json_get_double_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_double_from_array ) contains subroutine get_double_from_array ( json , element , i , count ) !! callback function for double implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec","tags":"","loc":"proc/json_get_double_vec.html","title":"json_get_double_vec â€“ JSON-Fortran"},{"text":"private subroutine json_get_double_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a double vector from a json_value , given the path. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_double_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description callback function for double Source Code subroutine json_get_double_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_double_from_array , found = found ) contains subroutine get_double_from_array ( json , element , i , count ) !! callback function for double implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec_with_path","tags":"","loc":"proc/json_get_double_vec_with_path.html","title":"json_get_double_vec_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_double_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_vec_with_path , where \"path\" is kind=CDK Calls proc~~wrap_json_get_double_vec_with_path~~CallsGraph proc~wrap_json_get_double_vec_with_path wrap_json_get_double_vec_with_path interface~to_unicode to_unicode proc~wrap_json_get_double_vec_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_double_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_double_vec_with_path","tags":"","loc":"proc/wrap_json_get_double_vec_with_path.html","title":"wrap_json_get_double_vec_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_logical(json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK) :: value Description Get a logical value from a json_value . Source Code subroutine json_get_logical ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ) :: value value = . false . if ( json % exception_thrown ) return if ( me % var_type == json_logical ) then value = me % log_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = ( me % int_value > 0 ) case default call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) end select end if end if end subroutine json_get_logical","tags":"","loc":"proc/json_get_logical.html","title":"json_get_logical â€“ JSON-Fortran"},{"text":"private subroutine json_get_logical_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found Description Get a logical value from a json_value , given the path. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_logical_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = . false . if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_logical_with_path","tags":"","loc":"proc/json_get_logical_with_path.html","title":"json_get_logical_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_logical_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_with_path , where \"path\" is kind=CDK Calls proc~~wrap_json_get_logical_with_path~~CallsGraph proc~wrap_json_get_logical_with_path wrap_json_get_logical_with_path interface~to_unicode to_unicode proc~wrap_json_get_logical_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_logical_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_logical_with_path","tags":"","loc":"proc/wrap_json_get_logical_with_path.html","title":"wrap_json_get_logical_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_logical_vec(json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec Description Get a logical vector from json_value . Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_logical_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description callback function for logical Source Code subroutine json_get_logical_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_logical_from_array ) contains subroutine get_logical_from_array ( json , element , i , count ) !! callback function for logical implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec","tags":"","loc":"proc/json_get_logical_vec.html","title":"json_get_logical_vec â€“ JSON-Fortran"},{"text":"private subroutine json_get_logical_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical vector from a json_value , given the path. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_logical_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description callback function for logical Source Code subroutine json_get_logical_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_logical_from_array , found = found ) contains subroutine get_logical_from_array ( json , element , i , count ) !! callback function for logical implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec_with_path","tags":"","loc":"proc/json_get_logical_vec_with_path.html","title":"json_get_logical_vec_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_logical_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_vec_with_path , where \"path\" is kind=CDK Calls proc~~wrap_json_get_logical_vec_with_path~~CallsGraph proc~wrap_json_get_logical_vec_with_path wrap_json_get_logical_vec_with_path interface~to_unicode to_unicode proc~wrap_json_get_logical_vec_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_logical_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_logical_vec_with_path","tags":"","loc":"proc/wrap_json_get_logical_vec_with_path.html","title":"wrap_json_get_logical_vec_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_string(json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value Description Get a character string from a json_value . Calls proc~~json_get_string~~CallsGraph proc~json_get_string json_get_string proc~unescape_string unescape_string proc~json_get_string->proc~unescape_string interface~to_unicode to_unicode proc~unescape_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: error_message for unescape_string Source Code subroutine json_get_string ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: value character ( kind = CK , len = :), allocatable :: error_message !! for [[unescape_string]] value = '' if (. not . json % exception_thrown ) then select case ( me % var_type ) case ( json_string ) if ( allocated ( me % str_value )) then call unescape_string ( me % str_value , value , error_message ) if ( allocated ( error_message )) then call json % throw_exception ( error_message ) deallocate ( error_message ) value = '' end if else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%str_value not allocated' ) end if case default call json % throw_exception ( 'Error in json_get_string: ' // & 'Unable to resolve value to characters: ' // & me % name ) ! Note: for the other cases, we could do val to string conversions. end select end if end subroutine json_get_string","tags":"","loc":"proc/json_get_string.html","title":"json_get_string â€“ JSON-Fortran"},{"text":"private subroutine json_get_string_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Get a character string from a json_value , given the path. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_string_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = '' if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_string_with_path:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( allocated ( value ) . and . . not . json % exception_thrown ) then if ( present ( found )) found = . true . else if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if !cleanup: if ( associated ( p )) nullify ( p ) end subroutine json_get_string_with_path","tags":"","loc":"proc/json_get_string_with_path.html","title":"json_get_string_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_string_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_with_path , where \"path\" is kind=CDK Calls proc~~wrap_json_get_string_with_path~~CallsGraph proc~wrap_json_get_string_with_path wrap_json_get_string_with_path interface~to_unicode to_unicode proc~wrap_json_get_string_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_string_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_string_with_path","tags":"","loc":"proc/wrap_json_get_string_with_path.html","title":"wrap_json_get_string_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_string_vec(json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec Description Get a string vector from a json_value . Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_chars_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description callback function for chars Source Code subroutine json_get_string_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_chars_from_array ) contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec","tags":"","loc":"proc/json_get_string_vec.html","title":"json_get_string_vec â€“ JSON-Fortran"},{"text":"private subroutine json_get_string_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a json_value , given the path. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_chars_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description callback function for chars Source Code subroutine json_get_string_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_chars_from_array , found = found ) contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec_with_path","tags":"","loc":"proc/json_get_string_vec_with_path.html","title":"json_get_string_vec_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_string_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_vec_with_path , where \"path\" is kind=CDK Calls proc~~wrap_json_get_string_vec_with_path~~CallsGraph proc~wrap_json_get_string_vec_with_path wrap_json_get_string_vec_with_path interface~to_unicode to_unicode proc~wrap_json_get_string_vec_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_string_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_string_vec_with_path","tags":"","loc":"proc/wrap_json_get_string_vec_with_path.html","title":"wrap_json_get_string_vec_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_get_array(json, me, array_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure( json_array_callback_func ) :: array_callback Description This routine calls the user-supplied json_array_callback_func subroutine\n      for each element in the array. Note For integer, double, logical, and character arrays,\n      higher-level routines are provided (see get methods), so\n      this routine does not have to be used for those cases. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: element temp variable for getting elements integer(kind=IK), public :: i counter integer(kind=IK), public :: count number of elements in the array Source Code subroutine json_get_array ( json , me , array_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me procedure ( json_array_callback_func ) :: array_callback type ( json_value ), pointer :: element !! temp variable for getting elements integer ( IK ) :: i !! counter integer ( IK ) :: count !! number of elements in the array if ( json % exception_thrown ) return nullify ( element ) select case ( me % var_type ) case ( json_array ) count = json % count ( me ) element => me % children do i = 1 , count ! callback for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_get_array: ' // & 'Malformed JSON linked list' ) return end if call array_callback ( json , element , i , count ) if ( json % exception_thrown ) exit element => element % next end do case default call json % throw_exception ( 'Error in json_get_array:' // & ' Resolved value is not an array ' ) end select !cleanup: if ( associated ( element )) nullify ( element ) end subroutine json_get_array","tags":"","loc":"proc/json_get_array.html","title":"json_get_array â€“ JSON-Fortran"},{"text":"private subroutine json_traverse(json, p, traverse_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p procedure( json_traverse_callback_func ) :: traverse_callback Description Traverse a JSON structure.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. Calls proc~~json_traverse~~CallsGraph proc~json_traverse json_traverse none~traverse traverse proc~json_traverse->none~traverse none~traverse->none~traverse traverse_callback traverse_callback none~traverse->traverse_callback Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: finished can be used to stop the process Subroutines recursive subroutine traverse(p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: p Description recursive json_value traversal. Source Code subroutine json_traverse ( json , p , traverse_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p procedure ( json_traverse_callback_func ) :: traverse_callback logical ( LK ) :: finished !! can be used to stop the process if (. not . json % exception_thrown ) call traverse ( p ) contains recursive subroutine traverse ( p ) !! recursive [[json_value]] traversal. implicit none type ( json_value ), pointer , intent ( in ) :: p type ( json_value ), pointer :: element !! a child element integer ( IK ) :: i !! counter integer ( IK ) :: icount !! number of children if ( json % exception_thrown ) return call traverse_callback ( json , p , finished ) ! first call for this object if ( finished ) return !for arrays and objects, have to also call for all children: if ( p % var_type == json_array . or . p % var_type == json_object ) then icount = json % count ( p ) ! number of children if ( icount > 0 ) then element => p % children ! first one do i = 1 , icount ! call for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_traverse: ' // & 'Malformed JSON linked list' ) return end if call traverse ( element ) if ( finished . or . json % exception_thrown ) exit element => element % next end do end if nullify ( element ) end if end subroutine traverse end subroutine json_traverse","tags":"","loc":"proc/json_traverse.html","title":"json_traverse â€“ JSON-Fortran"},{"text":"private subroutine json_get_array_with_path(json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Description This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_array_with_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path procedure ( json_array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) ! resolve the path to the value call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_array:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( me = p , array_callback = array_callback ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_array_with_path","tags":"","loc":"proc/json_get_array_with_path.html","title":"json_get_array_with_path â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_get_array_with_path(json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_array_with_path , where \"path\" is kind=CDK Calls proc~~wrap_json_get_array_with_path~~CallsGraph proc~wrap_json_get_array_with_path wrap_json_get_array_with_path interface~to_unicode to_unicode proc~wrap_json_get_array_with_path->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_get_array_with_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path procedure ( json_array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), array_callback , found ) end subroutine wrap_json_get_array_with_path","tags":"","loc":"proc/wrap_json_get_array_with_path.html","title":"wrap_json_get_array_with_path â€“ JSON-Fortran"},{"text":"private subroutine json_parse_file(json, file, p, unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), , pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) Description Parse the JSON file and populate the json_value tree. Inputs The inputs can be: file & unit : the specified unit is used to read JSON from file.\n                      [note if unit is already open, then the filename is ignored] file : JSON is read from file using internal unit number Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % parse ( file = 'myfile.json' , p = p ) History Jacob Williams : 01/13/2015 : added read from string option. Izaak Beekman  : 03/08/2015 : moved read from string to separate\n    subroutine, and error annotation to separate subroutine. Note When calling this routine, any exceptions thrown from previous\n      calls will automatically be cleared. Calls proc~~json_parse_file~~CallsGraph proc~json_parse_file json_parse_file proc~json_value_create json_value_create proc~json_parse_file->proc~json_value_create Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: iunit file unit actually used integer(kind=IK), public :: istat iostat flag logical(kind=LK), public :: is_open if the file is already open Source Code subroutine json_parse_file ( json , file , p , unit ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: file !! JSON file name type ( json_value ), pointer :: p !! output structure integer ( IK ), intent ( in ), optional :: unit !! file unit number (/= 0) integer ( IK ) :: iunit !! file unit actually used integer ( IK ) :: istat !! iostat flag logical ( LK ) :: is_open !! if the file is already open !clear any exceptions and initialize: call json % initialize () if ( present ( unit ) ) then if ( unit == 0 ) then call json % throw_exception ( 'Error in json_parse_file: unit number must not be 0.' ) return end if iunit = unit !check to see if the file is already open ! if it is, then use it, otherwise open the file with the name given. inquire ( unit = iunit , opened = is_open , iostat = istat ) if ( istat == 0 . and . . not . is_open ) then ! open the file open ( unit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) else !if the file is already open, then we need to make sure ! that it is open with the correct form/access/etc... end if else ! open the file with a new unit number: open ( newunit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) end if if ( istat == 0 ) then ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = trim ( file ) !use the file name ! parse as a value call json % parse_value ( unit = iunit , str = CK_ '' , value = p ) if ( json % exception_thrown ) call json % annotate_invalid_json ( iunit , CK_ '' ) ! close the file if necessary close ( unit = iunit , iostat = istat ) else call json % throw_exception ( 'Error in json_parse_file: Error opening file: ' // trim ( file )) nullify ( p ) end if end subroutine json_parse_file","tags":"","loc":"proc/json_parse_file.html","title":"json_parse_file â€“ JSON-Fortran"},{"text":"private subroutine json_parse_string(json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data Description Parse the JSON string and populate the json_value tree. See also json_parse_file Calls proc~~json_parse_string~~CallsGraph proc~json_parse_string json_parse_string proc~json_value_create json_value_create proc~json_parse_string->proc~json_value_create Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: iunit = 0 indicates that json data will be read from buffer Source Code subroutine json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data integer ( IK ), parameter :: iunit = 0 !! indicates that json data will be read from buffer !clear any exceptions and initialize: call json % initialize () ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = '' ! parse as a value call json % parse_value ( unit = iunit , str = str , value = p ) if ( json % exception_thrown ) call json % annotate_invalid_json ( iunit , str ) end subroutine json_parse_string","tags":"","loc":"proc/json_parse_string.html","title":"json_parse_string â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_parse_string(json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CDK,len=*), intent(in) :: str string with JSON data Description Alternate version of json_parse_string , where str is kind=CDK. Calls proc~~wrap_json_parse_string~~CallsGraph proc~wrap_json_parse_string wrap_json_parse_string interface~to_unicode to_unicode proc~wrap_json_parse_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CDK , len =* ), intent ( in ) :: str !! string with JSON data call json % parse ( p , to_unicode ( str )) end subroutine wrap_json_parse_string","tags":"","loc":"proc/wrap_json_parse_string.html","title":"wrap_json_parse_string â€“ JSON-Fortran"},{"text":"private subroutine annotate_invalid_json(json, iunit, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=*), intent(in) :: str string with JSON data Description Generate a warning message if there was an error parsing a JSON file or string. Calls proc~~annotate_invalid_json~~CallsGraph proc~annotate_invalid_json annotate_invalid_json proc~integer_to_string integer_to_string proc~annotate_invalid_json->proc~integer_to_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: line character(kind=CK,len=:), public, allocatable :: arrow_str character(kind=CK,len=10), public :: line_str character(kind=CK,len=10), public :: char_str integer(kind=IK), public :: i integer(kind=IK), public :: i_nl_prev integer(kind=IK), public :: i_nl Source Code subroutine annotate_invalid_json ( json , iunit , str ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data character ( kind = CK , len = :), allocatable :: line , arrow_str character ( kind = CK , len = 10 ) :: line_str , char_str integer ( IK ) :: i , i_nl_prev , i_nl !  If there was an error reading the file, then !   print the line where the error occurred: if ( json % exception_thrown ) then !the counters for the current line and the last character read: call integer_to_string ( json % line_count , int_fmt , line_str ) call integer_to_string ( json % char_count , int_fmt , char_str ) !draw the arrow string that points to the current character: arrow_str = repeat ( '-' , max ( 0 , json % char_count - 1 ) ) // '&#94;' if ( json % line_count > 0 . and . json % char_count > 0 ) then if ( iunit /= 0 ) then if ( use_unformatted_stream ) then call json % get_current_line_from_file_stream ( iunit , line ) else call json % get_current_line_from_file_sequential ( iunit , line ) end if else !get the current line from the string: ! [this is done by counting the newline characters] i_nl_prev = 0 !index of previous newline character i_nl = 2 !just in case line_count = 0 do i = 1 , json % line_count i_nl = index ( str ( i_nl_prev + 1 :), newline ) if ( i_nl == 0 ) then !last line - no newline character i_nl = len ( str ) + 1 exit end if i_nl = i_nl + i_nl_prev !index of current newline character i_nl_prev = i_nl !update for next iteration end do line = str ( i_nl_prev + 1 : i_nl - 1 ) !extract current line end if else !in this case, it was an empty line or file line = '' end if !create the error message: json % err_message = json % err_message // newline // & 'line: ' // trim ( adjustl ( line_str )) // ', ' // & 'character: ' // trim ( adjustl ( char_str )) // newline // & trim ( line ) // newline // arrow_str if ( allocated ( line )) deallocate ( line ) end if end subroutine annotate_invalid_json","tags":"","loc":"proc/annotate_invalid_json.html","title":"annotate_invalid_json â€“ JSON-Fortran"},{"text":"private subroutine get_current_line_from_file_sequential(json, iunit, line) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Description Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the SEQUENTIAL version (see also get_current_line_from_file_stream ). Variables Type Visibility Attributes Name Initial character(kind=CK,len=seq_chunk_size), public :: chunk for reading line in chunks integer(kind=IK), public :: istat iostat flag integer(kind=IK), public :: isize number of characters read in read statement Source Code subroutine get_current_line_from_file_sequential ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line character ( kind = CK , len = seq_chunk_size ) :: chunk !! for reading line in chunks integer ( IK ) :: istat !! iostat flag integer ( IK ) :: isize !! number of characters read in read statement !initialize: line = '' !rewind to beginning of the current record: backspace ( iunit , iostat = istat ) !loop to read in all the characters in the current record. ![the line is read in chunks until the end of the line is reached] if ( istat == 0 ) then do isize = 0 read ( iunit , fmt = '(A)' , advance = 'NO' , size = isize , iostat = istat ) chunk if ( istat == 0 ) then line = line // chunk else if ( isize > 0 . and . isize <= seq_chunk_size ) line = line // chunk ( 1 : isize ) exit end if end do end if end subroutine get_current_line_from_file_sequential","tags":"","loc":"proc/get_current_line_from_file_sequential.html","title":"get_current_line_from_file_sequential â€“ JSON-Fortran"},{"text":"private subroutine get_current_line_from_file_stream(json, iunit, line) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Description Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the STREAM version (see also get_current_line_from_file_sequential ). Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: istart integer(kind=IK), public :: iend integer(kind=IK), public :: ios character(kind=CK,len=1), public :: c Source Code subroutine get_current_line_from_file_stream ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ) :: istart , iend , ios character ( kind = CK , len = 1 ) :: c istart = json % ipos do if ( istart <= 1 ) then istart = 1 exit end if read ( iunit , pos = istart , iostat = ios ) c if ( c == newline . or . ios /= 0 ) then if ( istart /= 1 ) istart = istart - 1 exit end if istart = istart - 1 !rewind until the beginning of the line end do iend = json % ipos do read ( iunit , pos = iend , iostat = ios ) c if ( c == newline . or . ios /= 0 ) exit iend = iend + 1 end do allocate ( character ( kind = CK , len = iend - istart + 1 ) :: line ) read ( iunit , pos = istart , iostat = ios ) line end subroutine get_current_line_from_file_stream","tags":"","loc":"proc/get_current_line_from_file_stream.html","title":"get_current_line_from_file_stream â€“ JSON-Fortran"},{"text":"private recursive subroutine parse_value(json, unit, str, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number character(kind=CK,len=*), intent(in) :: str string containing JSON data (only used if unit=0) type( json_value ), , pointer :: value JSON data that is extracted Description Core parsing routine. Calls proc~~parse_value~~CallsGraph proc~parse_value parse_value proc~to_object to_object proc~parse_value->proc~to_object proc~to_null to_null proc~parse_value->proc~to_null proc~to_logical to_logical proc~parse_value->proc~to_logical proc~to_string to_string proc~parse_value->proc~to_string proc~to_array to_array proc~parse_value->proc~to_array proc~destroy_json_data destroy_json_data proc~to_object->proc~destroy_json_data proc~to_null->proc~destroy_json_data proc~to_logical->proc~destroy_json_data proc~to_string->proc~destroy_json_data proc~to_array->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: eof end-of-file flag character(kind=CK,len=1), public :: c character read from file (or string) character(kind=CK,len=:), public, allocatable :: tmp this is a work-around for a bug\n in the gfortran 4.9 compiler. Source Code recursive subroutine parse_value ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string containing JSON data (only used if unit=0) type ( json_value ), pointer :: value !! JSON data that is extracted logical ( LK ) :: eof !! end-of-file flag character ( kind = CK , len = 1 ) :: c !! character read from file (or string) #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( value )) then call json % throw_exception ( 'Error in parse_value: value pointer not associated.' ) end if ! pop the next non whitespace character off the file c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then return else select case ( c ) case ( start_object ) ! start object call to_object ( value ) !allocate class call json % parse_object ( unit , str , value ) case ( start_array ) ! start array call to_array ( value ) !allocate class call json % parse_array ( unit , str , value ) case ( end_array ) ! end an empty array call json % push_char ( c ) nullify ( value ) case ( quotation_mark ) ! string call to_string ( value ) !allocate class select case ( value % var_type ) case ( json_string ) #if defined __GFORTRAN__ call json % parse_string ( unit , str , tmp ) ! write to a tmp variable because of value % str_value = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) ! #else call json % parse_string ( unit , str , value % str_value ) #endif end select case ( CK_ 't' ) !true_str(1:1) gfortran bug work around !true call json % parse_for_chars ( unit , str , true_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call to_logical ( value ,. true .) case ( CK_ 'f' ) !false_str(1:1) gfortran bug work around !false call json % parse_for_chars ( unit , str , false_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call to_logical ( value ,. false .) case ( CK_ 'n' ) !null_str(1:1) gfortran bug work around !null call json % parse_for_chars ( unit , str , null_str ( 2 :)) if (. not . json % exception_thrown ) call to_null ( value ) !allocate class case ( CK_ '-' , CK_ '0' : CK_ '9' ) call json % push_char ( c ) call json % parse_number ( unit , str , value ) case default call json % throw_exception ( 'Error in parse_value:' // & ' Unexpected character while parsing value. \"' // & c // '\"' ) end select end if end if end subroutine parse_value","tags":"","loc":"proc/parse_value.html","title":"parse_value â€“ JSON-Fortran"},{"text":"private subroutine json_value_create_logical(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name Description Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_logical ( p , 'value' ,. true .) Calls proc~~json_value_create_logical~~CallsGraph proc~json_value_create_logical json_value_create_logical proc~json_value_create json_value_create proc~json_value_create_logical->proc~json_value_create proc~to_logical to_logical proc~json_value_create_logical->proc~to_logical proc~destroy_json_data destroy_json_data proc~to_logical->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name logical ( LK ), intent ( in ) :: val !! variable value call json_value_create ( p ) call to_logical ( p , val , name ) end subroutine json_value_create_logical","tags":"","loc":"proc/json_value_create_logical.html","title":"json_value_create_logical â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_create_logical(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Wrapper for json_value_create_logical so create_logical method can\n  be called with name of character kind 'DEFAULT' or 'ISO_10646' Calls proc~~wrap_json_value_create_logical~~CallsGraph proc~wrap_json_value_create_logical wrap_json_value_create_logical interface~to_unicode to_unicode proc~wrap_json_value_create_logical->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val call json % create_logical ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_logical","tags":"","loc":"proc/wrap_json_value_create_logical.html","title":"wrap_json_value_create_logical â€“ JSON-Fortran"},{"text":"private subroutine json_value_create_integer(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_integer ( p , 'value' , 1 ) Calls proc~~json_value_create_integer~~CallsGraph proc~json_value_create_integer json_value_create_integer proc~json_value_create json_value_create proc~json_value_create_integer->proc~json_value_create proc~to_integer to_integer proc~json_value_create_integer->proc~to_integer proc~destroy_json_data destroy_json_data proc~to_integer->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json_value_create ( p ) call to_integer ( p , val , name ) end subroutine json_value_create_integer","tags":"","loc":"proc/json_value_create_integer.html","title":"json_value_create_integer â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_create_integer(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description A wrapper procedure for json_value_create_integer so that create_integer method may be called with either a 'DEFAULT' or 'ISO_10646' character kind name actual argument. Calls proc~~wrap_json_value_create_integer~~CallsGraph proc~wrap_json_value_create_integer wrap_json_value_create_integer interface~to_unicode to_unicode proc~wrap_json_value_create_integer->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json % create_integer ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_integer","tags":"","loc":"proc/wrap_json_value_create_integer.html","title":"wrap_json_value_create_integer â€“ JSON-Fortran"},{"text":"private subroutine json_value_create_double(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_double ( p , 'value' , 1.0_RK ) Calls proc~~json_value_create_double~~CallsGraph proc~json_value_create_double json_value_create_double proc~json_value_create json_value_create proc~json_value_create_double->proc~json_value_create proc~to_double to_double proc~json_value_create_double->proc~to_double proc~destroy_json_data destroy_json_data proc~to_double->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json_value_create ( p ) call to_double ( p , val , name ) end subroutine json_value_create_double","tags":"","loc":"proc/json_value_create_double.html","title":"json_value_create_double â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_create_double(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description A wrapper for json_value_create_double so that create_double method\n  may be called with an actual argument corresponding to the dummy argument, name that may be of 'DEFAULT' or 'ISO_10646' character kind. Calls proc~~wrap_json_value_create_double~~CallsGraph proc~wrap_json_value_create_double wrap_json_value_create_double interface~to_unicode to_unicode proc~wrap_json_value_create_double->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json % create_double ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_double","tags":"","loc":"proc/wrap_json_value_create_double.html","title":"wrap_json_value_create_double â€“ JSON-Fortran"},{"text":"private subroutine json_value_create_string(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_string ( p , 'value' , 'hello' ) Calls proc~~json_value_create_string~~CallsGraph proc~json_value_create_string json_value_create_string proc~json_value_create json_value_create proc~json_value_create_string->proc~json_value_create proc~to_string to_string proc~json_value_create_string->proc~to_string proc~destroy_json_data destroy_json_data proc~to_string->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_create_string ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val call json_value_create ( p ) call to_string ( p , val , name ) end subroutine json_value_create_string","tags":"","loc":"proc/json_value_create_string.html","title":"json_value_create_string â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_create_string(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Wrap json_value_create_string so that create_string method may be called\n  with actual character string arguments for name and val that are BOTH of\n  'DEFAULT' or 'ISO_10646' character kind. Calls proc~~wrap_json_value_create_string~~CallsGraph proc~wrap_json_value_create_string wrap_json_value_create_string interface~to_unicode to_unicode proc~wrap_json_value_create_string->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_create_string ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val call json % create_string ( p , to_unicode ( val ), to_unicode ( name )) end subroutine wrap_json_value_create_string","tags":"","loc":"proc/wrap_json_value_create_string.html","title":"wrap_json_value_create_string â€“ JSON-Fortran"},{"text":"private subroutine json_value_create_null(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_null ( p , 'value' ) Calls proc~~json_value_create_null~~CallsGraph proc~json_value_create_null json_value_create_null proc~json_value_create json_value_create proc~json_value_create_null->proc~json_value_create proc~to_null to_null proc~json_value_create_null->proc~to_null proc~destroy_json_data destroy_json_data proc~to_null->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_null ( p , name ) end subroutine json_value_create_null","tags":"","loc":"proc/json_value_create_null.html","title":"json_value_create_null â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_create_null(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Wrap json_value_create_null so that create_null method may be called with\n  an actual argument corresponding to the dummy argument name that is either\n  of 'DEFAULT' or 'ISO_10646' character kind. Calls proc~~wrap_json_value_create_null~~CallsGraph proc~wrap_json_value_create_null wrap_json_value_create_null interface~to_unicode to_unicode proc~wrap_json_value_create_null->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_null ( p , to_unicode ( name )) end subroutine wrap_json_value_create_null","tags":"","loc":"proc/wrap_json_value_create_null.html","title":"wrap_json_value_create_null â€“ JSON-Fortran"},{"text":"private subroutine json_value_create_object(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_object ( p , 'objectname' ) Note The name is not significant for the root structure or an array element.\n      In those cases, an empty string can be used. Calls proc~~json_value_create_object~~CallsGraph proc~json_value_create_object json_value_create_object proc~json_value_create json_value_create proc~json_value_create_object->proc~json_value_create proc~to_object to_object proc~json_value_create_object->proc~to_object proc~destroy_json_data destroy_json_data proc~to_object->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_object ( p , name ) end subroutine json_value_create_object","tags":"","loc":"proc/json_value_create_object.html","title":"json_value_create_object â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_create_object(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Wrap json_value_create_object so that create_object method may be called\n  with an actual argument corresponding to the dummy argument name that is of\n  either 'DEFAULT' or 'ISO_10646' character kind. Calls proc~~wrap_json_value_create_object~~CallsGraph proc~wrap_json_value_create_object wrap_json_value_create_object interface~to_unicode to_unicode proc~wrap_json_value_create_object->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_object ( p , to_unicode ( name )) end subroutine wrap_json_value_create_object","tags":"","loc":"proc/wrap_json_value_create_object.html","title":"wrap_json_value_create_object â€“ JSON-Fortran"},{"text":"private subroutine json_value_create_array(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_array ( p , 'arrayname' ) Calls proc~~json_value_create_array~~CallsGraph proc~json_value_create_array json_value_create_array proc~json_value_create json_value_create proc~json_value_create_array->proc~json_value_create proc~to_array to_array proc~json_value_create_array->proc~to_array proc~destroy_json_data destroy_json_data proc~to_array->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_array ( p , name ) end subroutine json_value_create_array","tags":"","loc":"proc/json_value_create_array.html","title":"json_value_create_array â€“ JSON-Fortran"},{"text":"private subroutine wrap_json_value_create_array(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description A wrapper for json_value_create_array so that create_array method may be\n  called with an actual argument, corresponding to the dummy argument name ,\n  that is either of 'DEFAULT' or 'ISO_10646' character kind. Calls proc~~wrap_json_value_create_array~~CallsGraph proc~wrap_json_value_create_array wrap_json_value_create_array interface~to_unicode to_unicode proc~wrap_json_value_create_array->interface~to_unicode proc~to_uni to_uni interface~to_unicode->proc~to_uni proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine wrap_json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_array ( p , to_unicode ( name )) end subroutine wrap_json_value_create_array","tags":"","loc":"proc/wrap_json_value_create_array.html","title":"wrap_json_value_create_array â€“ JSON-Fortran"},{"text":"private subroutine to_logical(p, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p logical(kind=LK), intent(in), optional :: val if the value is also to be set (if not present, then .false. is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to a logical. Calls proc~~to_logical~~CallsGraph proc~to_logical to_logical proc~destroy_json_data destroy_json_data proc~to_logical->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~to_logical~~CalledByGraph proc~to_logical to_logical proc~json_update_logical json_update_logical proc~json_update_logical->proc~to_logical proc~json_value_create_logical json_value_create_logical proc~json_value_create_logical->proc~to_logical proc~parse_value parse_value proc~parse_value->proc~to_logical Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine to_logical ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p logical ( LK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then .false. is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_logical allocate ( p % log_value ) if ( present ( val )) then p % log_value = val else p % log_value = . false . !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_logical","tags":"","loc":"proc/to_logical.html","title":"to_logical â€“ JSON-Fortran"},{"text":"private subroutine to_integer(p, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p integer(kind=IK), intent(in), optional :: val if the value is also to be set (if not present, then 0 is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to an integer. Calls proc~~to_integer~~CallsGraph proc~to_integer to_integer proc~destroy_json_data destroy_json_data proc~to_integer->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~to_integer~~CalledByGraph proc~to_integer to_integer proc~json_value_create_integer json_value_create_integer proc~json_value_create_integer->proc~to_integer proc~json_update_integer json_update_integer proc~json_update_integer->proc~to_integer proc~parse_number parse_number proc~parse_number->proc~to_integer Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine to_integer ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p integer ( IK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0 is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_integer allocate ( p % int_value ) if ( present ( val )) then p % int_value = val else p % int_value = 0 !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_integer","tags":"","loc":"proc/to_integer.html","title":"to_integer â€“ JSON-Fortran"},{"text":"private subroutine to_double(p, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p real(kind=RK), intent(in), optional :: val if the value is also to be set (if not present, then 0.0_rk is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to a double. Calls proc~~to_double~~CallsGraph proc~to_double to_double proc~destroy_json_data destroy_json_data proc~to_double->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~to_double~~CalledByGraph proc~to_double to_double proc~parse_number parse_number proc~parse_number->proc~to_double proc~json_update_double json_update_double proc~json_update_double->proc~to_double proc~json_value_create_double json_value_create_double proc~json_value_create_double->proc~to_double Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine to_double ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p real ( RK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0.0_rk is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_double allocate ( p % dbl_value ) if ( present ( val )) then p % dbl_value = val else p % dbl_value = 0.0_RK !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_double","tags":"","loc":"proc/to_double.html","title":"to_double â€“ JSON-Fortran"},{"text":"private subroutine to_string(p, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p character(kind=CK,len=*), intent(in), optional :: val if the value is also to be set (if not present, then '' is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to a string. Modified Izaak Beekman : 02/24/2015 Calls proc~~to_string~~CallsGraph proc~to_string to_string proc~destroy_json_data destroy_json_data proc~to_string->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~to_string~~CalledByGraph proc~to_string to_string proc~parse_value parse_value proc~parse_value->proc~to_string proc~json_update_string json_update_string proc~json_update_string->proc~to_string proc~json_value_create_string json_value_create_string proc~json_value_create_string->proc~to_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine to_string ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then '' is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_string if ( present ( val )) then p % str_value = val else p % str_value = '' !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_string","tags":"","loc":"proc/to_string.html","title":"to_string â€“ JSON-Fortran"},{"text":"private subroutine to_null(p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to a null. Calls proc~~to_null~~CallsGraph proc~to_null to_null proc~destroy_json_data destroy_json_data proc~to_null->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~to_null~~CalledByGraph proc~to_null to_null proc~parse_value parse_value proc~parse_value->proc~to_null proc~json_value_create_null json_value_create_null proc~json_value_create_null->proc~to_null Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine to_null ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_null !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_null","tags":"","loc":"proc/to_null.html","title":"to_null â€“ JSON-Fortran"},{"text":"private subroutine to_object(p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to an object. Calls proc~~to_object~~CallsGraph proc~to_object to_object proc~destroy_json_data destroy_json_data proc~to_object->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~to_object~~CalledByGraph proc~to_object to_object proc~parse_value parse_value proc~parse_value->proc~to_object proc~json_value_create_object json_value_create_object proc~json_value_create_object->proc~to_object Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine to_object ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_object !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_object","tags":"","loc":"proc/to_object.html","title":"to_object â€“ JSON-Fortran"},{"text":"private subroutine to_array(p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to an array. Calls proc~~to_array~~CallsGraph proc~to_array to_array proc~destroy_json_data destroy_json_data proc~to_array->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~to_array~~CalledByGraph proc~to_array to_array proc~parse_value parse_value proc~parse_value->proc~to_array proc~json_value_create_array json_value_create_array proc~json_value_create_array->proc~to_array Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine to_array ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_array !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_array","tags":"","loc":"proc/to_array.html","title":"to_array â€“ JSON-Fortran"},{"text":"private recursive subroutine parse_object(json, unit, str, parent) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: parent the parsed object will be added as a child of this Description Core parsing routine. Calls proc~~parse_object~~CallsGraph proc~parse_object parse_object proc~json_value_create json_value_create proc~parse_object->proc~json_value_create Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: pair logical(kind=LK), public :: eof character(kind=CK,len=1), public :: c character(kind=CK,len=:), public, allocatable :: tmp this is a work-around for a bug\n in the gfortran 4.9 compiler. Source Code recursive subroutine parse_object ( json , unit , str , parent ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: parent !! the parsed object will be added as a child of this type ( json_value ), pointer :: pair logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( parent )) then call json % throw_exception ( 'Error in parse_object: parent pointer not associated.' ) end if nullify ( pair ) !probably not necessary ! pair name c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing start of object.' ) return else if ( end_object == c ) then ! end of an empty object return else if ( quotation_mark == c ) then call json_value_create ( pair ) #if defined __GFORTRAN__ call json % parse_string ( unit , str , tmp ) ! write to a tmp variable because of pair % name = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) #else call json % parse_string ( unit , str , pair % name ) #endif if ( json % exception_thrown ) then call json % destroy ( pair ) return end if else call json % throw_exception ( 'Error in parse_object: Expecting string: \"' // c // '\"' ) return end if ! pair value c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing object member.' ) return else if ( colon_char == c ) then ! parse the value call json % parse_value ( unit , str , pair ) if ( json % exception_thrown ) then call json % destroy ( pair ) return else call json % add ( parent , pair ) end if else call json % throw_exception ( 'Error in parse_object:' // & ' Expecting : and then a value: ' // c ) return end if ! another possible pair c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object: ' // & 'End of file encountered when parsing an object' ) return else if ( delimiter == c ) then ! read the next member call json % parse_object ( unit = unit , str = str , parent = parent ) else if ( end_object == c ) then ! end of object return else call json % throw_exception ( 'Error in parse_object: Expecting end of object: ' // c ) return end if end if end subroutine parse_object","tags":"","loc":"proc/parse_object.html","title":"parse_object â€“ JSON-Fortran"},{"text":"private recursive subroutine parse_array(json, unit, str, array) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: array Description Core parsing routine. Calls proc~~parse_array~~CallsGraph proc~parse_array parse_array proc~json_value_create json_value_create proc~parse_array->proc~json_value_create Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: element logical(kind=LK), public :: eof character(kind=CK,len=1), public :: c Source Code recursive subroutine parse_array ( json , unit , str , array ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: array type ( json_value ), pointer :: element logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c do if ( json % exception_thrown ) exit ! try to parse an element value nullify ( element ) call json_value_create ( element ) call json % parse_value ( unit , str , element ) if ( json % exception_thrown ) then if ( associated ( element )) call json % destroy ( element ) exit end if ! parse value will disassociate an empty array value if ( associated ( element )) call json % add ( array , element ) ! popped the next character c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then ! The file ended before array was finished: call json % throw_exception ( 'Error in parse_array: ' // & 'End of file encountered when parsing an array.' ) exit else if ( delimiter == c ) then ! parse the next element cycle else if ( end_array == c ) then ! end of array exit else call json % throw_exception ( 'Error in parse_array: ' // & 'Unexpected character encountered when parsing array.' ) exit end if end do end subroutine parse_array","tags":"","loc":"proc/parse_array.html","title":"parse_array â€“ JSON-Fortran"},{"text":"private subroutine parse_string(json, unit, str, string) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=:), intent(out), allocatable :: string Description Parses a string while reading a JSON file. History Jacob Williams : 6/16/2014 : Added hex validation. Jacob Williams : 12/3/2015 : Fixed some bugs. Calls proc~~parse_string~~CallsGraph proc~parse_string parse_string proc~valid_json_hex valid_json_hex proc~parse_string->proc~valid_json_hex Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: eof logical(kind=LK), public :: is_hex logical(kind=LK), public :: escape character(kind=CK,len=1), public :: c character(kind=CK,len=4), public :: hex integer(kind=IK), public :: i integer(kind=IK), public :: ip index to put next character,\n to speed up by reducing the number of character string reallocations. Source Code subroutine parse_string ( json , unit , str , string ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len = :), allocatable , intent ( out ) :: string logical ( LK ) :: eof , is_hex , escape character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = 4 ) :: hex integer ( IK ) :: i integer ( IK ) :: ip !! index to put next character, !! to speed up by reducing the number of character string reallocations. !at least return a blank string if there is a problem: string = repeat ( space , chunk_size ) if (. not . json % exception_thrown ) then !initialize: ip = 1 is_hex = . false . escape = . false . i = 0 do !get the next character from the file: c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . false .) if ( eof ) then call json % throw_exception ( 'Error in parse_string: Expecting end of string' ) return else if ( c == quotation_mark . and . . not . escape ) then !end of string if ( is_hex ) call json % throw_exception ( 'Error in parse_string:' // & ' incomplete hex string: \\u' // trim ( hex )) exit else !if the string is not big enough, then add another chunk: if ( ip > len ( string )) string = string // repeat ( space , chunk_size ) !append to string: string ( ip : ip ) = c ip = ip + 1 !hex validation: if ( is_hex ) then !accumulate the four characters after '\\u' i = i + 1 hex ( i : i ) = c if ( i == 4 ) then if ( valid_json_hex ( hex )) then i = 0 hex = '' is_hex = . false . else call json % throw_exception ( 'Error in parse_string:' // & ' invalid hex string: \\u' // trim ( hex )) exit end if end if else !when the '\\u' string is encountered, then !  start accumulating the hex string (should be the next 4 characters) if ( escape ) then escape = . false . is_hex = ( c == 'u' ) !the next four characters are the hex string else escape = ( c == backslash ) end if end if end if end do !trim the string if necessary: if ( ip < len ( string ) + 1 ) then if ( ip == 1 ) then string = '' else string = string ( 1 : ip - 1 ) end if end if end if end subroutine parse_string","tags":"","loc":"proc/parse_string.html","title":"parse_string â€“ JSON-Fortran"},{"text":"private subroutine parse_for_chars(json, unit, str, chars) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=*), intent(in) :: chars the string to check for. Description Core parsing routine. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i integer(kind=IK), public :: length logical(kind=LK), public :: eof character(kind=CK,len=1), public :: c Source Code subroutine parse_for_chars ( json , unit , str , chars ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len =* ), intent ( in ) :: chars !! the string to check for. integer ( IK ) :: i , length logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c if (. not . json % exception_thrown ) then length = len_trim ( chars ) do i = 1 , length c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected end of file while parsing array.' ) return else if ( c /= chars ( i : i )) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected character.: \"' // c // '\" ' // chars ( i : i )) return end if end do end if end subroutine parse_for_chars","tags":"","loc":"proc/parse_for_chars.html","title":"parse_for_chars â€“ JSON-Fortran"},{"text":"private subroutine parse_number(json, unit, str, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: value Description Read a numerical value from the file (or string).\n  The routine will determine if it is an integer or a double, and\n  allocate the type accordingly. Note Complete rewrite of the original FSON routine, which had some problems. Calls proc~~parse_number~~CallsGraph proc~parse_number parse_number proc~to_integer to_integer proc~parse_number->proc~to_integer proc~to_double to_double proc~parse_number->proc~to_double proc~destroy_json_data destroy_json_data proc~to_integer->proc~destroy_json_data proc~to_double->proc~destroy_json_data Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: tmp character(kind=CK,len=1), public :: c logical(kind=LK), public :: eof real(kind=RK), public :: rval integer(kind=IK), public :: ival logical(kind=LK), public :: first logical(kind=LK), public :: is_integer integer(kind=IK), public :: ip index to put next character\n [to speed up by reducing the number\n of character string reallocations] Source Code subroutine parse_number ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: value character ( kind = CK , len = :), allocatable :: tmp character ( kind = CK , len = 1 ) :: c logical ( LK ) :: eof real ( RK ) :: rval integer ( IK ) :: ival logical ( LK ) :: first logical ( LK ) :: is_integer integer ( IK ) :: ip !! index to put next character !! [to speed up by reducing the number !! of character string reallocations] if (. not . json % exception_thrown ) then tmp = repeat ( space , chunk_size ) ip = 1 first = . true . is_integer = . true . !assume it may be an integer, unless otherwise determined !read one character at a time and accumulate the string: do !get the next character: c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_number:' // & ' Unexpected end of file while parsing number.' ) return else select case ( c ) case ( CK_ '-' , CK_ '+' ) !note: allowing a '+' as the first character here. if ( is_integer . and . (. not . first )) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '.' , CK_ 'E' , CK_ 'e' ) !can be present in real numbers if ( is_integer ) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '0' : CK_ '9' ) !valid characters for numbers !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case default !push back the last character read: call json % push_char ( c ) !string to value: if ( is_integer ) then ival = json % string_to_integer ( tmp ) call to_integer ( value , ival ) else rval = json % string_to_double ( tmp ) call to_double ( value , rval ) end if exit !finished end select end if if ( first ) first = . false . end do !cleanup: if ( allocated ( tmp )) deallocate ( tmp ) end if end subroutine parse_number","tags":"","loc":"proc/parse_number.html","title":"parse_number â€“ JSON-Fortran"},{"text":"private subroutine push_char(json, c) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=1), intent(in) :: c Description Core routine. See also pop_char History Jacob Williams : 5/3/2015 : replaced original version of this routine. Calls proc~~push_char~~CallsGraph proc~push_char push_char proc~integer_to_string integer_to_string proc~push_char->proc~integer_to_string Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CK,len=max_numeric_str_len), public :: istr Source Code subroutine push_char ( json , c ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len = 1 ), intent ( in ) :: c character ( kind = CK , len = max_numeric_str_len ) :: istr if (. not . json % exception_thrown ) then if ( use_unformatted_stream ) then !in this case, c is ignored, and we just !decrement the stream position counter: json % ipos = json % ipos - 1 else json % pushed_index = json % pushed_index + 1 if ( json % pushed_index > 0 . and . json % pushed_index <= len ( json % pushed_char )) then json % pushed_char ( json % pushed_index : json % pushed_index ) = c else call integer_to_string ( json % pushed_index , int_fmt , istr ) call json % throw_exception ( 'Error in push_char: ' // & 'invalid valid of pushed_index: ' // trim ( istr )) end if end if end if end subroutine push_char","tags":"","loc":"proc/push_char.html","title":"push_char â€“ JSON-Fortran"},{"text":"private subroutine json_print_error_message(json, io_unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer, intent(in), optional :: io_unit Description Print any error message, and then clear the exceptions. Note This routine is used by the unit tests.\n      It was originally in json_example.f90, and was\n      moved here 2/26/2015 by Izaak Beekman. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: error_msg error message logical, public :: status_ok false if there were any errors thrown Source Code subroutine json_print_error_message ( json , io_unit ) implicit none class ( json_core ), intent ( inout ) :: json integer , intent ( in ), optional :: io_unit character ( kind = CK , len = :), allocatable :: error_msg !! error message logical :: status_ok !! false if there were any errors thrown !get error message: call json % check_for_errors ( status_ok , error_msg ) !print it if there is one: if (. not . status_ok ) then if ( present ( io_unit )) then write ( io_unit , '(A)' ) error_msg else write ( output_unit , '(A)' ) error_msg end if deallocate ( error_msg ) call json % clear_exceptions () end if end subroutine json_print_error_message","tags":"","loc":"proc/json_print_error_message.html","title":"json_print_error_message â€“ JSON-Fortran"},{"text":"public interface json_core Structure constructor to initialize a json_core object Example type ( json_file ) :: json_core json_core = json_core () Calls interface~~json_core~~CallsGraph interface~json_core json_core proc~initialize_json_core initialize_json_core interface~json_core->proc~initialize_json_core Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(json_core_object) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_core ) Description Author Jacob Williams Date 4/26/2016 Function constructor for a json_core .\n  This is just a wrapper for json_initialize .","tags":"","loc":"interface/json_core.html","title":"json_core â€“ JSON-Fortran"},{"text":"Uses: iso_fortran_env json_kinds json_parameters json_string_utilities json_value_module module~~json_file_module~~UsesGraph module~json_file_module json_file_module module~json_parameters json_parameters module~json_parameters->module~json_file_module module~json_string_utilities json_string_utilities module~json_parameters->module~json_string_utilities module~json_value_module json_value_module module~json_parameters->module~json_value_module module~json_string_utilities->module~json_file_module module~json_string_utilities->module~json_value_module module~json_value_module->module~json_file_module iso_fortran_env iso_fortran_env iso_fortran_env->module~json_file_module iso_fortran_env->module~json_value_module module~json_kinds json_kinds iso_fortran_env->module~json_kinds module~json_kinds->module~json_file_module module~json_kinds->module~json_parameters module~json_kinds->module~json_string_utilities module~json_kinds->module~json_value_module var panmodulejson_file_moduleUsesGraph = svgPanZoom('#modulejson_file_moduleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Higher-level json_file interface for the json_value type. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Used By module~~json_file_module~~UsedByGraph module~json_file_module json_file_module module~json_module json_module module~json_file_module->module~json_module Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object, and either the json_core settings or a json_core instance. private function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_file ) Description Author Izaak Beekman Date 07/23/2015 Cast a json_value object as a json_file object.\n  It also calls the initialize() method. private function initialize_json_file_v2 (json_value_object, json_core_object) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Description Author Jacob Williams Date 4/26/2016 Cast a json_value pointer and a json_core object\n  as a json_file object. Derived Types type, public :: json_file Components Type Visibility Attributes Name Initial type( json_core ), private :: core The instance of the json_core factory used for this file. type( json_value ), private, pointer :: p => null() the JSON structure read from the file Constructor Structure constructor to initialize a json_file object\n  with an existing json_value object, and either the json_core settings or a json_core instance. private  function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Cast a json_value object as a json_file object.\n  It also calls the initialize() method. private  function initialize_json_file_v2 (json_value_object, json_core_object) Cast a json_value pointer and a json_core object\n  as a json_file object. Type-Bound Procedures generic, public :: initialize => initialize_json_core_in_file, set_json_core_in_file procedure, public :: get_core => get_json_core_in_file procedure, public :: load_file => json_file_load generic, public :: load_from_string => json_file_load_from_string, wrap_json_file_load_from_string procedure, public :: destroy => json_file_destroy procedure, public :: move => json_file_move_pointer generic, public :: info => json_file_variable_info, wrap_json_file_variable_info procedure, public :: failed => json_file_failed procedure, public :: print_error_message => json_file_print_error_message procedure, public :: check_for_errors => json_file_check_for_errors procedure, public :: clear_exceptions => json_file_clear_exceptions procedure, public :: print_to_string => json_file_print_to_string generic, public :: print_file => json_file_print_to_console, json_file_print_1, json_file_print_2 generic, public :: get => json_file_get_object, wrap_json_file_get_object, json_file_get_integer, wrap_json_file_get_integer, json_file_get_double, wrap_json_file_get_double, json_file_get_logical, wrap_json_file_get_logical, json_file_get_string, wrap_json_file_get_string, json_file_get_integer_vec, wrap_json_file_get_integer_vec, json_file_get_double_vec, wrap_json_file_get_double_vec, json_file_get_logical_vec, wrap_json_file_get_logical_vec, json_file_get_string_vec, wrap_json_file_get_string_vec, json_file_get_root generic, public :: update => json_file_update_integer, wrap_json_file_update_integer, json_file_update_logical, wrap_json_file_update_logical, json_file_update_real, wrap_json_file_update_real, json_file_update_string, wrap_json_file_update_string generic, public :: update => json_file_update_string_name_ascii, json_file_update_string_val_ascii procedure, public :: traverse => json_file_traverse procedure, public :: wrap_json_file_load_from_string procedure, public :: json_file_load_from_string procedure, public :: initialize_json_core_in_file procedure, public :: set_json_core_in_file procedure, public :: wrap_json_file_variable_info procedure, public :: json_file_variable_info procedure, public :: wrap_json_file_get_object procedure, public :: json_file_get_object procedure, public :: wrap_json_file_get_integer procedure, public :: json_file_get_integer procedure, public :: wrap_json_file_get_double procedure, public :: json_file_get_double procedure, public :: wrap_json_file_get_logical procedure, public :: json_file_get_logical procedure, public :: wrap_json_file_get_string procedure, public :: json_file_get_string procedure, public :: wrap_json_file_get_integer_vec procedure, public :: json_file_get_integer_vec procedure, public :: wrap_json_file_get_double_vec procedure, public :: json_file_get_double_vec procedure, public :: wrap_json_file_get_logical_vec procedure, public :: json_file_get_logical_vec procedure, public :: wrap_json_file_get_string_vec procedure, public :: json_file_get_string_vec procedure, public :: json_file_get_root procedure, public :: wrap_json_file_update_integer procedure, public :: json_file_update_integer procedure, public :: wrap_json_file_update_logical procedure, public :: json_file_update_logical procedure, public :: wrap_json_file_update_real procedure, public :: json_file_update_real procedure, public :: wrap_json_file_update_string procedure, public :: json_file_update_string procedure, public :: json_file_update_string_name_ascii procedure, public :: json_file_update_string_val_ascii procedure, public :: json_file_print_to_console procedure, public :: json_file_print_1 procedure, public :: json_file_print_2 Description The json_file is the main public class that is\n  used to open a file and get data from it. Functions private pure function json_file_failed (me) result(failed) Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me Return Value logical(kind=LK) will be true if there has been an error. Description Check error status in the file. private function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_file ) Description Author Izaak Beekman Date 07/23/2015 Cast a json_value object as a json_file object.\n  It also calls the initialize() method. private function initialize_json_file_v2 (json_value_object, json_core_object) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Description Author Jacob Williams Date 4/26/2016 Cast a json_value pointer and a json_core object\n  as a json_file object. Subroutines private subroutine json_file_check_for_errors (me, status_ok, error_msg) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Description Retrieve error status and message from the class. private pure subroutine json_file_clear_exceptions (me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Clear exceptions in the class. private subroutine json_file_print_error_message (me, io_unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer, intent(in), optional :: io_unit Description This is a wrapper for json_print_error_message . private subroutine initialize_json_core_in_file (me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Description Initialize the json_core for this json_file .\n  This is just a wrapper for json_initialize . private subroutine set_json_core_in_file (me, core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_core ), intent(in) :: core Description Set the json_core for this json_file . private subroutine get_json_core_in_file (me, core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me type( json_core ), intent(out) :: core Description Get a copy of the json_core in this json_file . private subroutine json_file_destroy (me, destroy_core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical, intent(in), optional :: destroy_core to also destroy the json_core .\n default is to leave it as is. Description Author Jacob Williams Destroy the json_value data in a json_file .\n  This must be done when the variable is no longer needed,\n  or will be reused to open a different file.\n  Otherwise a memory leak will occur. private subroutine json_file_move_pointer (to, from) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from Description Author Jacob Williams Date 12/5/2014 Move the json_value pointer from one json_file to another.\n  The \"from\" pointer is then nullified, but not destroyed. private subroutine json_file_load (me, filename, unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use (if not present, a newunit is used) Description Author Jacob Williams Date 12/9/2013 Load the JSON data from a file. private subroutine json_file_load_from_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from Description Author Jacob Williams Date 1/13/2015 Load the JSON data from a string. private subroutine wrap_json_file_load_from_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: str Description Alternate version of json_file_load_from_string , where \"str\" is kind=CDK. private subroutine json_file_print_to_console (me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Author Jacob Williams Date 1/11/2015 Print the JSON file to the console. private subroutine json_file_print_1 (me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) Description Author Jacob Williams Date 12/9/2013 Prints the JSON file to the specified file unit number. private subroutine json_file_print_2 (me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to Description Author Jacob Williams Date 1/11/2015 Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. private subroutine json_file_print_to_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to Description Author Jacob Williams Date 1/11/2015 Print the JSON file to a string. private subroutine json_file_variable_info (me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children Description Author Jacob Williams Date 2/3/2014 Returns information about a variable in a json_file . private subroutine wrap_json_file_variable_info (me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: found integer(kind=IK), intent(out) :: var_type integer(kind=IK), intent(out) :: n_children Description Alternate version of json_file_variable_info , where \"path\" is kind=CDK. private subroutine json_file_get_root (me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable Description Author Izaak Beekman Date 7/23/2015 Get a json_value pointer to the JSON file root. private subroutine json_file_get_object (me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 2/3/2014 Get a json_value pointer to an object from a JSON file. private subroutine wrap_json_file_get_object (me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_object , where \"path\" is kind=CDK. private subroutine json_file_get_integer (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 12/9/2013 Get an integer value from a JSON file. private subroutine wrap_json_file_get_integer (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer , where \"path\" is kind=CDK. private subroutine json_file_get_integer_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Description Author Jacob Williams Date 1/20/2014 Get an integer vector from a JSON file. private subroutine wrap_json_file_get_integer_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer_vec , where \"path\" is kind=CDK. private subroutine json_file_get_double (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a real(RK) variable value from a JSON file. private subroutine wrap_json_file_get_double (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double , where \"path\" is kind=CDK. private subroutine json_file_get_double_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/19/2014 Get a real(RK) vector from a JSON file. private subroutine wrap_json_file_get_double_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double_vec , where \"path\" is kind=CDK. private subroutine json_file_get_logical (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a logical(LK) value from a JSON file. private subroutine wrap_json_file_get_logical (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical , where \"path\" is kind=CDK. private subroutine json_file_get_logical_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/20/2014 Get a logical(LK) vector from a JSON file. private subroutine wrap_json_file_get_logical_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical_vec , where \"path\" is kind=CDK. private subroutine json_file_get_string (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 12/9/2013 Get a character string from a json file.\n  The output val is an allocatable character string. private subroutine wrap_json_file_get_string (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string , where \"path\" is kind=CDK. private subroutine json_file_get_string_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Author Jacob Williams Date 1/19/2014 Get a string vector from a JSON file. private subroutine wrap_json_file_get_string_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string_vec , where \"path\" is kind=CDK. private subroutine json_file_update_integer (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_file_update_integer (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_integer , where \"name\" is kind=CDK. private subroutine json_file_update_logical (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_file_update_logical (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_logical , where \"name\" is kind=CDK. private subroutine json_file_update_real (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_file_update_real (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_real , where \"name\" is kind=CDK. private subroutine json_file_update_string (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_file_update_string (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" and \"val\" are kind=CDK. private subroutine json_file_update_string_name_ascii (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" is kind=CDK. private subroutine json_file_update_string_val_ascii (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"val\" is kind=CDK. private subroutine json_file_traverse (me, traverse_callback) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure( json_traverse_callback_func ) :: traverse_callback Description Author Jacob Williams Date 6/11/2016 Traverse the JSON structure in the file.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure.","tags":"","loc":"module/json_file_module.html","title":"json_file_module â€“ JSON-Fortran"},{"text":"Uses: iso_fortran_env module~~json_kinds~~UsesGraph module~json_kinds json_kinds iso_fortran_env iso_fortran_env iso_fortran_env->module~json_kinds Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. JSON -Fortran kind definitions. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Note -DUSE_UCS4 is an optional preprocessor flag.\n      When present, Unicode support is enabled. Note that this\n      is currently only supported with the gfortran compiler.\n      Example: gfortran -DUSE_UCS4 ... The documentation given here assumes USE_UCS4 is defined. Warning CK and CDK are the JSON -Fortran character kind and JSON -Fortran default\n         character kind respectively. Client code MUST ensure characters of kind=CK are used for all character variables and strings passed to the JSON -Fortran\n         library EXCEPT for file names which must be of 'DEFAULT' character kind,\n         provided here as CDK . In particular, any variable that is a: json path, string\n         value or object name passed to the JSON -Fortran library MUST be of type CK . Note Most string literal constants of default kind are fine to pass as arguments to JSON -Fortran procedures since they have been overloaded to accept intent(in) character arguments of the default ( CDK ) kind. If you find a procedure which does\n      not accept an intent(in) literal string argument of default kind, please file an issue on GitHub. Used By module~~json_kinds~~UsedByGraph module~json_kinds json_kinds module~json_value_module json_value_module module~json_kinds->module~json_value_module module~json_file_module json_file_module module~json_kinds->module~json_file_module module~json_module json_module module~json_kinds->module~json_module module~json_parameters json_parameters module~json_kinds->module~json_parameters module~json_string_utilities json_string_utilities module~json_kinds->module~json_string_utilities module~json_value_module->module~json_file_module module~json_value_module->module~json_module module~json_file_module->module~json_module module~json_parameters->module~json_value_module module~json_parameters->module~json_file_module module~json_parameters->module~json_string_utilities module~json_string_utilities->module~json_value_module module~json_string_utilities->module~json_file_module module~json_string_utilities->module~json_module var panmodulejson_kindsUsedByGraph = svgPanZoom('#modulejson_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: RK = real64 Default real kind [8 bytes] integer, public, parameter :: IK = int32 Default integer kind [4 bytes]. integer, public, parameter :: CDK = selected_char_kind('DEFAULT') Processor dependendant 'DEFAULT' character kind.\n  This is 1 byte for the Intel and Gfortran compilers. integer, public, parameter :: LK = logical_kinds(min(3, size(logical_kinds))) Default logical kind.\n  This is 4 bytes for the Intel and Gfortran compilers\n  (and perhaps others).\n  The declaration ensures a valid kind\n  if the compiler doesn't have a logical_kinds(3). character(kind=CDK,len=*), private, parameter :: json_fortran_string_kind = 'ISO_10646' String kind preprocessor macro. gfortran compiler AND UCS4 support requested: integer, public, parameter :: CK = selected_char_kind(json_fortran_string_kind) Default character kind used by JSON -Fortran.\n  If ISO 10646 (UCS4) support is available, use that,\n  otherwise, gracefully fall back on 'DEFAULT' characters.\n  Currently only gfortran >= 4.9.2 will correctly support\n  UCS4 which is stored in 4 bytes.\n  (and perhaps others).","tags":"","loc":"module/json_kinds.html","title":"json_kinds â€“ JSON-Fortran"},{"text":"Uses: json_kinds json_string_utilities json_value_module json_file_module module~~json_module~~UsesGraph module~json_module json_module module~json_file_module json_file_module module~json_file_module->module~json_module module~json_string_utilities json_string_utilities module~json_string_utilities->module~json_module module~json_string_utilities->module~json_file_module module~json_value_module json_value_module module~json_string_utilities->module~json_value_module module~json_kinds json_kinds module~json_kinds->module~json_module module~json_kinds->module~json_file_module module~json_kinds->module~json_string_utilities module~json_kinds->module~json_value_module module~json_parameters json_parameters module~json_kinds->module~json_parameters module~json_value_module->module~json_module module~json_value_module->module~json_file_module module~json_parameters->module~json_file_module module~json_parameters->module~json_string_utilities module~json_parameters->module~json_value_module iso_fortran_env iso_fortran_env iso_fortran_env->module~json_file_module iso_fortran_env->module~json_kinds iso_fortran_env->module~json_value_module var panmodulejson_moduleUsesGraph = svgPanZoom('#modulejson_moduleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A Fortran 2008 JSON (JavaScript Object Notation) API . This module provides access to json_value_module and json_file_module . For normal JSON -Fortran use, using this module\n  is all that is necessary. Note that this module renames the kind definition variables from json_kinds from [ RK , IK , LK , CK , and CDK ] to [ json_RK , json_IK , json_LK , json_CK , and json_CDK ] so as to avoid namespace pollution with short\n  variable names. Since USE_UCS4 is defined, this module also exports the\n  operators == , /= , and // from json_string_utilities for CK and CDK operations. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. History Joseph A. Levin : March 2012 : Original FSON code [retrieved on 12/2/2013]. Jacob Williams : 2/8/2014 : Extensive modifications to the original FSON code.\n    The original F95 code was split into four files:\n    fson_path_m.f95, fson_string_m.f95, fson_value_m.f95, and fson.f95.\n    The new code has been extensively updated, refactored and combined into this\n    one module (json_module.f90).\n    Various Fortran 2003/2008 features are now used\n    (e.g., allocatable strings, newunit, generic, class, and abstract interface). Development continues at: Github See also json-fortran development site json-fortran online documentation JSON website JSON validator Note Originally JSON -Fortran was entirely contained within this module.","tags":"","loc":"module/json_module.html","title":"json_module â€“ JSON-Fortran"},{"text":"Uses: json_kinds module~~json_parameters~~UsesGraph module~json_parameters json_parameters module~json_kinds json_kinds module~json_kinds->module~json_parameters iso_fortran_env iso_fortran_env iso_fortran_env->module~json_kinds Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Other parameters used by JSON -Fortran.\n  This is a low-level module not meant to be used by a JSON -Fortran user. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Used By module~~json_parameters~~UsedByGraph module~json_parameters json_parameters module~json_file_module json_file_module module~json_parameters->module~json_file_module module~json_value_module json_value_module module~json_parameters->module~json_value_module module~json_string_utilities json_string_utilities module~json_parameters->module~json_string_utilities module~json_module json_module module~json_file_module->module~json_module module~json_value_module->module~json_file_module module~json_value_module->module~json_module module~json_string_utilities->module~json_file_module module~json_string_utilities->module~json_value_module module~json_string_utilities->module~json_module Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(kind=CDK,len=*), public, parameter :: json_ext = '.json' JSON file extension character(kind=CK,len=*), public, parameter :: space = ' ' character(kind=CK,len=*), public, parameter :: start_object = '{' character(kind=CK,len=*), public, parameter :: end_object = '}' character(kind=CK,len=*), public, parameter :: start_array = '[' character(kind=CK,len=*), public, parameter :: end_array = ']' character(kind=CK,len=*), public, parameter :: delimiter = ',' character(kind=CK,len=*), public, parameter :: colon_char = ':' character(kind=CK,len=*), public, parameter :: start_array_alt = '(' for json_get_by_path character(kind=CK,len=*), public, parameter :: end_array_alt = ')' for json_get_by_path character(kind=CK,len=*), public, parameter :: root = '$' for json_get_by_path character(kind=CK,len=*), public, parameter :: this = '@' for json_get_by_path character(kind=CK,len=*), public, parameter :: child = '.' for json_get_by_path character(kind=CK,len=*), public, parameter :: bspace = achar(8) character(kind=CK,len=*), public, parameter :: horizontal_tab = achar(9) character(kind=CK,len=*), public, parameter :: newline = achar(10) character(kind=CK,len=*), public, parameter :: formfeed = achar(12) character(kind=CK,len=*), public, parameter :: carriage_return = achar(13) character(kind=CK,len=*), public, parameter :: quotation_mark = achar(34) character(kind=CK,len=*), public, parameter :: slash = achar(47) character(kind=CK,len=*), public, parameter :: backslash = achar(92) character(kind=CDK,len=*), public, parameter :: default_real_fmt = '(ss,E26.16E4)' default real number format statement (for writing real values to strings and files).\n Note that this can be overridden by calling json_initialize . character(kind=CK,len=*), public, parameter :: star = '*' for invalid numbers and\n list-directed real output character(kind=CK,len=26), protected :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' uppercase characters character(kind=CK,len=26), protected :: lower = 'abcdefghijklmnopqrstuvwxyz' lowercase characters character(kind=CK,len=4), protected :: null_str = 'null' JSON Null variable string character(kind=CK,len=4), protected :: true_str = 'true' JSON logical True string character(kind=CK,len=5), protected :: false_str = 'false' JSON logical False string integer, private :: i_ just a counter for control_chars array character(kind=CK,len=*), public, parameter, dimension(32) :: control_chars = [(achar(i_), i_=1, 31), achar(127)] Control characters, possibly in unicode integer(kind=IK), public, parameter :: rp_safety_factor = 1_IK integer(kind=IK), public, parameter :: rp_addl_safety = 1_IK integer(kind=IK), public, parameter :: real_precision = rp_safety_factor*precision(1.0_RK)+rp_addl_safety integer(kind=IK), public, parameter :: maxexp = maxexponent(1.0_RK) integer(kind=IK), public, parameter :: minexp = minexponent(1.0_RK) integer(kind=IK), public, parameter :: real_exponent_digits = floor(1+log10(real(max(maxexp, abs(maxexp)), kind=RK))) integer(kind=IK), public, parameter :: max_numeric_str_len = real_precision+real_exponent_digits+6 6 = sign + leading 0 + decimal + 'E' + exponent sign + 1 extra character(kind=CDK,len=*), public, parameter :: int_fmt = '(ss,I0)' minimum width format for integers integer(kind=IK), public, parameter :: chunk_size = 100_IK for allocatable strings: allocate chunks of this size integer(kind=IK), public, parameter :: unit2str = -1_IK unit number to cause stuff to be\n output to strings rather than files.\n See 9.5.6.12 in the F2003/08 standard integer(kind=IK), public, parameter :: seq_chunk_size = 256_IK chunk size for reading sequential files integer(kind=IK), public, parameter :: pushed_char_size = 10_IK magic number","tags":"","loc":"module/json_parameters.html","title":"json_parameters â€“ JSON-Fortran"},{"text":"Uses: json_kinds json_parameters module~~json_string_utilities~~UsesGraph module~json_string_utilities json_string_utilities module~json_kinds json_kinds module~json_kinds->module~json_string_utilities module~json_parameters json_parameters module~json_kinds->module~json_parameters module~json_parameters->module~json_string_utilities iso_fortran_env iso_fortran_env iso_fortran_env->module~json_kinds Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. JSON -Fortran support module for string manipulation. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Used By module~~json_string_utilities~~UsedByGraph module~json_string_utilities json_string_utilities module~json_file_module json_file_module module~json_string_utilities->module~json_file_module module~json_value_module json_value_module module~json_string_utilities->module~json_value_module module~json_module json_module module~json_string_utilities->module~json_module module~json_file_module->module~json_module module~json_value_module->module~json_file_module module~json_value_module->module~json_module Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface to_unicode Convert a 'DEFAULT' kind character input to\n  'ISO_10646' kind and return it private pure function to_uni (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) Description Author Izaak Beekman Convert string to unicode (CDK to CK). private pure function to_uni_vec (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Description Author Izaak Beekman Convert array of strings to unicode (CDK to CK). public interface operator(//) Provide a means to convert to UCS4 while\n concatenating UCS4 and default strings private pure function ucs4_join_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value character(kind=CK,len=(len(ucs4_str)+len(def_str))) Description Author Izaak Beekman CK // CDK operator. private pure function default_join_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value character(kind=CK,len=(len(def_str)+len(ucs4_str))) Description Author Izaak Beekman CDK // CK operator. public interface operator(==) Provide a string == operator that works\n with mixed kinds private pure elemental function ucs4_comp_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description Author Izaak Beekman CK == CDK operator. private pure elemental function default_comp_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description Author Izaak Beekman CDK == CK operator. public interface operator(/=) Provide a string /= operator that works\n with mixed kinds private pure elemental function ucs4_neq_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description Author Jacob Williams CK /= CDK operator. private pure elemental function default_neq_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description Author Jacob Williams CDK /= CK operator. Functions public pure function valid_json_hex (str) result(valid) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to check. Return Value logical(kind=LK) is str a value 4-digit hex string Description Author Jacob Williams Date 6/14/2014 Returns true if the string is a valid 4-digit hex string. private pure function to_uni (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) Description Author Izaak Beekman Convert string to unicode (CDK to CK). private pure function to_uni_vec (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Description Author Izaak Beekman Convert array of strings to unicode (CDK to CK). private pure function ucs4_join_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value character(kind=CK,len=(len(ucs4_str)+len(def_str))) Description Author Izaak Beekman CK // CDK operator. private pure function default_join_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value character(kind=CK,len=(len(def_str)+len(ucs4_str))) Description Author Izaak Beekman CDK // CK operator. private pure elemental function ucs4_comp_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description Author Izaak Beekman CK == CDK operator. private pure elemental function default_comp_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description Author Izaak Beekman CDK == CK operator. private pure elemental function ucs4_neq_default (ucs4_str, def_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description Author Jacob Williams CK /= CDK operator. private pure elemental function default_neq_ucs4 (def_str, ucs4_str) result(res) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description Author Jacob Williams CDK /= CK operator. private pure elemental function lowercase_character (c) result(c_lower) Arguments Type Intent Optional Attributes Name character(kind=CK,len=1), intent(in) :: c Return Value character(kind=CK,len=1) Description Author Jacob Williams Return the lowercase version of the CK character. public pure elemental function lowercase_string (str) result(s_lower) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str input string Return Value character(kind=CK,len=(len(str))) lowercase version of the string Description Author Jacob Williams Returns lowercase version of the CK string. Subroutines public pure subroutine integer_to_string (ival, int_fmt, str) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: ival integer value. character(kind=CDK,len=*), intent(in) :: int_fmt format for integers character(kind=CK,len=*), intent(out) :: str ival converted to a string. Description Author Jacob Williams Date 12/4/2013 Convert an integer to a string. public subroutine real_to_string (rval, real_fmt, compact_real, str) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: rval real value. character(kind=CDK,len=*), intent(in) :: real_fmt format for real numbers logical(kind=LK), intent(in) :: compact_real compact the string so that it is\n displayed with fewer characters character(kind=CK,len=*), intent(out) :: str rval converted to a string. Description Author Jacob Williams Date 12/4/2013 Convert a real value to a string. private subroutine compact_real_string (str) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(inout) :: str string representation of a real number. Description Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that\n  the same value is displayed with fewer characters. public subroutine escape_string (str_in, str_out) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in character(kind=CK,len=:), intent(out), allocatable :: str_out Description Author Jacob Williams Date 1/21/2014 Add the escape characters to a string for adding to JSON . public subroutine unescape_string (str_in, str_out, error_message) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in string as stored in a json_value character(kind=CK,len=:), intent(out), allocatable :: str_out decoded string character(kind=CK,len=:), intent(out), allocatable :: error_message will be allocated if there was an error Description Remove the escape characters from a JSON string and return it.","tags":"","loc":"module/json_string_utilities.html","title":"json_string_utilities â€“ JSON-Fortran"},{"text":"Uses: iso_fortran_env json_kinds json_parameters json_string_utilities module~~json_value_module~~UsesGraph module~json_value_module json_value_module module~json_parameters json_parameters module~json_parameters->module~json_value_module module~json_string_utilities json_string_utilities module~json_parameters->module~json_string_utilities module~json_string_utilities->module~json_value_module iso_fortran_env iso_fortran_env iso_fortran_env->module~json_value_module module~json_kinds json_kinds iso_fortran_env->module~json_kinds module~json_kinds->module~json_value_module module~json_kinds->module~json_parameters module~json_kinds->module~json_string_utilities Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. This module provides a low-level interface for manipulation of JSON data.\n  The two public entities are json_value , and json_core .\n  The json_file_module provides a higher-level interface to some\n  of these routines. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Used By module~~json_value_module~~UsedByGraph module~json_value_module json_value_module module~json_file_module json_file_module module~json_value_module->module~json_file_module module~json_module json_module module~json_value_module->module~json_module module~json_file_module->module~json_module Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, private, parameter :: use_unformatted_stream = .false. If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. character(kind=CDK,len=*), private, parameter :: access_spec = 'SEQUENTIAL' If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. character(kind=CDK,len=*), private, parameter :: form_spec = 'FORMATTED' If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. integer(kind=IK), public, parameter :: json_unknown = 0 Unknown JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_null = 1 Null JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_object = 2 Object JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_array = 3 Array JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_logical = 4 Logical JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_integer = 5 Integer JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_double = 6 Double JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_string = 7 String JSON data type Interfaces public interface json_core Structure constructor to initialize a json_core object private function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(json_core_object) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_core ) Description Author Jacob Williams Date 4/26/2016 Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Abstract Interfaces abstract interface public subroutine json_array_callback_func (json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description Array element callback function.  Used by json_get_array abstract interface public subroutine json_traverse_callback_func (json, p, finished) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: finished set true to stop traversing Description Callback function used by json_traverse Derived Types type, public, sequence  :: json_value Components Type Visibility Attributes Name Initial type( json_value ), private, pointer :: previous => null() previous item in the list type( json_value ), private, pointer :: next => null() next item in the list type( json_value ), private, pointer :: parent => null() parent item of this type( json_value ), private, pointer :: children => null() first child item of this type( json_value ), private, pointer :: tail => null() last child item of this character(kind=CK,len=:), private, allocatable :: name variable name real(kind=RK), private, allocatable :: dbl_value real data for this variable logical(kind=LK), private, allocatable :: log_value logical data for this variable character(kind=CK,len=:), private, allocatable :: str_value string data for this variable integer(kind=IK), private, allocatable :: int_value integer data for this variable integer(kind=IK), private :: var_type = json_unknown variable type integer(kind=IK), private :: n_children = 0 number of children Description Type used to construct the linked-list JSON structure.\n  Normally, this should always be a pointer variable.\n  This type should only be used by an instance of json_core . type, public :: json_core Components Type Visibility Attributes Name Initial integer(kind=IK), private :: spaces_per_tab = 2 number of spaces for indenting logical(kind=LK), private :: compact_real = .true. to use the \"compact\" form of real\n numbers for output character(kind=CDK,len=:), private, allocatable :: real_fmt the format string to use\n for converting real numbers to strings.\n It can be set in json_initialize ,\n and used in json_value_print If not set, then default_real_fmt is used instead. logical(kind=LK), private :: is_verbose = .false. if true, all exceptions are\n immediately printed to console. logical(kind=LK), private :: exception_thrown = .false. The error flag. Will be set to true\n when an error is thrown in the class.\n Many of the methods will check this\n and return immediately if it is true. character(kind=CK,len=:), private, allocatable :: err_message the error message integer(kind=IK), private :: char_count = 0 character position in the current line integer(kind=IK), private :: line_count = 1 lines read counter integer(kind=IK), private :: pushed_index = 0 used when parsing lines in file character(kind=CK,len=pushed_char_size), private :: pushed_char = '' used when parsing\n lines in file integer(kind=IK), private :: ipos = 1 for allocatable strings: next character to read logical(kind=LK), private :: strict_type_checking = .false. if true, then no type conversions are done\n in the get routines if the actual variable\n type is different from the return type (for\n example, integer to double). logical(kind=LK), private :: trailing_spaces_significant = .false. for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), private :: case_sensitive_keys = .true. for name and path comparisons, are they\n case sensitive. Constructor Structure constructor to initialize a json_core object private  function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Type-Bound Procedures generic, public :: get_child => json_value_get_by_index, json_value_get_child, json_value_get_by_name_chars, wrap_json_value_get_by_name_chars procedure, private :: json_value_get_by_index procedure, private :: wrap_json_value_get_by_name_chars procedure, private :: json_value_get_by_name_chars procedure, private :: json_value_get_child generic, public :: add => json_value_add_member, json_value_add_integer, wrap_json_value_add_integer, json_value_add_integer_vec, wrap_json_value_add_integer_vec, json_value_add_double, wrap_json_value_add_double, json_value_add_double_vec, wrap_json_value_add_double_vec, json_value_add_logical, wrap_json_value_add_logical, json_value_add_logical_vec, wrap_json_value_add_logical_vec, json_value_add_string, wrap_json_value_add_string, json_value_add_string_vec, wrap_json_value_add_string_vec Add objects to a linked list of json_value s. generic, public :: add => json_value_add_string_name_ascii, json_value_add_string_val_ascii, json_value_add_string_vec_name_ascii, json_value_add_string_vec_val_ascii procedure, private :: json_value_add_member procedure, private :: wrap_json_value_add_integer procedure, private :: json_value_add_integer procedure, private :: wrap_json_value_add_integer_vec procedure, private :: json_value_add_integer_vec procedure, private :: wrap_json_value_add_double procedure, private :: json_value_add_double procedure, private :: wrap_json_value_add_double_vec procedure, private :: json_value_add_double_vec procedure, private :: wrap_json_value_add_logical procedure, private :: json_value_add_logical procedure, private :: wrap_json_value_add_logical_vec procedure, private :: json_value_add_logical_vec procedure, private :: wrap_json_value_add_string procedure, private :: json_value_add_string procedure, private :: wrap_json_value_add_string_vec procedure, private :: json_value_add_string_vec procedure, private :: json_value_add_string_name_ascii procedure, private :: json_value_add_string_val_ascii procedure, private :: json_value_add_string_vec_name_ascii procedure, private :: json_value_add_string_vec_val_ascii generic, public :: update => json_update_logical, wrap_json_update_logical, json_update_double, wrap_json_update_double, json_update_integer, wrap_json_update_integer, json_update_string, wrap_json_update_string These are like the add methods, except if a child with the\n  same name is already present, then its value is simply updated.\n  Note that currently, these only work for scalar variables.\n  These routines can also change the variable's type (but an error will be\n  thrown if the existing variable is not a scalar). generic, public :: update => json_update_string_name_ascii, json_update_string_val_ascii procedure, private :: wrap_json_update_logical procedure, private :: json_update_logical procedure, private :: wrap_json_update_double procedure, private :: json_update_double procedure, private :: wrap_json_update_integer procedure, private :: json_update_integer procedure, private :: wrap_json_update_string procedure, private :: json_update_string procedure, private :: json_update_string_name_ascii procedure, private :: json_update_string_val_ascii generic, public :: get => json_get_by_path, wrap_json_get_by_path, json_get_integer, json_get_integer_with_path, wrap_json_get_integer_with_path, json_get_integer_vec, json_get_integer_vec_with_path, wrap_json_get_integer_vec_with_path, json_get_double, json_get_double_with_path, wrap_json_get_double_with_path, json_get_double_vec, json_get_double_vec_with_path, wrap_json_get_double_vec_with_path, json_get_logical, json_get_logical_with_path, wrap_json_get_logical_with_path, json_get_logical_vec, json_get_logical_vec_with_path, wrap_json_get_logical_vec_with_path, json_get_string, json_get_string_with_path, wrap_json_get_string_with_path, json_get_string_vec, json_get_string_vec_with_path, wrap_json_get_string_vec_with_path, json_get_array, json_get_array_with_path, wrap_json_get_array_with_path Get data from a json_value linked list. procedure, private :: json_get_integer procedure, private :: json_get_integer_vec procedure, private :: json_get_double procedure, private :: json_get_double_vec procedure, private :: json_get_logical procedure, private :: json_get_logical_vec procedure, private :: json_get_string procedure, private :: json_get_string_vec procedure, private :: json_get_array procedure, private :: wrap_json_get_by_path procedure, private :: json_get_by_path procedure, private :: wrap_json_get_integer_with_path procedure, private :: json_get_integer_with_path procedure, private :: wrap_json_get_integer_vec_with_path procedure, private :: json_get_integer_vec_with_path procedure, private :: wrap_json_get_double_with_path procedure, private :: json_get_double_with_path procedure, private :: wrap_json_get_double_vec_with_path procedure, private :: json_get_double_vec_with_path procedure, private :: wrap_json_get_logical_with_path procedure, private :: json_get_logical_with_path procedure, private :: wrap_json_get_logical_vec_with_path procedure, private :: json_get_logical_vec_with_path procedure, private :: wrap_json_get_string_with_path procedure, private :: json_get_string_with_path procedure, private :: wrap_json_get_string_vec_with_path procedure, private :: json_get_string_vec_with_path procedure, private :: wrap_json_get_array_with_path procedure, private :: json_get_array_with_path procedure, public :: print_to_string => json_value_to_string Print the json_value structure to an allocatable string generic, public :: print => json_print_1, json_print_2 Print the json_value to a file. procedure, private :: json_print_1 procedure, private :: json_print_2 generic, public :: destroy => json_value_destroy, destroy_json_core Destructor routine for a json_value pointer.\n  This must be called explicitly if it is no longer needed,\n  before it goes out of scope.  Otherwise, a memory leak will result. procedure, private :: json_value_destroy procedure, private :: destroy_json_core generic, public :: remove_if_present => json_value_remove_if_present, wrap_json_value_remove_if_present If the child variable is present, then remove it. procedure, private :: wrap_json_value_remove_if_present procedure, private :: json_value_remove_if_present generic, public :: create_double => json_value_create_double, wrap_json_value_create_double Allocate a json_value pointer and make it a double variable.\n  The pointer should not already be allocated. procedure, private :: wrap_json_value_create_double procedure, private :: json_value_create_double generic, public :: create_array => json_value_create_array, wrap_json_value_create_array Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. procedure, private :: wrap_json_value_create_array procedure, private :: json_value_create_array generic, public :: create_object => json_value_create_object, wrap_json_value_create_object Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. procedure, private :: wrap_json_value_create_object procedure, private :: json_value_create_object generic, public :: create_null => json_value_create_null, wrap_json_value_create_null Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. procedure, private :: wrap_json_value_create_null procedure, private :: json_value_create_null generic, public :: create_string => json_value_create_string, wrap_json_value_create_string Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. procedure, private :: wrap_json_value_create_string procedure, private :: json_value_create_string generic, public :: create_integer => json_value_create_integer, wrap_json_value_create_integer Allocate a json_value pointer and make it an integer variable.\n  The pointer should not already be allocated. procedure, private :: wrap_json_value_create_integer procedure, private :: json_value_create_integer generic, public :: create_logical => json_value_create_logical, wrap_json_value_create_logical Allocate a json_value pointer and make it a logical variable.\n  The pointer should not already be allocated. procedure, private :: wrap_json_value_create_logical procedure, private :: json_value_create_logical generic, public :: parse => json_parse_file, json_parse_string, wrap_json_parse_string Parse the JSON file and populate the json_value tree. procedure, private :: json_parse_file procedure, private :: wrap_json_parse_string procedure, private :: json_parse_string generic, public :: throw_exception => json_throw_exception, wrap_json_throw_exception Throw an exception. procedure, private :: wrap_json_throw_exception procedure, private :: json_throw_exception generic, public :: rename => json_value_rename, wrap_json_value_rename Rename a json_value variable. procedure, private :: wrap_json_value_rename procedure, private :: json_value_rename procedure, public :: remove => json_value_remove Remove a json_value from a linked-list structure. procedure, public :: check_for_errors => json_check_for_errors check for error and get error message procedure, public :: clear_exceptions => json_clear_exceptions clear exceptions procedure, public :: count => json_count count the number of children procedure, public :: clone => json_clone clone a JSON structure (deep copy) procedure, public :: failed => json_failed check for error procedure, public :: get_parent => json_get_parent get pointer to json_value parent procedure, public :: get_next => json_get_next get pointer to json_value next procedure, public :: get_previous => json_get_previous get pointer to json_value previous procedure, public :: get_tail => json_get_tail get pointer to json_value tail procedure, public :: info => json_info get info about a json_value procedure, public :: initialize => json_initialize to initialize some parsing parameters procedure, public :: traverse => json_traverse to traverse all elements of a JSON structure procedure, public :: print_error_message => json_print_error_message simply routine to print error messages procedure, public :: swap => json_value_swap Swap two json_value pointers\n in a structure (or two different structures). procedure, public :: is_child_of => json_value_is_child_of Check if a json_value is a child of another. procedure, public :: validate => json_value_validate Check that a json_value linked list is valid\n (i.e., is properly constructed). This may be\n useful if it has been constructed externally. procedure, private :: name_equal procedure, private :: json_value_print procedure, private :: string_to_integer procedure, private :: string_to_double procedure, private :: parse_value procedure, private :: parse_number procedure, private :: parse_string procedure, private :: parse_for_chars procedure, private :: parse_object procedure, private :: parse_array procedure, private :: annotate_invalid_json procedure, private :: pop_char procedure, private :: push_char procedure, private :: get_current_line_from_file_stream procedure, private :: get_current_line_from_file_sequential Description To access the core routines for manipulation\n  of json_value pointer variables. This class allows\n  for thread safe use of the module. Functions private function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(json_core_object) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_core ) Description Author Jacob Williams Date 4/26/2016 Function constructor for a json_core .\n  This is just a wrapper for json_initialize . private function name_equal (json, p, name) result(is_equal) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in) :: p the json object character(kind=CK,len=*), intent(in) :: name the name to check for Return Value logical(kind=LK) true if the string are lexically equal Description Author Jacob Williams Date 4/30/2016 Returns true if name is equal to p%name , using the specified\n  settings for case sensitivity and trailing whitespace. private pure function json_failed (json) result(failed) Arguments Type Intent Optional Attributes Name class( json_core ), intent(in) :: json Return Value logical(kind=LK) will be true if an exception\n has been thrown. Description Author Jacob Williams Date 12/5/2013 Logical function to indicate if an exception has been thrown in a json_core . private function json_value_is_child_of (json, p1, p2) result(is_child_of) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p1 type( json_value ), , pointer :: p2 Return Value logical(kind=LK) Description Author Jacob Williams Date 4/28/2016 Returns True if p2 is a descendant of p1 (i.e, a child, or a child of child, etc.) private function json_count (json, p) result(count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p Return Value integer(kind=IK) number of children Description Count the number of children. private function string_to_integer (json, str) result(ival) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value integer(kind=IK) Description Convert a string into an integer. private function string_to_double (json, str) result(rval) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value real(kind=RK) Description Author Jacob Williams Date 1/19/2014 Convert a string into a double. private recursive function pop_char (json, unit, str, eof, skip_ws) result(popped) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) â€“ only used if unit=0 logical(kind=LK), intent(out) :: eof true if the end of the file has been reached. logical(kind=LK), intent(in), optional :: skip_ws to ignore whitespace. Return Value character(kind=CK,len=1) the popped character. Description Get the next character from the file (or string). Subroutines private subroutine destroy_json_core (me) Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me Description Author Jacob Williams Date 4/17/2016 Destructor for the json_core type. private subroutine json_initialize (json, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Description Author Jacob Williams Date 12/4/2013 Initialize the json_core instance. private subroutine json_clone (json, from, to) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: from this is the structure to clone type( json_value ), , pointer :: to the clone is put here\n (it must not already be associated) Description Author Jacob Williams Date 10/31/2015 Create a deep copy of a json_value linked-list structure. private recursive subroutine json_value_clone_func (from, to, parent, previous, next, children, tail) Arguments Type Intent Optional Attributes Name type( json_value ), , pointer :: from this is the structure to clone type( json_value ), , pointer :: to the clone is put here\n (it must not already be associated) type( json_value ), , optional pointer :: parent to%parent type( json_value ), , optional pointer :: previous to%previous type( json_value ), , optional pointer :: next to%next type( json_value ), , optional pointer :: children to%children logical , optional :: tail if \"to\" is the tail of its parent's children Description Author Jacob Williams Date 10/31/2015 Recursive deep copy function called by json_clone . private subroutine destroy_json_data (d) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: d Description Author Jacob Williams Destroy the data within a json_value , and reset type to json_unknown . private subroutine json_info (json, p, var_type, n_children, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Description Author Jacob Williams Date 2/13/2014 Returns information about a json_value . private subroutine json_value_rename (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name Description Author Jacob Williams Date 4/29/2016 Rename a json_value . private subroutine wrap_json_value_rename (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name new variable name Description Author Jacob Williams Date 4/29/2016 Alternate version of json_value_rename , where name is kind=CDK. private pure subroutine json_clear_exceptions (json) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json Description Author Jacob Williams Date 12/4/2013 Clear exceptions in the json_core . private subroutine json_throw_exception (json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message Description Author Jacob Williams Date 12/4/2013 Throw an exception in the json_core .\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. private subroutine wrap_json_throw_exception (json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: msg the error message Description Alternate version of json_throw_exception , where msg is kind=CDK. private subroutine json_check_for_errors (json, status_ok, error_msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Description Author Jacob Williams Date 12/4/2013 Retrieve error code from the json_core .\n  This should be called after parse to check for errors.\n  If an error is thrown, before using the class again, json_initialize should be called to clean up before it is used again. private subroutine json_value_create (p) Arguments Type Intent Optional Attributes Name type( json_value ), , pointer :: p Description Allocate a json_value pointer variable.\n  This should be called before adding data to it. private recursive subroutine json_value_destroy (json, p, destroy_next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) Description Author Jacob Williams Date 1/22/2014 Destroy a json_value linked-list structure. private subroutine json_value_remove (json, p, destroy) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. Description Author Jacob Williams Date 9/9/2014 Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure. private subroutine json_value_swap (json, p1, p2) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p1 type( json_value ), , pointer :: p2 Description Author Jacob Williams Date 4/26/2016 Swap two elements in a JSON structure.\n  All of the children are carried along as well. private subroutine json_value_validate (json, p, is_valid, error_msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: is_valid True if the structure is valid. character(kind=CK,len=:), , allocatable :: error_msg if not valid, this will contain\n a description of the problem Description Author Jacob Williams Date 5/2/2016 Validate a json_value linked list by checking to make sure\n  all the pointers are properly associated, arrays and objects\n  have the correct number of children, and the correct data is\n  allocated for the variable types. private subroutine json_value_remove_if_present (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Date 12/6/2014 Given the path string, remove the variable from\n  the json_value structure, if it exists. private subroutine wrap_json_value_remove_if_present (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Alternate version of json_value_remove_if_present , where name is kind=CDK. private subroutine json_update_logical (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_update_logical (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_logical , where name is kind=CDK. private subroutine json_update_double (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_update_double (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_double , where name is kind=CDK. private subroutine json_update_integer (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_update_integer (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_integer , where name is kind=CDK. private subroutine json_update_string (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private subroutine wrap_json_update_string (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where name and value are kind=CDK. private subroutine json_update_string_name_ascii (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where name is kind=CDK. private subroutine json_update_string_val_ascii (json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where val is kind=CDK. private subroutine json_value_add_member (json, p, member) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p type( json_value ), , pointer :: member the child member to add Description Adds member as a child of p . private subroutine json_value_add_double (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Author Jacob Williams Date 1/19/2014 Add a real value child to the json_value variable private subroutine wrap_json_value_add_double (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Alternate version of json_value_add_double where name is kind=CDK. private subroutine json_value_add_double_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Author Jacob Williams Date 1/20/2014 Add a real vector to the structure. private subroutine wrap_json_value_add_double_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Alternate version of json_value_add_double_vec where name is kind=CDK. private subroutine json_value_add_integer (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val Description Author Jacob Williams Date 1/20/2014 Add an integer value child to the json_value variable private subroutine wrap_json_value_add_integer (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in) :: val value Description Alternate version of json_value_add_integer where name is kind=CDK. private subroutine json_value_add_integer_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Author Jacob Williams Date 1/20/2014 Add an integer vector to the structure. private subroutine wrap_json_value_add_integer_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_integer_vec where name is kind=CDK. private subroutine json_value_add_logical (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Author Jacob Williams Date 1/20/2014 Add a logical value child to the json_value variable private subroutine wrap_json_value_add_logical (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Alternate version of json_value_add_logical where name is kind=CDK. private subroutine json_value_add_logical_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value Description Author Jacob Williams Date 1/20/2014 Add a logical vector to the structure. private subroutine wrap_json_value_add_logical_vec (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_logical_vec where name is kind=CDK. private subroutine json_value_add_string (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Author Jacob Williams Date 1/19/2014 Add a character string child to the json_value variable. private subroutine wrap_json_value_add_string (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where name and val are kind=CDK. private subroutine json_value_add_string_name_ascii (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where name is kind=CDK. private subroutine json_value_add_string_val_ascii (json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where val is kind=CDK. private subroutine json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Description Author Jacob Williams Date 1/19/2014 Add an array of character strings to the structure. private subroutine wrap_json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where name and val are kind=CDK. private subroutine json_value_add_string_vec_name_ascii (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where name is kind=CDK. private subroutine json_value_add_string_vec_val_ascii (json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where val is kind=CDK. private subroutine json_get_parent (json, p, parent) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: parent pointer to parent Description Author Jacob Williams Date 10/16/2015 Returns a pointer to the parent of a json_value .\n  If there is no parent, then a null() pointer is returned. private subroutine json_get_next (json, p, next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: next pointer to next Description Author Jacob Williams Date 10/31/2015 Returns a pointer to the next of a json_value .\n  If there is no next, then a null() pointer is returned. private subroutine json_get_previous (json, p, previous) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: previous pointer to previous Description Author Jacob Williams Date 10/31/2015 Returns a pointer to the previous of a json_value .\n  If there is no previous, then a null() pointer is returned. private subroutine json_get_tail (json, p, tail) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: tail pointer to tail Description Author Jacob Williams Date 10/31/2015 Returns a pointer to the tail of a json_value (the last child of an array of object).\n  If there is no tail, then a null() pointer is returned. private subroutine json_value_get_by_index (json, p, idx, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child type( json_value ), , pointer :: child pointer to the child Description Returns a child in the object or array given the index. private subroutine json_value_get_child (json, p, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), , pointer :: child pointer to the child Description Returns pointer to the first child of the object\n  (or null() if it is not associated). private subroutine json_value_get_by_name_chars (json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), , pointer :: child pointer to the child Description Returns a child in the object or array given the name string. private subroutine wrap_json_value_get_by_name_chars (json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name type( json_value ), , pointer :: child Description Alternate version of json_value_get_by_name_chars where name is kind=CDK. private subroutine json_value_to_string (json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string Description Author Jacob Williams Date 2/12/2014 Print the json_value structure to an allocatable string. private subroutine json_print_1 (json, p, iunit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must already have been opened, can't be -1). Description Author Jacob Williams Date 6/20/2014 Print the json_value structure to a file. private subroutine json_print_2 (json, p, filename) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to (should not already be open) Description Author Jacob Williams Date 12/23/2014 Print the json_value structure to a file. private recursive subroutine json_value_print (json, p, iunit, str, indent, need_comma, colon, is_array_element) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit file unit to write to (6=console) character(kind=CK,len=:), intent(inout), allocatable :: str if iunit==unit2str (-1) then the structure is\n printed to this string rather than\n a file. This mode is used by json_value_to_string . integer(kind=IK), intent(in), optional :: indent indention level logical(kind=LK), intent(in), optional :: need_comma if it needs a comma after it logical(kind=LK), intent(in), optional :: colon if the colon was just written logical(kind=LK), intent(in), optional :: is_array_element if this is an array element Description Print the JSON structure to a string or a file. private subroutine json_get_by_path (json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable specify by path logical(kind=LK), intent(out), optional :: found true if it was found Description Returns the json_value pointer given the path string. private subroutine wrap_json_get_by_path (json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_by_path where \"path\" is kind=CDK. private subroutine json_get_integer (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value Description Get an integer value from a json_value . private subroutine json_get_integer_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get an integer value from a json_value , given the path string. private subroutine wrap_json_get_integer_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_with_path , where \"path\" is kind=CDK. private subroutine json_get_integer_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get an integer vector from a json_value . private subroutine json_get_integer_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get an integer vector from a json_value , given the path string. private subroutine wrap_json_get_integer_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_vec_with_path , where \"path\" is kind=CDK private subroutine json_get_double (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out) :: value Description Get a double value from a json_value . private subroutine json_get_double_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get a double value from a json_value , given the path. private subroutine wrap_json_get_double_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_with_path , where \"path\" is kind=CDK private subroutine json_get_double_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a double vector from a json_value . private subroutine json_get_double_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a double vector from a json_value , given the path. private subroutine wrap_json_get_double_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_vec_with_path , where \"path\" is kind=CDK private subroutine json_get_logical (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK) :: value Description Get a logical value from a json_value . private subroutine json_get_logical_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found Description Get a logical value from a json_value , given the path. private subroutine wrap_json_get_logical_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_with_path , where \"path\" is kind=CDK private subroutine json_get_logical_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a logical vector from json_value . private subroutine json_get_logical_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical vector from a json_value , given the path. private subroutine wrap_json_get_logical_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_vec_with_path , where \"path\" is kind=CDK private subroutine json_get_string (json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value Description Get a character string from a json_value . private subroutine json_get_string_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Get a character string from a json_value , given the path. private subroutine wrap_json_get_string_with_path (json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_with_path , where \"path\" is kind=CDK private subroutine json_get_string_vec (json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec Description Author Jacob Williams Date 5/14/2014 Get a string vector from a json_value . private subroutine json_get_string_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a json_value , given the path. private subroutine wrap_json_get_string_vec_with_path (json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_vec_with_path , where \"path\" is kind=CDK private subroutine json_get_array (json, me, array_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure( json_array_callback_func ) :: array_callback Description This routine calls the user-supplied json_array_callback_func subroutine\n      for each element in the array. private subroutine json_traverse (json, p, traverse_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p procedure( json_traverse_callback_func ) :: traverse_callback Description Author Jacob Williams Date 4/28/2016 Traverse a JSON structure.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. private subroutine json_get_array_with_path (json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Description This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). private subroutine wrap_json_get_array_with_path (json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_array_with_path , where \"path\" is kind=CDK private subroutine json_parse_file (json, file, p, unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), , pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) Description Parse the JSON file and populate the json_value tree. private subroutine json_parse_string (json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data Description Parse the JSON string and populate the json_value tree. private subroutine wrap_json_parse_string (json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CDK,len=*), intent(in) :: str string with JSON data Description Alternate version of json_parse_string , where str is kind=CDK. private subroutine annotate_invalid_json (json, iunit, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=*), intent(in) :: str string with JSON data Description Generate a warning message if there was an error parsing a JSON file or string. private subroutine get_current_line_from_file_sequential (json, iunit, line) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Description Author Jacob Williams Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the SEQUENTIAL version (see also get_current_line_from_file_stream ). private subroutine get_current_line_from_file_stream (json, iunit, line) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Description Author Jacob Williams Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the STREAM version (see also get_current_line_from_file_sequential ). private recursive subroutine parse_value (json, unit, str, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number character(kind=CK,len=*), intent(in) :: str string containing JSON data (only used if unit=0) type( json_value ), , pointer :: value JSON data that is extracted Description Core parsing routine. private subroutine json_value_create_logical (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name Description Author Jacob Williams Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_logical (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrapper for json_value_create_logical so create_logical method can\n  be called with name of character kind 'DEFAULT' or 'ISO_10646' private subroutine json_value_create_integer (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_integer (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper procedure for json_value_create_integer so that create_integer method may be called with either a 'DEFAULT' or 'ISO_10646' character kind name actual argument. private subroutine json_value_create_double (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_double (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper for json_value_create_double so that create_double method\n  may be called with an actual argument corresponding to the dummy argument, name that may be of 'DEFAULT' or 'ISO_10646' character kind. private subroutine json_value_create_string (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_string (json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_string so that create_string method may be called\n  with actual character string arguments for name and val that are BOTH of\n  'DEFAULT' or 'ISO_10646' character kind. private subroutine json_value_create_null (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_null (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_null so that create_null method may be called with\n  an actual argument corresponding to the dummy argument name that is either\n  of 'DEFAULT' or 'ISO_10646' character kind. private subroutine json_value_create_object (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_object (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman Wrap json_value_create_object so that create_object method may be called\n  with an actual argument corresponding to the dummy argument name that is of\n  either 'DEFAULT' or 'ISO_10646' character kind. private subroutine json_value_create_array (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name Description Author Jacob Williams Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. private subroutine wrap_json_value_create_array (json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Author Izaak Beekman A wrapper for json_value_create_array so that create_array method may be\n  called with an actual argument, corresponding to the dummy argument name ,\n  that is either of 'DEFAULT' or 'ISO_10646' character kind. private subroutine to_logical (p, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p logical(kind=LK), intent(in), optional :: val if the value is also to be set (if not present, then .false. is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Author Jacob Williams Change the json_value variable to a logical. private subroutine to_integer (p, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p integer(kind=IK), intent(in), optional :: val if the value is also to be set (if not present, then 0 is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Author Jacob Williams Change the json_value variable to an integer. private subroutine to_double (p, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p real(kind=RK), intent(in), optional :: val if the value is also to be set (if not present, then 0.0_rk is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Author Jacob Williams Change the json_value variable to a double. private subroutine to_string (p, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p character(kind=CK,len=*), intent(in), optional :: val if the value is also to be set (if not present, then '' is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Author Jacob Williams Change the json_value variable to a string. private subroutine to_null (p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Author Jacob Williams Change the json_value variable to a null. private subroutine to_object (p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Author Jacob Williams Change the json_value variable to an object. private subroutine to_array (p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Author Jacob Williams Change the json_value variable to an array. private recursive subroutine parse_object (json, unit, str, parent) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: parent the parsed object will be added as a child of this Description Core parsing routine. private recursive subroutine parse_array (json, unit, str, array) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: array Description Core parsing routine. private subroutine parse_string (json, unit, str, string) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=:), intent(out), allocatable :: string Description Parses a string while reading a JSON file. private subroutine parse_for_chars (json, unit, str, chars) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=*), intent(in) :: chars the string to check for. Description Core parsing routine. private subroutine parse_number (json, unit, str, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), , pointer :: value Description Author Jacob Williams Date 1/20/2014 Read a numerical value from the file (or string).\n  The routine will determine if it is an integer or a double, and\n  allocate the type accordingly. private subroutine push_char (json, c) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=1), intent(in) :: c Description Core routine. private subroutine json_print_error_message (json, io_unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer, intent(in), optional :: io_unit Description Author Jacob Williams Print any error message, and then clear the exceptions.","tags":"","loc":"module/json_value_module.html","title":"json_value_module â€“ JSON-Fortran"},{"text":"Current Stable Release The latest stable release is 5.0.2 . 1 Past Releases Documentation for official, tagged releases can be found here , including the changelog , and download\nlinks. Development Documentation Additional documentation useful to JSON -Fortran contributors can be\nfound here , including contributing guidelines\nand test coverage reports. General Documentation A README , the same one that's posted on GitHub , can be found here . Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page//index.html","title":"Other Docs â€“ JSON-Fortran"},{"text":"JSON -Fortran A Fortran 2008 JSON API Table of Contents JSON -Fortran Status Brief description Download Building the library Documentation Contributing License Miscellaneous Status Take a look at the CHANGELOG for a list of changes since the latest release. top Brief description A user-friendly, thread-safe, and object-oriented API for reading and writing JSON files, written in modern Fortran. top Download Download the official versioned releases here .\nOr, get the latest development code from the master branch here . NEWS: As of June 7, 2015, json-fortran can be\ndownloaded and installed with the homebrew package\nmanager on Mac OS X. Once homebrew is installed,\nmake sure that the formulae are up to date, view the package options\nand caveats, and install the json-fortran formula : brew update\nbrew info json-fortran\nbrew install --with-unicode-support json-fortran Please note , if you wish to support usage of JSON -Fortran with\nmultiple Fortran compilers, please follow the CMake installation\ninstructions below, as the homebrew installation is only intended to\nsupport a single Fortran compiler. Cheers! top Building the library The code requires a Fortran compiler that supports\nvarious Fortran 2003 and Fortran 2008 features such as: allocatable\nstrings, newunit , generic , class , and abstract interface .\nIt has been successfully compiled with the Intel Fortran compiler\n13.1.0 (and greater) and the GNU gfortran\ncompiler [4.9 and greater]. It has also\nbeen reported that the library can be built (using the CMake build\nscript) with the NAG Fortran compiler 6.0 Currently, several ways are provided to build the JSON -fortran library\n(libjsonfortran). A build script, build.sh is provided in the project root directory. This script uses FoBiS to build the JSON -Fortran library and the unit tests.  Edit the script to use either the Intel Fortran Compiler or Gfortran .  Note that version 1.2.5 of FoBiS (or later) is required. A Visual Studio project is included for building the library (and unit tests) on Windows with the Intel Fortran Compiler.  The project has been tested with Visual Studio 2010 and 2013. A CMake build\nsystem is provided. This build system has been tested on Mac and Linux\nusing the Intel Fortran Compiler, gfortran 4.9, and NAG Fortran 6.0. It has not been\ntested on Windows. This CMake based build provides an install target,\nand exports from both the install location and the build location so\nthat building and using JSON -Fortran in another CMake based project is\ntrivial. To get started with the CMake based build, set the\nenvironment variable FC to point to your Fortran compiler, and\ncreate a build directory. Then (cmake-gui|ccmake|cmake)\n/path/to/json-fortran-root to configure, make to build and make\ninstall to optionally install. As long as the project is built with\nCMake, other CMake projects can find it and link against it. For example,\nif you have a second copy of the JSON -Fortran project tree, and want to build the unit tests\nlinking against those compiled/installed by the first copy: cmake_minimum_required ( VERSION 2.8.8 FATAL_ERROR ) enable_language ( Fortran ) project ( jf_test NONE ) find_package ( jsonfortran- ${ CMAKE_Fortran_COMPILER_ID } 5.0.2 REQUIRED ) include_directories ( \"${jsonfortran_INCLUDE_DIRS}\" ) file ( GLOB JF_TEST_SRCS \"src/tests/jf_test_*.f90\" ) foreach ( UNIT_TEST ${ JF_TEST_SRCS } ) get_filename_component ( TEST ${ UNIT_TEST } NAME_WE ) add_executable ( ${ TEST } ${ UNIT_TEST } ) target_link_libraries ( ${ TEST } jsonfortran-static ) # or for linking against the dynamic/shared library: # target_link_libraries ( ${TEST} jsonfortran ) # instead endforeach () top Documentation The API documentation for the latest release version can be found here .  The\ndocumentation can also be generated by processing the source files\nwith FORD .  Note that both the\nshell script and CMake will also generate these files automatically in the documentation folder, assuming you have FORD installed. Some examples can also be found on the wiki . top Contributing Want to help?  Take a quick look at our contributing guidelines then claim something in the \"ready\" column on our Waffle.io and Fork. Commit. Pull request. top License The JSON -Fortran source code and related files and documentation are distributed under a permissive free software license (BSD-style).  See the LICENSE file for more details. top Miscellaneous JSON -Fortran is a fork and extensive upgrade of the Fortran 95 FSON code. The reason for the split was to be able to incorporate object-oriented and other nice features of the Fortran 2003 and 2008 standards.  Many thanks to the original authors of FSON. For more information about JSON , see: http://www.json.org/ json-fortran on Travis CI json-fortran on Waffle.IO json-fortran on Codecov.IO top Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/./README.html","title":"Github README â€“ JSON-Fortran"},{"text":"This page is a place to collect resources which are useful to JSON -Fortran contributors and developers. Contributing The guidelines for contributing to JSON -Fortran can be found here . Please read these before posting issues or opening pull requests . Also,\nplease carefully read the LICENSE before using JSON -Fortran in an application, or contributing code. Test Coverage Information The best place to start when trying to increase test coverage, is to\nlook at the procedure level coverage report automatically generated by FoBiS.py . If all procedures are\nlisted as covered, then please take a look at the Codecov.io coverage info . Scripts Scripts used to build and test JSON -Fortran. This is a partial list of\nscripts used in building and testing JSON -Fortran, as well as\ndeploying documentation and managing test coverage information. build.sh deploy.sh .travis.yml codecov.yml gccr.pl Release Checklist This is a\nchecklist of tasks to be performed when tagging a new release of JSON -Fortran. The current stable version is 5.0.2 . Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/index.html","title":"Development Resources â€“ JSON-Fortran"},{"text":"Contributing to JSON -Fortran Looking to contribute something to JSON -Fortran ? Here's how you can help. Table of Contents Key Branches Filing issues Outstanding Work Pull Requests Coding Standards Key Branches master is the latest, development version and all efforts should be made to keep it stable. top Filing issues Before filing a new issue , please perform a search to see if that issue has already been filed by someone else, and whether or not a solution exists. If you are experiencing the same issue as one that's already posted, please leave any additional comments and information under the existing issue. If your issue is related to a previous issue, but substantively different, file a new issue and include a mention of the related issue in text, using Jib's #<issue-number> syntax. When filing an issue please try to include all of the following information Problem description: What behavior are you seeing that you think is erroneous Installation method: Did you build the code with one of the included build scripts? Some other way? Install from a binary package? What type of system you are on: E.g., 64 bit Intel Mac OS X 10.10.2 (Yosemite) or x86_64 Ubuntu 14.04 LTS (Trusty Tahr) If applicable, what compiler you used, and any non-standard options or configurations that were used. All steps required to reproduce the problem top Outstanding Work Take a look at the issues to see if there is an issue you'd like to help address. Issues with the ready label or in the ready column on waffle.io are issues that are ready to be dealt with. (i.e., They are not blocked by other dependencies and are higher priority.) Increasing the test coverage is another helpful way to\n  contribute. Please take a look at the test coverage page for a list of uncovered procedures, and at the Codecov.io coverage status to find procedures and lines of code that are still uncovered by the unit tests . It\n  is worth pointing out that the majority of uncovered procedures are\n  internal, overloaded procedures and can only be exercised by calling\n  the corresponding generic procedure with input arguments that will\n  resolve to the specific procedure in question. Let's keep the\n  following graph trending upwards! top Pull Requests Try not to pollute your pull request with unintended changesâ€“keep them simple and small Pull requests should address one issue at a time, and each commit should be a set of self contained, related changes. If you forget something in a commit, please use git rebase -i <ref>&#94; to amend and/or squash erroneous commits. Here <ref> is the reference to to oldest commit needing to be modified (SHA, or HEAD~4 , etc.) Each commit should compile, and ideally pass the tests. Very complicated new features or fixes, may have commits that don't pass tests, if otherwise the commit history would include far to many changes in any given commit. Use an interactive rebase to fix any of these issues, as described above. Each commit should have a concise, descriptive message following the\n  guidelines laid out here . Make sure to document your changes in the CHANGELOG under the 'unreleased' heading. Pull requests should always be based on the upstream master, jacobwilliams/json-fortran:master . Please rebase your branch on top\nof the latest upstream master. Assuming you are on your branch and you've added the upstream remote by running something like: git remote add upstream git://github.com/jacobwilliams/json-fortran.git You can accomplish this by running: git rebase upstream/master Create a branch in your fork with a descriptive name that also includes the issue number , if applicable. For example, after forking the repo, you can run something like git checkout -b Unicode-support-issue-35 before starting work on issue #35 : Unicode support When you're content with your changes, your commits are clean, self contained, with concise descriptive messages, and your changes compile and pass the tests, submit a pull request. We will review your changes, and may ask for certain modifications to be made. Pull requests are tested by our travis-ci continuous integration system, and any errors uncovered will need to be fixed before the pull request can be merged into master. The JSON -Fortran library and associated documentation is released under a BSD style license .  By submitting a pull request, you are agreeing to release your code under the same license.  Note that code with GPL or other \"copyleft\" style licenses will not be accepted. top Coding Standards Each commit should address a single logical change and code base transformation. Each commit must compile. Each commit should pass the tests unless the feature being implemented or bug being fixed requires extensive changes that would result in a commit with too many different changes. Each pull request should ensure that the proper unit tests have\n  been added to cover at least 90% of new or changed code and that the\n  overall coverage continues to increase. New tests are added to the src/tests directory and are named jf_test_<#>.[Ff]90 . Each test is a stand alone Fortran program\n  which will automatically be compiled and linked against the JSON -Fortran library so long as it follows this naming\n  convention. If any of the tests fail, the test program should exit\n  with a non-zero return status, using the stop 2 intrinsic\n  statement. (The Fortran standard does not require the 'processor' to\n  have or set a return value, but in practice all compilers respect\n  this convention. An integer other than 2 may be used, so long as\n  it is non-zero and supported by the processor.) No extraneous white spaces are allowed to be introduced at line endings and all non binary files should end with a single new line. Run git config core.whitespace trailing-space,space-before-tab,blank-at-eol,blank-at-eof to setup the whitespace rules from within your fork, and then check for white space errors with git diff --check to see if you have accidentally introduced white space errors before committing. (You can also enable the sample pre-commit hook that ships with git, to prevent you from committing changes that introduce white space errors. See this stackoverflow question ) for some tips on preventing the introduction of whitespace errors. Please adhere to the code indentation and formatting as it currently exists, aligning common elements vertically, etc. Tab characters are not allowed. Indentations should be done with 4 space characters. Do NOT allow your editor to make a bunch of indentation or white space changes, that will introduce non-substantive changes on lines that you have not actually edited. The coding style is modern free-form Fortran, consistent with the Fortran 2008 standard.  Note that the two supported compilers (ifort and gfortran) do not currently include the entire Fortran 2008 standard. Therefore, only those language features supported by Gfortran 4.9 and Intel 13.1.0 are currently allowed.  This also means that previous versions of these compilers are not supported, and major changes to the code to support earlier compilers (or Fortran 95) will not be accepted.  At some point in the future (when compiler support has improved), all Fortran 2008 features will be allowed. All subroutines and functions must be properly documented.  This includes useful inline comments as well as comment blocks using the FORD syntax. top Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/CONTRIBUTING.html","title":"Contributing Guidelines â€“ JSON-Fortran"},{"text":"JSON -Fortran: A Fortran 2008 JSON API https://github.com/jacobwilliams/json-fortran Copyright (c) 2014-2016, Jacob Williams\nAll rights reserved. Redistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution. The names of its contributors may not be used to endorse or promote products\n  derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Original FSON License: Copyright (c) 2012 Joseph A. Levin Permission is hereby granted, free of charge, to any person obtaining a copy of this\nsoftware and associated documentation files (the \"Software\"), to deal in the Software\nwithout restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or\nsubstantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\nOR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE. Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/LICENSE.html","title":"JSON-Fortran License â€“ JSON-Fortran"},{"text":"Below is the build script used to build JSON -Fortran using FoBiS.py . #!/bin/bash # #  NAME #    build.sh # #  DESCRIPTION #    Build the JSON-Fortran library and unit tests. # #  USAGE #    build.sh [--compiler {intel|gnu|<other>}] [--cflags '<custom compiler flags here>'] #             [--coverage [{yes|no}]] [--profile [{yes|no}]] [--skip-tests [{yes|no}]] #             [--skip-documentation [{yes|no}]] [--enable-unicode [{yes|no}]] [--help] #             [--clean] # #    By default, if invoked without any flags, this build script will build the #    JSON-Fortran library using gfortran, #        without : #            unicode support #            coverage flags #            profiling flags #        with : #            unit tests enabled #            documentation (if FORD is installed) # #     More recent (right-most) flags will override preceding flags #     flags: #        --compiler : gnu or gfortran for gfortran, intel or ifort for intel compiler #                     A custom compiler may also be specified here, e.g. ftn # #        --cflags : Enter any aditiol/custom compiler flags here and make sure they are #                   properly quoted # #        --help : Print a usage message and exit. # #        --clean : Delete generated files and clean up after builds # # #        The following flags all (optionally) accept an argument, \"yes\" or \"no.\" If #        no argument is passed, \"yes\" will be assumed. # #        --enable-unicode [{yes|no}]: Request that the JSON-Fortran be built with (or #                                     without) unicode/UCS4 support. If your compiler #                                     does NOT support ISO 10646/UCS4 and it was #                                     requested, then a warning is printed and the #                                     library is built without UCS4 support. # #        --coverage [{yes|no}]: Compile the library and tests with code coverage enabled #                               or disabled. # #        --profile [{yes|no}]: Compile the library and tests with code profiling enabled #                              or disabled # #        --skip-tests [{yes|no}]: Skip (or don't skip) building and running the json- #                                 fortran unit tests # #        --skip-documentation [{yes|no}]: Skip (or don't skip) building the json- #                                         fortran documentation using FORD # #  REQUIRES #    FoBiS.py : https://github.com/szaghi/FoBiS      [version 1.2.5 or later required] #    FORD     : https://github.com/cmacmackin/ford   [version 4.0.0 or later] # #  AUTHOR #    Jacob Williams : 12/27/2014 # set -o errexit FORDMD = 'json-fortran.md' # FORD options file for building documentation DOCDIR = './doc/' # build directory for documentation PAGESDIR = './pages/' # Directory for FORD \"pages\" SRCDIR = './src/' # library source directory TESTDIR = './src/tests/' # unit test source directory INTROSPECDIR = './src/tests/introspection/' # pre compile configuration tests directory UCS4TESTCODE = 'test_iso_10646_support.f90' BINDIR = './bin/' # build directory for unit tests LIBDIR = './lib/' # build directory for library MODCODE = 'json_module.F90' # json module file name LIBOUT = 'libjsonfortran.a' # name of json library FPP = \"gfortran -E\" # default to gfortran -E pre-processing # The following warning might be triggered by ifort unless explicitly silenced: # warning #7601: F2008 standard does not allow an internal procedure to be an actual argument procedure name. (R1214.4). # In the context of F2008 this is an erroneous warning. # See https://prd1idz.cps.intel.com/en-us/forums/topic/486629 INTELCOMPILERFLAGS = '-c -O2 -warn -stand f08 -diag-disable 7601 -diag-disable 4013 -diag-disable 5142 -traceback' #INTELCOMPILERFLAGS='-c -O2 -warn -traceback -stand f08 -assume protect_parens -assume buffered_io -check all' GNUCOMPILERFLAGS = '-c -O2 -fbacktrace -Wall -Wextra -Wno-maybe-uninitialized -Wno-unused-function -pedantic -std=f2008 -fno-omit-frame-pointer' FCOMPILER = 'gnu' #Set default compiler to gfortran # command line argument parsing # N.B.: Arguments appearing later in the list take precidence over those appearing earlier. #       e.g., \"./build.sh --compiler intel --coverage no --compiler gnu --coverage\" will #       perform the build with the GFORTRAN compiler, and coverage analysis script_name = \" $( basename \" $0 \" ) \" # usage message print_usage () { echo -e \"\\n\\nUsage:\\n\" echo -e \" ${ script_name } [--compiler {intel|gnu|<other>}] [--cflags '<custom compiler flags here>']\\n\\ [--coverage [{yes|no}]] [--profile [{yes|no}]] [--skip-tests [{yes|no}]]\\n\\ [--skip-documentation [{yes|no}]] [--enable-unicode [{yes|no}]] [--help]\" echo \"\" echo -e \"Any flags that take an optional yes or no argument will default to 'yes' when no\\n\\ argument is passed. Additionally, A custom compiler may be passed to the 'compiler'\\n\\ flag, but appropriate 'cflags' should also be passed to the script.\\n\\n\" } while [ \" $# \" -ge \"1\" ] ; do # Get command line arguments while there are more left to process key = \" $1 \" # Command line args are key-value pairs or value-less keys case $key in #find known keys --compiler ) #pick the compiler. Defaults to gfortran, but intel or custom compilers can be used case \" $2 \" in\n        intel | Intel | INTEL | ifort ) FCOMPILER = 'Intel' FCOMPILERFLAGS = \" $INTELCOMPILERFLAGS \" FPP = \"fpp\" shift ;; gnu | Gnu | GNU | gfortran | Gfortran | GFortran | GFORTRAN ) FCOMPILER = 'gnu' FCOMPILERFLAGS = \" $GNUCOMPILERFLAGS \" FPP = \"gfortran -E\" shift ;; * ) FCOMPILER = \"custom\" echo \"Warning: Trying to build with unsupported compiler, $2 .\" 1> & 2 echo \"Please ensure you set appropriate --cflags and (single) quote them\" 1> & 2 FC = \" $2 \" FPP = \"gfortran -E\" # try gfortran to preprocess as a default shift ;; esac ;; --cflags ) FCOMPILERFLAGS = \" $2 \" # no good way to check that the user didn't do something questionable shift ;; --enable-unicode ) case $2 in\n        yes | Yes | YES ) TRY_UNICODE = \"yes\" shift ;; no | No | NO ) TRY_UNICODE = \"no\" shift ;; * ) TRY_UNICODE = \"yes\" # don't shift; $2 is next arg ;; esac ;; --coverage ) # enable coverage case $2 in\n        yes | Yes | YES ) CODE_COVERAGE = \"yes\" shift ;; no | No | NO ) CODE_COVERAGE = \"no\" shift ;; * ) CODE_COVERAGE = \"yes\" # don't shift because $2 is some other flag ;; esac ;; --profile ) #nable profiling case $2 in\n        yes | Yes | YES ) CODE_PROFILE = \"yes\" shift ;; no | No | NO ) CODE_PROFILE = \"no\" shift ;; * ) CODE_PROFILE = \"yes\" # don't shift because $2 is some other flag ;; esac ;; --skip-tests ) # skip tests case $2 in\n        yes | Yes | YES ) JF_SKIP_TESTS = \"yes\" shift ;; no | No | NO ) JF_SKIP_TESTS = \"no\" shift ;; * ) JF_SKIP_TESTS = \"yes\" ;; esac ;; --skip-documentation ) case $2 in\n        yes | Yes | YES ) JF_SKIP_DOCS = \"yes\" shift ;; no | No | NO ) JF_SKIP_DOCS = \"no\" shift ;; * ) JF_SKIP_DOCS = \"yes\" ;; esac ;; --help ) print_usage exit 0 ;; --clean ) rm -r -- src { ,/tests } /*.o $DOCDIR * $LIBDIR * $BINDIR * *.gcov* ;; * ) echo \"Unknown flag, \\\" $1 \\\", passed to ${ script_name } !\" 2> & 1\n        print_usage exit 1 ;; esac shift # look at next argument done # with argument parsing loop # if no compiler selected, then we're defaulting to gnu, and need to check that the cflags are set if [ \" $FCOMPILER \" = 'gnu' ] && [ -z \" $FCOMPILERFLAGS \" ] ; then FCOMPILERFLAGS = \" $GNUCOMPILERFLAGS \" fi if [[ $CODE_COVERAGE == [ yY ] * ]] ; then echo \"Trying to compile with code coverage instrumentation.\" COVERAGE = \"-coverage\" fi if [[ $CODE_PROFILE == [ yY ] * ]] ; then echo \"Trying to compile with code profiling instrumentation.\" PROFILING = \"-profile\" fi if [[ $FCOMPILER == custom ]] ; then echo \"Trying to compile with custom compiler, $FC \" CUSTOM =( \"-fc\" \" $FC \" ) fi if [[ $TRY_UNICODE == [ yY ] * ]] ; then echo \"Trying to compile library with Unicode/UCS4 support\" FoBiS.py build -ch -compiler \" ${ FCOMPILER } \" \" ${ CUSTOM [@] } \" -cflags \" ${ FCOMPILERFLAGS } \" -dbld \" ${ BINDIR } \" -s \" ${ INTROSPECDIR } \" -dmod ./ -dobj ./ -t \" ${ UCS4TESTCODE } \" -o \" ${ UCS4TESTCODE %.f90 } \" -colors if \" ${ BINDIR } / ${ UCS4TESTCODE %.f90 } \" ; then DEFINES = \"-DUSE_UCS4 -Wunused-function\" fi fi #build the stand-alone library: echo \"\" echo \"Building library...\" FoBiS.py build -ch -compiler ${ FCOMPILER } \" ${ CUSTOM [@] } \" -cflags \" ${ FCOMPILERFLAGS } ${ DEFINES } \" ${ COVERAGE } ${ PROFILING } -dbld ${ LIBDIR } -s ${ SRCDIR } -dmod ./ -dobj ./ -t ${ MODCODE } -o ${ LIBOUT } -mklib static -colors #build the unit tests (uses the above library): if [[ $JF_SKIP_TESTS ! = [ yY ] * ]] ; then echo \"\" echo \"Building unit tests...\" # FoBiS.py PR #45 work around [ -d \" $BINDIR \" ] || mkdir \" $BINDIR \" for TEST in \" ${ TESTDIR %/ } \" /jf_test_*. [ fF ] 90 ; do THIS_TEST = ${ TEST ##*/ } echo \"Build ${ THIS_TEST %.[fF]90 } \" FoBiS.py build -ch -compiler ${ FCOMPILER } \" ${ CUSTOM [@] } \" -cflags \" ${ FCOMPILERFLAGS } ${ DEFINES } \" ${ COVERAGE } ${ PROFILING } -dbld \" ${ BINDIR } \" -s \" ${ TESTDIR } \" -i \" ${ LIBDIR } \" -libs \" ${ LIBDIR } / ${ LIBOUT } \" -dmod ./ -dobj ./ -t \" ${ THIS_TEST } \" -o \" ${ THIS_TEST %.[fF]90 } \" -colors done else echo \"Skip building the unit tests since \\$JF_SKIP_TESTS has been set to 'true'.\" fi # Run all the tests unless $JF_SKIP_TESTS echo \"\" if [[ $JF_SKIP_TESTS ! = [ yY ] * ]] ; then echo \"Running tests...\" OLD_IGNORES = \" $GLOBIGNORE \" # run next commands in subshell to avoid `cd -` ( cd \" $BINDIR \" GLOBIGNORE = '*.*' # for TEST in jf_test_* ; do # It would be nice to run json output printed to stdout through jsonlint, however, # some tests output more than one json structure and these need to be split echo \"Running ${ TEST } \" \"./ ${ TEST } \" done ) GLOBIGNORE = \" $OLD_IGNORES \" if [[ $CODE_COVERAGE = [ yY ] * ]] ; then for SRCFILE in json_string_utilities.F90 json_value_module.F90 json_file_module.F90 ; do [ -f ${ SRCDIR }${ SRCFILE } .gcov ] && rm ${ SRCDIR }${ SRCFILE } .gcov\n            gcov -o $LIBDIR ${ SRCDIR }${ SRCFILE } if [[ $TRY_UNICODE = [ yY ] * ]] ; then # gcov/gfortran bug work around awk -F ':' '{line=\"\"; for(i=2;i<=NF;i++){line=line\":\"$i}; if (NR > 1) print $1 prevline; prevline=line}; END{print \"        -\"prevline}' ${ SRCFILE } .gcov > ${ SRCFILE } .gcov.fixed && \\ mv ${ SRCFILE } .gcov { .fixed, } # rename so we can merge coverage info mv ${ SRCFILE } .gcov ${ SRCFILE } -unicode.gcov else # rename so we can merge coverage info mv ${ SRCFILE } .gcov ${ SRCFILE } -no-unicode.gcov fi if [ -f ${ SRCFILE } -unicode.gcov ] && [ -f ${ SRCFILE } -no-unicode.gcov ] ; then # merge them ./pages/development-resources/gccr.pl -n -c ${ SRCFILE } -no-unicode.gcov no-unicode \\ ${ SRCFILE } -unicode.gcov unicode > ${ SRCFILE } .gcov else cp ${ SRCFILE } *-unicode.gcov ${ SRCFILE } .gcov fi done FoBiS.py rule -gcov_analyzer . for SRCFILE in json_string_utilities.F90 json_value_module.F90 json_file_module.F90 ; do sed -i \"bak\" -E 's; \\*\\*([a-zA-Z]+[a-zA-Z0-9_]*)\\*\\*; \\*\\*[[\\1]]\\*\\*;' ${ SRCFILE } .gcov.md\n            sed -i \"bak\" -E \"s;, line ([0-9]+);, line [\\1](https://github.com/jacobwilliams/json-fortran/blob/master/src/ ${ SRCFILE } #L\\1);\" ${ SRCFILE } .gcov.md done gcov -o $BINDIR ${ TESTDIR } *. [ Ff ] 90 fi else echo \"Skip running the unit tests since \\$JF_SKIP_TESTS has been set to ${ JF_SKIP_TESTS } .\" fi #build the documentation with ford (if present): echo \"\" if [[ $JF_SKIP_DOCS ! = [ yY ] * ]] ; then if hash ford 2>/dev/null ; then echo \"Building documentation...\" [[ $TRY_UNICODE = [ yY ] * ]] && MACRO_FLAG =( \"-m\" \"USE_UCS4\" ) echo \" $FPP \" > preprocessor-def.md # Override via include in project file, until FORD gets CLI for this ford --debug \" ${ MACRO_FLAG [@] } \" -p \" $PAGESDIR \" \" $FORDMD \" else echo \"FORD not found! Install using: sudo pip install ford\" fi else echo \"Skip building documentation since \\$JF_SKIP_DOCS has been set to ${ JF_SKIP_DOCS } .\" fi Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/build.sh.html","title":"build.sh â€“ JSON-Fortran"},{"text":"This is the Codecov configuration file. comment : layout : header , changes , diff , sunburst coverage : fixes : - doc / src :: src ignore : - src / tests - doc status : patch : default : {} project : default : {} Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/codecov.yml.html","title":"codecov.yml â€“ JSON-Fortran"},{"text":"This is the script that deploys the automatically generated FORD documentation which you are\ncurrently reading. #!/bin/bash # Script to deploy documentation after successfull build of master branch or tag # If running under travis-ci this will automatically deploy updates to the master branch's # documentation on build events for the master branch, and will add/update documentation for # any new/updated tags that are pushed. set -o errexit set -o verbose if [ \" $TRAVIS \" ] ; then #running under travis if $TRAVIS_SECURE_ENV_VARS ; then # only try to update master's development documentation if [ \" $TRAVIS_BRANCH \" = \"master\" ] && \\ [ \" $TRAVIS_PULL_REQUEST \" = \"false\" ] && \\ [ \" $( ls -A \" $TRAVIS_BUILD_DIR /doc\" ) \" ] ; then #not empty git clone -q --branch = gh-pages \"https:// ${ GH_TOKEN } @github.com/ $TRAVIS_REPO_SLUG \" gh-pages >/dev/null 2> & 1 cd gh-pages || exit 1\n        rm -rf -- css fonts interface lists module proc search.html src type favicon.png index.html \\ js media page program sourcefile tipuesearch || true cp -r \" $TRAVIS_BUILD_DIR \" /doc/* .\n            git add -A || true # Add all the new files git commit -m \"Development documentation updated by travis job $TRAVIS_JOB_NUMBER for commits $TRAVIS_COMMIT_RANGE \" || true git push -fq origin gh-pages > /dev/null 2> & 1 || true fi # If publishing a new/updated tag, deploy it's documentation if [ \" $TRAVIS_TAG \" ] && [ \" $( ls -A \" $TRAVIS_BUILD_DIR /doc\" ) \" ] ; then #not empty cd \" $TRAVIS_BUILD_DIR \" || exit 1\n        git clone -q --branch = gh-pages \"https:// ${ GH_TOKEN } @github.com/ $TRAVIS_REPO_SLUG \" gh-pages >/dev/null 2> & 1\n        sed \"2 s/&#94;/version: ${ TRAVIS_TAG } \\n/\" json-fortran.md > json-fortran.tagged.md\n        head json-fortran.tagged.md # Debug output # rebuild FORD documentation without pages, with version info, wiping out any existing tag folder ford --debug -o \"gh-pages/ $TRAVIS_TAG \" json-fortran.tagged.md cd gh-pages || exit 1\n        git add -A # add all new files in $TRAVIS_TAG/ git commit -m \"Tag/release documentation updated by travis job $TRAVIS_JOB_NUMBER for tag $TRAVIS_TAG $TRAVIS_COMMIT \" git push -f -q origin gh-pages >/dev/null 2> & 1 fi fi fi Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/deploy.sh.html","title":"deploy.sh â€“ JSON-Fortran"},{"text":"Below is the source code for gccr.pl , which was downloaded from https://github.com/eel3/gccr on July 23, 2015. This script is used\nby the build.sh script to merge the code coverage\ninformation for the coverage report . #!/usr/bin/env perl # -*- coding: utf-8; tab-width: 8 -*- # vim: fileencoding=UTF-8 shiftwidth=8 softtabstop=8 tabstop=8 # # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, # 2003, 2004, 2005  Free Software Foundation, Inc. # This file is free software; the Free Software Foundation # gives unlimited permission to copy and/or distribute it, # with or without modifications, as long as this notice is preserved. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY, to the extent permitted by law; without # even the implied warranty of MERCHANTABILITY or FITNESS FOR A # PARTICULAR PURPOSE. # # version 0.4.18 : eel3 : changed shebang, fixed indent, specified emacs/vim coding system. # version 0.4.17 : eel3 : fixed error occur when print the line matched /%[&#94;%]/g # version 0.4.16 : eel3 : fixed parse error occur in line 10000 or later # version 0.4.15 : eel3 : avoided warnings caused by uninitialized variable # version 0.4.14 : eel3 : fixed line number indent size for over 99999 line # version 0.4.13 : eel3 : changed warning option # version 0.4.12 : eel3 : fixed problem that extra tab is output, and changed line number to be right-aligned # version 0.4.11 : Nick Groesz : fix potential divide by zero # version 0.4.10 : Nick Groesz : fixed summary in combined coverage, ignore function data, added copyright # version 0.4.9 : Nick Groesz : added combined reporting in print_summary(), changed usage text # version 0.4.8 : Nick Groesz : added -c option (combined coverage) # version 0.4.7 : Nick Groesz : fixed formatting, added comments # version 0.4.6 : Dickson Patton : fixed tagfile option, right justify counts # version 0.4.5 : Nick Groesz : list code generated with #define macros # version 0.4.4 : Dickson Patton : added tagfile option # version 0.4.3 : Nick Groesz : changed around internal data structures, start of version history use strict ; use warnings ; use Getopt:: Long ; # prototypes sub read_args (); # read in command line arguments sub process_files (); # run through each file sub parse_execution_data (); # parse the data from each file sub print_results (); # print gcov data sub print_summary (); # print summary (similary to gcov's summary) sub print_usage (); # print gccr usage text our $tool_name = 'gccr' ; # name of script our $version = 'gccr (GCC) 0.4.18' ; # version of script our $copyright = 'Copyright (C) 2005 Free Software Foundation, Inc. This is free software; see the source for copying conditions.  There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ' ; # copyright notice # internal data our @files ; # gcov file data # # File information: # file_number -  ranges from 0 to NUMBER OF FILES SPECIFIED - 1 # $file[file_number]{'tag'} - user specified file tag # $file[file_number]{'name'} - name of file to be read and parsed # # $file[file_number[{'data'} contains parsed gcov data # # Line information: # line_number - corresponds to the line number of the GCOV file #       and ranges from 1 to NUMBER OF LINES # $data{'line'}[line_number]{'type'} - type of line #                      Can be set to: #                       no_ex -  non-executing code (gcov meta-data, header code, code that has been #ifdef'd out) #                       line -   an executable line of code #                       branch - branch execution information #                       call -   call execution information # # $data{'line'}[line_number]{'count'} -    number of times an executable line, branch, or call was executed # $data{'line'}[line_number]{'raw'} -      raw data straight from gcov file #                          this is only populated in the first file's data structure # $data{'line'}[line_number]{'line_num'} - line number in original source code # Execution information: # $data{'line_count'} -     number of executable lines # $data{'execution_count'} -    number of executed lines our $file_count = 0 ; # number of files read our $line_count = 0 ; # number of lines in gcov data files (should be the same for each file) our $executable_total = 0 ; # number of different executable lines across all files our $executed_total = 0 ; # number of different executable lines across all files that were executed # options our $opt_combined = 0 ; our $opt_help = 0 ; # help option our $opt_version = 0 ; # version option our @tag_files = (); # tagfile(s) option our $opt_nosummary = 0 ; # do not print summary read_args (); process_files (); print_results (); unless ( $opt_nosummary ) { print_summary (); } # Summary:  read command line arguments: # Parameters:   none # Return:   none sub read_args () { unless ( GetOptions ( 'combined' => \\ $opt_combined , 'help' => \\ $opt_help , 'no-summary' => \\ $opt_nosummary , 'tagfile|file=s' => \\ @tag_files , 'version' => \\ $opt_version , ) ) { # if GetOptions returns FALSE, then incorrect options were specified # exit with error print_usage (); exit ( 1 ); } if ( $opt_help ) { print_usage (); exit ( 0 ); } if ( $opt_version ) { print \"$version\\n\" ; print \"$copyright\\n\" ; exit ( 0 ); } # if any number of tag files were specified, then we read tagfiles instead of command line arugments if ( scalar ( @tag_files )) { @files = & read_tagfiles ( @tag_files ); } else { # number of file arguments + number of tag arguments should equal an even number if ( @ARGV % 2 == 1 ) { print ( \"ERROR: file count does not match tag count\\n\" ); exit ( 1 ); } my $i = 0 ; while ( $ARGV [ $i ]) { push @files , { name => $ARGV [ $i ], tag => $ARGV [ $i + 1 ]}; $i += 2 ; } } $file_count = scalar ( @files ); if ( $file_count < 2 ) { print ( \"ERROR: at least two files must be specified\\n\" ); exit ( 1 ); } } # Summary:  read tagfiles specifie dwith the -t option # Parameters:   array of names of tagfiles # Return:   array of name/tag hashes sub read_tagfiles ($) { my @tag_files = @_ ; my @files ; my $l = 0 ; # count of --tagfile=___ options my $m = 0 ; # count of line in the current tagfile foreach my $file ( @tag_files ) { $l ++ ; open ( TAGFILE , $file ) || die \"ERROR: on open of tagfile $l, $file: ($!)\\n\" ; while ( <TAGFILE> ) { $m ++ ; chomp $_ ; if ( /(&#94;([&#94; ]+) *(.*)$)/ ) { push @files , { name => $2 , tag => $3 }; } else { die \"ERROR: invalid file-tag pair on line $m of tagfile $l\\n\" ; } } close ( TAGFILE ); } return ( @files ); } # Summary:  run through all the gcov files and call the parsing function # Parameters:   none # Return:   none sub process_files () { # the first file is used to gather raw data $files [ 0 ]{ 'data' } = parse_execution_data ( $files [ 0 ]{ 'name' }, 1 ); for ( my $i = 1 ; $i < $file_count ; $i ++ ) { $files [ $i ]{ 'data' } = parse_execution_data ( $files [ $i ]{ 'name' }, 0 ); } } # Summary:  parse the gcov file, populating the %data structure # Parameters:   name of file to parse | boolean indicating whether raw (original gcov) data should be saved #       save_raw is set to 1 on the first file parse and set to zero thereafter # Returns:  reference to data hash sub parse_execution_data () { my ( $file , $save_raw ) = @_ ; my %data ; $data { 'line_count' } = 0 ; # number of executable lines in file $data { 'execution_count' } = 0 ; # number of lines that were executed in file stat ( $file ); if ( ! ( - r _ )) { die ( \"ERROR: cannot read file: $file\\n\" ); } if ( ! ( - f _ )) { die ( \"ERROR: not a plain file: $file\\n\" ); } open ( FILE_HANDLE , $file ) || die ( \"ERROR: cannot open file $file: $!\" ); my $file_line_num = 0 ; while ( <FILE_HANDLE> ) { my $line = $_ ; $file_line_num ++ ; chomp $line ; if ( $line =~ /&#94;\\s+-:\\s*(\\d+):(.*)/ ) { # line is gcov preamble or non-executing code my $line_num = $1 ; my $raw = $2 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'no_ex' ; $data { 'line' }[ $file_line_num ]{ 'line_num' } = $line_num ; if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $2 ; } } elsif ( $line =~ /&#94;\\s+#####:\\s*(\\d+):(.*)/ ) { # line was not executed my $line_num = $1 ; my $raw = $2 ; $data { 'line' }[ $file_line_num ]{ 'count' } = 0 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'code' ; $data { 'line' }[ $file_line_num ]{ 'line_num' } = $line_num ; $data { 'line_count' } ++ ; if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $raw ; } } elsif ( $line =~ /&#94;\\s+(\\d+):\\s*(\\d+):(.*)/ ) { # line was executed my $count = $1 ; my $line_num = $2 ; my $raw = $3 ; $data { 'line' }[ $file_line_num ]{ 'count' } = $count ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'code' ; $data { 'line' }[ $file_line_num ]{ 'line_num' } = $line_num ; $data { 'line_count' } ++ ; $data { 'execution_count' } ++ ; if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $raw ; } } elsif ( $line =~ /&#94;branch\\s+(\\d+)/ ) { # line contains branch execution information my $branch_num = $1 ; $data { 'line' }[ $file_line_num ]{ 'num' } = $branch_num ; if ( $line =~ /&#94;branch\\s+\\d+\\s+never executed/ ) { $data { 'line' }[ $file_line_num ]{ 'count' } = 0 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'branch' ; } elsif ( $line =~ /&#94;branch\\s+\\d+\\s+taken (\\d+)%/ ) { $data { 'line' }[ $file_line_num ]{ 'count' } = $1 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'branch' ; } if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $line ; } } elsif ( $line =~ /&#94;call\\s+(\\d+)/ ) { # line contains call execution information my $call_num = $1 ; $data { 'line' }[ $file_line_num ]{ 'num' } = $call_num ; if ( $line =~ /&#94;call\\s+\\d+\\s+never executed/ ) { $data { 'line' }[ $file_line_num ]{ 'count' } = 0 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'call' ; } elsif ( $line =~ /&#94;call\\s+\\d+\\s+returns (\\d+)%/ ) { $data { 'line' }[ $file_line_num ]{ 'count' } = $1 ; $data { 'line' }[ $file_line_num ]{ 'type' } = 'call' ; } if ( $save_raw ) { $data { 'line' }[ $file_line_num ]{ 'raw' } = $line ; } } elsif ( $line =~ /&#94;function/i ) { # function data is ignored } else { # line could not be parsed print ( \"ERROR: cannot parse line $file_line_num in file $file\\n Is this a valid gcov file?\\n\" ); exit ( 1 ); } } close ( FILE_HANDLE ); # check to see if we should save an overall line count (common to all gcov files) if ( $save_raw ) { $line_count = $file_line_num ; } return ( \\ %data ); } # Summary:  print interpolated gcov information # Parameters:   none # Return:   none sub print_results () { my $ftab = '        ' ; my $p_op = ( $line_count <= 99999 ) ? '%5d' : '%13d' ; for ( my $line_i = 1 ; $line_i <= $line_count ; $line_i ++ ) { my $raw_printed = 0 ; # boolean flag to print out the line slurped in from the gcov file my $count_sum = 0 ; # sum of executions across all files for this one line- used for combined coverage reporting my $never_exec = 1 ; # boolean flag that is set to 0 when the current line is executed or executable # in any file. used in combined coverage reporting. my $first_code_line_executed = 0 ; # boolean flag that indicates whether this is the first unique # executed line of code to be found among the gcov files for ( my $file_i = 0 ; $file_i < $file_count ; $file_i ++ ) { # Note that each file is cycled through for every line even if just the raw # data from the first file that ends up being printed. This is because the same # line may be non-executing in one file and executable in another file (because code # may be ifdef'd out). my $type = $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'type' }; no warnings 'uninitialized' ; # XXX: remove warining for $type if ( $type eq 'no_ex' ) { # non-executing code unless ( $raw_printed || $opt_combined ) { printf ( \"$ftab-:$p_op:%s\\n\" , $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }, $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'raw' }); $raw_printed = 1 ; } # nothing additional is printed for non-executing code } elsif ( $type eq 'code' ) { # code that is executable if ( $never_exec ) { # this code is exectuable, so we indicate that in the never_exec flag $never_exec = 0 ; # we only want the number of UNIQUE lines across files that are executable # in the executable_total flag, so this is only incremented once for all # identical lines across each file $executable_total ++ ; } unless ( $raw_printed || $opt_combined ) { printf ( \"$ftab  $p_op:%s\\n\" , $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }, $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'raw' }); $raw_printed = 1 ; } my $count = $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'count' }; if ( $opt_combined ) { $count_sum += $count ; if ( $first_code_line_executed == 0 && $count > 0 ) { $executed_total ++ ; $first_code_line_executed = 1 ; } } else { if ( $count == 0 ) { print '     ####' ; } else { unless ( $first_code_line_executed ) { # update the unique count of code lines executed # across all gcov files $executed_total ++ ; $first_code_line_executed = 1 ; } my $padding = 9 ; $padding -= length ( $count ); printf ( \"%*s%d\" , $padding , ' ' , $count ); } printf ( \":$p_op: \" , $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }); print \"$files[$file_i]{'tag'}\\n\" ; } } elsif ( $type eq 'branch' ) { # branch information my $count = $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'count' }; if ( $opt_combined ) { $count_sum += $count ; } else { if ( $count == 0 ) { print \"branch $files[$file_i]{'data'}{'line'}[$line_i]{'num'} never executed:$files[$file_i]{'tag'}\\n\" ; } else { print \"branch $files[$file_i]{'data'}{'line'}[$line_i]{'num'} taken $count%:$files[$file_i]{'tag'}\\n\" ; } } } elsif ( $type eq 'call' ) { # call information my $count = $files [ $file_i ]{ 'data' }{ 'line' }[ $line_i ]{ 'count' }; if ( $opt_combined ) { $count_sum += $count ; } else { if ( $count == 0 ) { print \"call $files[$file_i]{'data'}{'line'}[$line_i]{'num'} never executed:$files[$file_i]{'tag'}\\n\" ; } else { print \"call $files[$file_i]{'data'}{'line'}[$line_i]{'num'} returns $count%:$files[$file_i]{'tag'}\\n\" ; } } } } if ( $opt_combined ) { # if the combined coverage flag is set then no information is printed in the above for loop # count information is summed into $count_sum and printed on a single line my $type = $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'type' }; no warnings 'uninitialized' ; # XXX: remove warining for $type if ( $type eq 'no_ex' || $type eq 'code' ) { # line is either non-executable or executable code if ( $never_exec ) { # code line is not executable in any file printf ( \"$ftab-:$p_op:%s\\n\" , $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }, $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'raw' }); } else { # line is executable in at least one file if ( $count_sum == 0 ) { print '    #####' ; } else { my $padding = 9 ; $padding -= length ( $count_sum ); printf ( \"%*s%d\" , $padding , ' ' , $count_sum ); } printf ( \":$p_op:%s\\n\" , $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'line_num' }, $files [ 0 ]{ 'data' }{ 'line' }[ $line_i ]{ 'raw' }); } } elsif ( $type eq 'branch' ) { # branch information if ( $count_sum == 0 ) { print \"branch $files[0]{'data'}{'line'}[$line_i]{'num'} never executed\\n\" ; } else { my $percentage = $count_sum / $file_count ; print \"branch $files[0]{'data'}{'line'}[$line_i]{'num'} taken $percentage%\\n\" ; } } elsif ( $type eq 'call' ) { # call information if ( $count_sum == 0 ) { print \"call $files[0]{'data'}{'line'}[$line_i]{'num'} never executed\\n\" ; } else { my $percentage = $count_sum / $file_count ; print \"call $files[0]{'data'}{'line'}[$line_i]{'num'} returns $percentage%\\n\" ; } } } } } # Summary:  prints the line execution percentages for each file and a percentage for all files combined # Parameters:   none # Return:   none sub print_summary () { for ( my $file_i = 0 ; $file_i < $file_count ; $file_i ++ ) { my $file_line_count = $files [ $file_i ]{ 'data' }{ 'line_count' }; my $percentage ; if ( $file_line_count ) { $percentage = ( $files [ $file_i ]{ 'data' }{ 'execution_count' } / $file_line_count ) * 100 ; } else { $percentage = 0 ; } $percentage = sprintf ( '%.2f' , $percentage ); print \"$percentage% of $file_line_count lines executed on target $files[$file_i]{'tag'}\\n\" ; } my $overall_percentage ; if ( $executable_total ) { $overall_percentage = ( $executed_total / $executable_total ) * 100 ; } else { $overall_percentage = 0 ; } $overall_percentage = sprintf ( '%.2f' , $overall_percentage ); print \"$overall_percentage% of $executable_total lines executed across all files\\n\" ; } # Summary:  print tool usage information # Parameters:   none # Return:   none sub print_usage () { print <<END_USAGE; Usage: ./$tool_name [options] <file name> <target id> <file name> <target id> [file name] [target id]... Use $tool_name to compare gcov files generated on different platforms or targets. -h, --help                      Print this help, then exit -v, --version                   Print version number, then exit Input Options: -t, --tagfile                   Take file-tag assignments from a file, not from command-line Ouput Options: -c, --combined          Print combined coverage -n, --no-summmary       Do not print summary END_USAGE } Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/gccr.pl.html","title":"gccr.pl â€“ JSON-Fortran"},{"text":"Coverage analysis Coverage analysis of json_string_utilities.F90 Unexecuted procedures Executed procedures Coverage analysis of json_value_module.F90 Unexecuted procedures Executed procedures Coverage analysis of json_file_module.F90 Unexecuted procedures Executed procedures Coverage analysis The following report was automatically generated from gcov output by the FoBiS.py Fortran build\ntool. gccr.pl was used to\nmerge gcov coverage\nreports, and can be obtained at https://github.com/eel3/gccr . Any\nprocedures surrounded by double square brackets below are internal\nprocedures and do not have their own documentation pageâ€“documentation\nfor these procedures is included in the documentation of the scope in\nwhich they are defined. If procedure coverage is at 100%, also have a look at the Codecov.io coverage suggestions . Coverage analysis of json_string_utilities.F90 Metrics Number of executable lines 270 Number of executed lines 225 83% Number of unexecuted lines 45 17% Average hits per executed line 1044 Number of procedures 10 Number of executed procedures 7 70% Number of unexecuted procedures 3 30% Average hits per executed procedure 173 Unexecuted procedures function default_join_ucs4 , line 551 function to_uni , line 497 function ucs4_join_default , line 533 Executed procedures subroutine integer_to_string : tested 335 times function to_uni_vec : tested 228 times subroutine real_to_string : tested 190 times subroutine compact_real_string : tested 189 times function valid_json_hex : tested 119 times subroutine escape_string : tested 80 times subroutine unescape_string : tested 74 times Report generated by [FoBiS.py](https://github.com/szaghi/FoBiS Coverage analysis of json_value_module.F90 Metrics Number of executable lines 2430 Number of executed lines 1999 82% Number of unexecuted lines 431 18% Average hits per executed line 385784 Number of procedures 139 Number of executed procedures 96 69% Number of unexecuted procedures 43 31% Average hits per executed procedure 34309 Unexecuted procedures function initialize_json_core , line 621 subroutine get_current_line_from_file_sequential , line 4916 subroutine json_update_string_name_ascii , line 2077 subroutine json_update_string_val_ascii , line 2096 subroutine json_value_add_string_name_ascii , line 2505 subroutine json_value_add_string_val_ascii , line 2523 subroutine json_value_add_string_vec_name_ascii , line 2623 subroutine json_value_add_string_vec_val_ascii , line 2643 subroutine json_value_get_child , line 2844 subroutine wrap_json_get_array_with_path , line 4656 subroutine wrap_json_get_by_path , line 3472 subroutine wrap_json_get_double_vec_with_path , line 4003 subroutine wrap_json_get_double_with_path , line 3889 subroutine wrap_json_get_integer_vec_with_path , line 3778 subroutine wrap_json_get_integer_with_path , line 3663 subroutine wrap_json_get_logical_vec_with_path , line 4225 subroutine wrap_json_get_logical_with_path , line 4110 subroutine wrap_json_get_string_vec_with_path , line 4475 subroutine wrap_json_get_string_with_path , line 4344 subroutine wrap_json_parse_string , line 4821 subroutine wrap_json_throw_exception , line 1081 subroutine wrap_json_update_double , line 1938 subroutine wrap_json_update_integer , line 1998 subroutine wrap_json_update_logical , line 1878 subroutine wrap_json_update_string , line 2058 subroutine wrap_json_value_add_double , line 2183 subroutine wrap_json_value_add_double_vec , line 2236 subroutine wrap_json_value_add_integer , line 2283 subroutine wrap_json_value_add_integer_vec , line 2336 subroutine wrap_json_value_add_logical , line 2383 subroutine wrap_json_value_add_logical_vec , line 2436 subroutine wrap_json_value_add_string , line 2487 subroutine wrap_json_value_add_string_vec , line 2603 subroutine wrap_json_value_create_array , line 5428 subroutine wrap_json_value_create_double , line 5234 subroutine wrap_json_value_create_integer , line 5185 subroutine wrap_json_value_create_logical , line 5136 subroutine wrap_json_value_create_null , line 5331 subroutine wrap_json_value_create_object , line 5381 subroutine wrap_json_value_create_string , line 5283 subroutine wrap_json_value_get_by_name_chars , line 2925 subroutine wrap_json_value_remove_if_present , line 1820 subroutine wrap_json_value_rename , line 1007 Executed procedures subroutine parse_string : tested 1055434 times subroutine destroy_json_data : tested 777448 times subroutine json_value_create : tested 388765 times subroutine json_value_add_member : tested 388718 times subroutine to_string : tested 248878 times subroutine push_char : tested 139733 times subroutine parse_number : tested 69864 times subroutine to_integer : tested 50041 times function string_to_integer : tested 49952 times subroutine to_object : tested 39885 times subroutine to_double : tested 20028 times subroutine to_array : tested 19959 times function string_to_double : tested 19943 times subroutine to_logical : tested 9980 times subroutine parse_for_chars : tested 9967 times subroutine [[write_it]] : tested 1757 times function name_equal : tested 471 times function json_count : tested 407 times function json_failed : tested 383 times subroutine json_get_double : tested 256 times subroutine json_value_get_by_name_chars : tested 175 times subroutine [[get_double_from_array]] : tested 132 times subroutine json_get_by_path : tested 118 times subroutine json_value_create_integer : tested 117 times subroutine json_value_add_integer : tested 116 times subroutine json_info : tested 86 times subroutine json_value_create_double : tested 83 times subroutine json_value_add_double : tested 82 times subroutine json_clear_exceptions : tested 79 times subroutine json_initialize : tested 68 times subroutine [[get_double_from_array]] : tested 60 times subroutine json_get_string_with_path : tested 44 times subroutine json_value_create_string : tested 41 times subroutine json_value_add_string : tested 40 times subroutine json_get_string : tested 37 times subroutine json_print_1 : tested 35 times subroutine json_get_integer : tested 33 times subroutine json_value_get_by_index : tested 32 times subroutine json_get_logical : tested 29 times subroutine json_throw_exception : tested 27 times subroutine json_get_integer_with_path : tested 25 times subroutine json_value_create_object : tested 20 times subroutine json_value_create_array : tested 19 times subroutine [[get_logical_from_array]] : tested 18 times subroutine json_parse_string : tested 18 times subroutine json_get_array : tested 17 times function json_value_is_child_of : tested 16 times subroutine json_value_create_logical : tested 15 times subroutine json_value_add_double_vec : tested 14 times subroutine json_value_add_logical : tested 14 times subroutine json_get_array_with_path : tested 13 times subroutine [[get_chars_from_array]] : tested 12 times subroutine [[swap_pointers]] : tested 11 times subroutine json_update_string : tested 11 times subroutine json_parse_file : tested 11 times subroutine json_value_add_string_vec : tested 10 times subroutine [[get_logical_from_array]] : tested 9 times subroutine json_value_swap : tested 8 times subroutine json_value_to_string : tested 8 times subroutine json_check_for_errors : tested 6 times subroutine json_value_add_integer_vec : tested 6 times subroutine json_get_double_with_path : tested 6 times subroutine json_get_double_vec_with_path : tested 6 times subroutine json_value_remove : tested 5 times subroutine [[get_int_from_array]] : tested 5 times subroutine json_traverse : tested 5 times subroutine to_null : tested 5 times subroutine [[is_child_of_callback]] : tested 4 times subroutine json_value_add_logical_vec : tested 4 times subroutine json_print_2 : tested 4 times subroutine json_get_logical_with_path : tested 4 times subroutine json_update_logical : tested 3 times subroutine json_update_double : tested 3 times subroutine json_update_integer : tested 3 times subroutine json_get_parent : tested 3 times subroutine [[get_int_from_array]] : tested 3 times subroutine [[get_chars_from_array]] : tested 3 times subroutine annotate_invalid_json : tested 3 times subroutine json_print_error_message : tested 3 times subroutine destroy_json_core : tested 2 times subroutine json_get_integer_vec_with_path : tested 2 times subroutine json_get_logical_vec_with_path : tested 2 times subroutine json_get_string_vec_with_path : tested 2 times subroutine json_clone : tested 1 times subroutine json_value_rename : tested 1 times subroutine json_value_validate : tested 1 times subroutine json_value_remove_if_present : tested 1 times subroutine json_get_next : tested 1 times subroutine json_get_previous : tested 1 times subroutine json_get_tail : tested 1 times subroutine json_get_integer_vec : tested 1 times subroutine json_get_double_vec : tested 1 times subroutine json_get_logical_vec : tested 1 times subroutine json_get_string_vec : tested 1 times subroutine get_current_line_from_file_stream : tested 1 times subroutine json_value_create_null : tested 1 times Report generated by [FoBiS.py](https://github.com/szaghi/FoBiS Coverage analysis of json_file_module.F90 Metrics Number of executable lines 335 Number of executed lines 280 84% Number of unexecuted lines 55 16% Average hits per executed line 7 Number of procedures 50 Number of executed procedures 33 66% Number of unexecuted procedures 17 34% Average hits per executed procedure 7 Unexecuted procedures subroutine json_file_update_string_name_ascii , line 1247 subroutine json_file_update_string_val_ascii , line 1265 subroutine wrap_json_file_get_double , line 866 subroutine wrap_json_file_get_double_vec , line 904 subroutine wrap_json_file_get_integer , line 790 subroutine wrap_json_file_get_integer_vec , line 828 subroutine wrap_json_file_get_logical , line 942 subroutine wrap_json_file_get_logical_vec , line 980 subroutine wrap_json_file_get_object , line 752 subroutine wrap_json_file_get_string , line 1019 subroutine wrap_json_file_get_string_vec , line 1057 subroutine wrap_json_file_load_from_string , line 537 subroutine wrap_json_file_update_integer , line 1100 subroutine wrap_json_file_update_logical , line 1143 subroutine wrap_json_file_update_real , line 1186 subroutine wrap_json_file_update_string , line 1229 subroutine wrap_json_file_variable_info , line 693 Executed procedures function json_file_failed : tested 93 times subroutine json_file_get_string : tested 34 times subroutine initialize_json_core_in_file : tested 17 times subroutine json_file_destroy : tested 17 times subroutine json_file_load : tested 10 times subroutine json_file_load_from_string : tested 7 times subroutine json_file_print_to_string : tested 7 times subroutine json_file_get_object : tested 7 times subroutine json_file_get_double_vec : tested 5 times subroutine json_file_print_to_console : tested 4 times subroutine json_file_print_1 : tested 4 times subroutine json_file_get_integer : tested 4 times subroutine json_file_update_string : tested 4 times subroutine json_file_get_double : tested 3 times subroutine json_file_print_error_message : tested 2 times function initialize_json_file_v2 : tested 2 times subroutine json_file_move_pointer : tested 2 times subroutine json_file_print_2 : tested 2 times subroutine json_file_variable_info : tested 2 times subroutine json_file_update_logical : tested 2 times subroutine json_file_update_real : tested 2 times subroutine json_file_check_for_errors : tested 1 times subroutine json_file_clear_exceptions : tested 1 times subroutine set_json_core_in_file : tested 1 times subroutine get_json_core_in_file : tested 1 times function initialize_json_file : tested 1 times subroutine json_file_get_root : tested 1 times subroutine json_file_get_integer_vec : tested 1 times subroutine json_file_get_logical : tested 1 times subroutine json_file_get_logical_vec : tested 1 times subroutine json_file_get_string_vec : tested 1 times subroutine json_file_update_integer : tested 1 times subroutine json_file_traverse : tested 1 times Report generated by [FoBiS.py](https://github.com/szaghi/FoBiS Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/json_module.F90.gcov.html","title":"Coverage Analysis â€“ JSON-Fortran"},{"text":"When tagging a new release please follow this checklist so that the\ndocumentation will be updated correctly, and version strings will\nremain accurate. Release Checklist Make sure you are working from the master branch: git checkout master Update the CHANGELOG.md Ensure that the changes listed under Unreleased are up\n    to date and accurate. Look at the latest changes committed to GitHub since the\n    last release ,\n    5.0.2. This will only be accurate if you have\n    not yet updated __VERSION__ . If you have updated __VERSION__ then edit the URL manually to view the\n    changes. Run the github_changelog_generator as follows, and compare the output to the unreleased section of the CHANGELOG.md : github_changelog_generator -o Unreleased.md\n    --unreleased-only --bugs-label \"**Fixed issues:**\"\n    --enhancement-label \"**Enhancements:**\" --issues-label\n    \"**Fixed issues:**\" and make sure that you have a\n    16-digit GitHub token stored in the environment variable CHANGELOG_GITHUB_TOKEN . Compare generated Unreleased.md to the \"Unreleased\" section of CHANGELOG.md and make updates as needed. Rename the \"Unreleased\" section to the new version number Copy the \"Unreleased\" section header and \"Complete\n    Changeset\" link line and insert it just below the TOC In the newly inserted \"Complete Changeset\" URL replace the\n    old version number with the new version number Rename the lower \"Unreleased\" section (with all the\n    changes) to the current version Replace HEAD in the header URL with the new version\n    number Replace HEAD in the \"Complete Changeset\" link with the\n    new version number. Insert the new version section in the TOC just below the\n    \"Unreleased\" entry Add CHANGELOG.md to the git index: git add CHANGELOG.md Add an entry in pages/releases/index.md under the \"Past\n    Releases\" heading Copy/paste the most recent one listed and replace all\n    occurrences of the old version string with the new version\n    string Add pages/releases/index.md to the git index: git add pages/releases/index.md Update the version string in remaining files requiring manual edits: Edit the __VERSION__ file Edit the CMake example on line 123 of README.md Add both files to the git index: git add __VERSION__\n README.md Commit the changes to the master branch: git commit Create the tag: git tag <new version> deploy.sh will publish the documentation for the\n    latest tag from Travis-CI to\n    https://jacobwilliams.github.io/json-fortran/ new_ver / if all\n    goes according to plan Push tags and master to GitHub: git push --tags origin master Draft and publish a new GitHub Release corresponding to the new version Update the Homebrew formula Fork the Homebrew repository Change to your local Homebrew repository: cd $(brew\n    --repository)/Library/Formula Add your fork as a pushable remote: git remote add\n    YOUR_USERNAME https://github.com/YOUR_USERNAME/homebrew.git Make sure you're on the master branch: git checkout master Make sure everything is up to date: brew update (this calls git pull ) Create a new branch from the latest master branch with git\n    checkout -b YOUR_BRANCH_NAME origin/master Edit the json-fortran.rb formula with brew edit\n    json-fortran Do NOT change anything other than the URL and the SHA256\n    checksum at the top of the formula. These should be changed to\n    correspond to the new version of the compressed tarball\n    available on newly minted latest release page Test the changes to make sure that they will be accepted: brew audit --strict --online json-fortran brew rm json-fortran brew install -v json-fortran brew test -v json-fortran Add json-fortran.rb to the index ( git add json-fortran.rb ) Commit your changes with the correct commit message: git\n    commit -m \"json-fortran <new-version-string-here>\" Push changes to your fork: git push --set-upstream\n    YOUR_USERNAME YOUR_BRANCH_NAME Go to https://github.com/Homebrew/homebrew and submit a pull\n    request Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/release-checklist.html","title":"Release Checklist â€“ JSON-Fortran"},{"text":"This is the Travis-CI script\nused to perform continuous integration testing for JSON -Fortran, and\ntrigger automatic documentation deployment. language : python python : - 2.7 sudo : false cache : apt : true pip : true directories : - $HOME /.cache/ pip - $HOME /. local addons : apt : sources : - kalakris - cmake - ubuntu - toolchain - r - test packages : - gfortran - 4.9 - binutils - cmake - python - pip - graphviz # Build matrix : Run the three build systems and tests in parallel env : global : - CHECK_README_PROGS = \"no\" matrix : # CMake build with unit tests , no documentation , with coverage analysis # No unicode so that coverage combined with the build script will cover unicode # and non - unicode code paths - > BUILD_SCRIPT = \"mkdir cmake-build && cd cmake-build && cmake .. && make -j 4 check\" CODE_COVERAGE = \"no\" DEPLOY_DOCUMENTATION = \"no\" # build with build . sh , make documentation , run unit tests and perform coverage analysis - > BUILD_SCRIPT = \"./build.sh --coverage --skip-documentation && ./build.sh --coverage --enable-unicode\" CODE_COVERAGE = \"yes\" DEPLOY_DOCUMENTATION = \"yes\" install : - | if [[ ! - d \"$HOME/.local/bin\" ]]; then mkdir \"$HOME/.local/bin\" fi - export PATH = \"$HOME/.local/bin:$PATH\" - export FC =/ usr /bin/g fortran - 4.9 - ln - fs /usr/bin/gfortran-4.9 \"$HOME/.local/bin/g fortran \" && gfortran --version - ls -l /usr/bin/gfortran-4.9 - ln -fs /usr/bin/gcov-4.9 \" $HOME /.local/bin/g cov \" && gcov --version - | if ! which f90split; then wget http://people.sc.fsu.edu/~jburkardt/f_src/f90split/f90split.f90 && \\ gfortran -o f90split f90split.f90 && \\ mv f90split \" $HOME /.local/bin/ \" && \\ rm f90split.f90 fi - pip install --upgrade pygooglechart - pip install --upgrade graphviz - (pip install --upgrade FoBiS.py && FoBiS.py --version) - (pip install --upgrade ford && ford --version) - (pip install --upgrade git+https://github.com/dmeranda/demjson.git && jsonlint --version) before_script: - | if [[ $CHECK_README_PROGS == [yY]* ]]; then f90split README.md && \\ for f in example*.md; do mv $f src/tests/jf_test_${f%.md}.f90 done fi - | if [ \" $TRAVIS_TAG \" ]; then if [[ \" v$TRAVIS_TAG \" != \" v$ ( cat __VERSION__ ) \" ]]; then echo \" ERROR : You are trying to tag a new release but have a version missmatch in \\ ` __VERSION__ \\ ` \" false # throw an error fi fi script: - echo $BUILD_SCRIPT - bash <<<$BUILD_SCRIPT after_success: - cd $TRAVIS_BUILD_DIR - git config --global user.name \" TRAVIS - CI - for - $ ( git -- no - pager show - s -- format = '%cn' $TRAVIS_COMMIT ) \" - git config --global user.email \" $ ( git -- no - pager show - s -- format = '%ce' $TRAVIS_COMMIT ) \" - | if [[ $DEPLOY_DOCUMENTATION == [ yY ]* ]]; then ./ deploy . sh # publish docs for master branch and tags fi - ( yes | rm - r doc gh - pages ) || true # wipe out doc dirs to avoid confusing codecov - | if [[ $CODE_COVERAGE == [ yY ]* ]]; then rm json_ *. F90 -* unicode . gcov || true mv json_ *. F90 . gcov src / mv jf_test *.[ fF ] 90 . gcov src /tests/ bash <( curl - s https :// codecov . io / bash ) - v - X gcov fi Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/development-resources/travis.yml.html","title":".travis.yml â€“ JSON-Fortran"},{"text":"Official Releases Latest Stable Release Past Releases Development Version Changes Between Releases Change Log Unreleased 5.0.2 (2016-06-11) 5.0.1 (2016-06-11) 5.0.0 (2016-05-09) 4.3.0 (2015-12-05) 4.2.0 (2015-08-03) 4.1.1 (2015-05-27) 4.1.0 (2015-05-05) 4.0.0 (2015-03-16) 3.1.0 (2015-02-28) 3.0.0 (2015-01-18) 2.0.0 (2014-12-27) 1.0.0 (2014-06-23) Official Releases This is where to find the documentation corresponding to an official,\ntagged release. If you are looking for the most current documentation\nof the master branch, please head back to the main page . Latest Stable Release Documentation: 5.0.2 Download: https://github.com/jacobwilliams/json-fortran/releases/latest Past Releases Note: There is currently no way to navigate back to the general/master\ndocumentation from the documentation for official releases other than\nusing the browser's back button. Feel free to bookmark this page, or\nthe main project page for convenient navigation. 5.0.2 ( FORD generated documentation) Download 5.0.1 ( FORD generated documentation) Download 5.0.0 ( FORD generated documentation) Download 4.3.0 ( FORD generated documentation) Download 4.2.0 ( FORD generated documentation) Download 4.1.1 ( ROBODoc generated documentation) Download 4.1.0 ( ROBODoc generated documentation) Download 4.0.0 ( ROBODoc generated documentation) Download 3.1.0 ( ROBODoc generated documentation) Download 3.0.0 ( ROBODoc generated documentation) Download 2.0.0 ( ROBODoc generated documentation) Download 1.0.0 ( ROBODoc generated documentation) Download Development Version Documentation for the latest development version may be found at https://jacobwilliams.github.io/json-fortran/5.0.2/index.html or generated locally using the build.sh build\nscript. Changes Between Releases Included below is the changelogâ€“a list of significant changes\nimplemented between each release. Change Log Table of Contents Change Log Unreleased 5.0.2 (2016-06-11) 5.0.1 (2016-06-11) 5.0.0 (2016-05-09) 4.3.0 (2015-12-05) 4.2.0 (2015-08-03) 4.1.1 (2015-05-27) 4.1.0 (2015-05-05) 4.0.0 (2015-03-16) 3.1.0 (2015-02-28) 3.0.0 (2015-01-18) 2.0.0 (2014-12-27) 1.0.0 (2014-06-23) Unreleased Complete Changeset 5.0.2 (2016-06-11) Complete Changeset or Download v5.0.2 Minor documentation fix. 5.0.1 (2016-06-11) Complete Changeset or Download v5.0.1 Note: This release contains no changes to the library, only the build system and documentation. Fixed issues: FORD now uses the Intel preprocessor when library is built with the Intel compiler #205 ShellCheck script files #181 Merged pull requests: De-lint shell scripts with ShellCheck, debug FORD upgrade, and various updates to documentation and build system. #201 ( zbeekman ) 5.0.0 (2016-05-09) Complete Changeset or Download v5.0.0 See also this Wiki page on how to update your code to be compatible with this release. Enhancements: Split json_module into multiple files. #168 #170 ( jacobwilliams ) The library is now thread safe #36 #170 ( jacobwilliams ) Added new initialize() , failed() , print_error_message() , check_to_errors() , and clear_exceptions() to the json_file class. #170 ( jacobwilliams ) The number of spaces for indenting can now be user specified. #170 ( jacobwilliams ) Updates for Visual Studio project #170 ( jacobwilliams ) Added a validate() method for validating JSON linked lists #196 #197 ( jacobwilliams ) Added some additional error checks for malformed JSON linked lists #182 ( jacobwilliams ) Added a new routine is_child_of to check if one json_value is a descendant of another #182 ( jacobwilliams ) Added new options for case-insensitive searching of names/paths, as well as the option to consider trailing space significant #185 #192 ( jacobwilliams ) Added a routine to enable swapping of elements in a json_value linked list #177 #182 ( jacobwilliams ) Rename parameters RK , IK , LK , CK , and CDK using less generic names ( json_RK , json_IK , json_LK , json_CK , and json_CDK ) #172 ( jacobwilliams ) Calling the initialize() method (which is now in json_core and json_file ) is no longer mandatory #171 ( jacobwilliams ) Added a rename() method for renaming a json_value variable #184 #187 ( jacobwilliams ) Added some compiler directives so that workarounds for Gfortran bugs are not used for other compilers #190 ( jacobwilliams ) Added option for strict typing for get routines #173 ( jacobwilliams ) Various cosmetic changes and renaming of some of the dummy arguments in some procedures. #198 ( jacobwilliams ) Added checks to avoid unnecessary looping when traversing arrays if an exception is thrown #183 ( jacobwilliams ) Added a new get_child method to get the first child. [9d4f736] ( jacobwilliams ) Added some additional error checks for unassociated pointers [9d4f736] ( jacobwilliams ) Ensure null pointers are returned for some error cases [838f476] ( jacobwilliams ) Fixed Issues Fixed a bug in the traverse() routine, where the finished output flag was not being correctly checked #182 ( jacobwilliams ) 4.3.0 (2015-12-05) Complete Changeset or Download v4.3.0 Enhancements: Added routines for getting the parent , next , previous , and tail pointers #161 ( jacobwilliams ) Added a deep copy routine for json_value structures #160 ( jacobwilliams ) Updated the Visual Studio solution to VS 2013. Also removed the test projects (it now just compiles the library) ( jacobwilliams ) Fixed issues: Rewrote logic for decoding strings, and fixed bugs related to parsing strings with certain escape character combinations #164 ( jacobwilliams ) Fixed a bug where some real numbers weren't being read in properly. Also added an option to output real numbers with fmt=* formatting #157 ( jacobwilliams ) Merged pull requests: Minor documentation change. #153 ( jacobwilliams ) Enabled FORD graphs in documentation. #149 ( jacobwilliams ) Tag documentation fix #147 ( zbeekman ) Fix url in 4.2.0 tag documentation #146 ( zbeekman ) 4.2.0 (2015-08-03) Complete Changeset or Download v4.2.0 Enhancements The exception_thrown flag is now true by default before the json_initialize routine is called to initialize the module. #142 ( jacobwilliams ) Updated json_info to get name of json_value variable. #141 ( jacobwilliams ) Added a new routine ( json_traverse ) to traverse all nodes of a JSON structure #140 via PR #144 from  ( jacobwilliams ) Added FORD documentation automatic deployment via PR #137 from zbeekman Added new version release checklist, #122 via PR #137 from zbeekman Added finer control of real format printing, #117 via PR #137 from zbeekman , and #143 from jacobwilliams Removed official SCons support to facilitate faster development\n  cycle, #121 via PR #130 from zbeekman Add a CHANGELOG #120 via PR #123 from zbeekman Spell 'Fortran' correctly #118 via PR #124 from zbeekman Migrate to Codecov.io #106 via PR #107 from zbeekman CMake emulate make check and exclude tests\n  from all target #103 implemented via PR #104 from zbeekman Fixed issues: Fixed bad gcov reports being generated due to a gcov/gfortran bug, #131 via PR #137 from zbeekman Fixed inaccurate coverage reports via PR #109 from zbeekman Fixed a small consistency issue when outputting floating point\n  numbers via PR #125 Problems writing JSON to error_unit (0) due to JSON -Fortran's\n  special interpretation of unit=0 #85 fixed via PR #111 from zbeekman Broken parsing error message for empty line PR #110 ( jacobwilliams ) Merged pull requests: Documentation fixes & coverage improvements #112 ( zbeekman ) Speedier container based Travis-CI builds #130 ( zbeekman ) 4.1.1 (2015-05-27) Complete Changeset or Download v4.1.1 Enhancements Installation now possible with a Homebrew package on Mac OS X CMake install option to use a more traditional\n  Gnu install structure (to support Homebrew installation) PR #101 from zbeekman Fixed issues: Broken Travis-CI tests #99 fixed by PR #100 from zbeekman CMakeLists.txt accidentally defaulting to Unicode build due to small\n  typo #96 ,\n  fixed by PR #97 from zbeekman Merged pull requests: 4.1.0 (2015-05-05) Complete Changeset or Download v4.1.0 Enhancements: Run-time speed improvements #75 implemented in PR #93 from jacobwilliams Merged pull requests: Small formatting and addition of a unit test #95 ( jacobwilliams ) 4.0.0 (2015-03-16) Complete Changeset or Download v4.0.0 Enhancements Unicode support #35 added in PR #84 from zbeekman Automate testing of the stand alone programs listed in the README.md #67 added in PR #71 from zbeekman Automatically analyze and report test coverage info with coveralls.io and Travis-CI #63 implemented in PR #72 from zbeekman Enhanced command line user interface for build.sh build script PR #82 ( zbeekman ) Additional options and improvements made to command line interface\n  of the build.sh build script PR #88 ( zbeekman ) Added unit tests for improved unit test coverage PR #83 ( jacobwilliams ) and PR #73 ( jacobwilliams ) Fixed issues: Stack overflow in destroy for large structure #76 fixed in PR #77 from jacobwilliams Discrepancy with dummy argument attributes for\n  path between get and get_..._vec procedures #79 Small bug fix for CMake install #68 ( zbeekman ) JSON output files from tests are overwriting expected outputs and\n  outputs from other tests #86 ( zbeekman ) NAG Fortran Errors on module procedure :: change to module\n  procedure with no double colon PR #78 from kmanalo CMake for jf_test_9.f90 broke #74 ( zbeekman ) Merged pull requests: Very small changes and fixes: #81 ( zbeekman ) 3.1.0 (2015-02-28) Complete Changeset or Download v3.1.0 Enhancements: Compact real number printing ( 0.0 instead of 0.00000...E000 )\n  with ability to revert to old behavior #39 (implemented in PR #60 from zbeekman and PR #61 from jacobwilliams ) Read JSON structure from a character string #5 Adopted official contributing guidelines and added a CONTRIBUTING.md #47 Fixed issues: Build script ( build.sh ) failing with Intel's ifort #53 ,\n  fixed by PR #54 (from zbeekman ) Segfaults and unexpected behavior due to optional dummy arguments\n  being dereferenced outside of if (present(â€¦)) #52 Documentation not being produced for tests because tests directory\n  should be sub-directory of src #49 Example 8 failing on gfortran 4.9.2 #44 CMake Tests 3 and 8 fail due to new test\n  case, example 6, added in e636f96 #30 CMake build using makefiles fails if\n  parallel build is specified #8 , fixed\n  by PR #50 from zbeekman Merged pull requests: Unit test updates #65 ( jacobwilliams ) Unit test cleanup as discussed in #30 #64 ( zbeekman ) Stops PRs by @jacobwilliams from\n  deploying master docs #62 ( zbeekman ) Auto deploy script #59 ( zbeekman ) Getting ready for auto-deployment #57 ( zbeekman ) Travis-CI build matrix #56 ( zbeekman ) 3.0.0 (2015-01-18) Complete Changeset or Download v3.0.0 Fixed issues: Intel compiler bug triggered by commit d2622a8 #41 Unaligned data warnings with Intel compiler #34 CMake fails due to bad path to robodoc.rc #31 Indentation of output wrong for some nested objects #29 Intel build broke #28 CMake misbehaving when ROBODoc absent #26 Differentiate internal (low level, private) procedures/types/etc\n  from public API in documentation #21 Merged pull requests: CMake Fixes for issues #31 and #26 . #32 ( zbeekman ) 2.0.0 (2014-12-27) Complete Changeset or Download v2.0.0 Enhancements: - Significant changes to the API including new procedures\n- Code re-factoring\n- SCons build added thanks to @bruceravel Fixed issues: enable wiki contributions from the public #23 1.0.0 (2014-06-23) Download v1.0.0 Enhancements: Validate hex values in strings #14 Add CMake build infrastructure #6 (pull request from zbeekman ) CMake build now builds the example program\n  and runs tests #9 Added CMake logic to build ROBODoc documentation #12 (pull\n  request from zbeekman ) Upload ROBODoc documentation to\n  gh-pages project page #7 Add CMake testing infrastructure #18 ( zbeekman ) Implement better support for Intel compiler, DPD200247629 associate construct work around, via PR #2 ( zbeekman ) Fixed issues: Unit tests fail when compiled with GFortran #19 CMake outputs of ROBODoc must be specified in\n  CMakeLists.txt manually #17 Invalid JSON input files ( test1.json , test5.json ) #10 ,\n  fixed by PR #11 ( zbeekman ) char() is processor dependent, use achar() #20 (pull request from zbeekman ) Bug-fix for ROBODoc documentation\n  generation with CMake #16 (pull request from zbeekman ) Change library file from libjson to libjsonfortran #4 * This Change Log was generated with help from github_changelog_generator Documentation pages for a specific release do not contain links\nback to this page and the master documentation. Please use your\nbrowser's back button to navigate back to https://jacobwilliams.github.com/json-fortran/ . â†©","tags":"","loc":"page/releases/index.html","title":"Official Releases â€“ JSON-Fortran"}]}